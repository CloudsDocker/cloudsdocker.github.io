---
title: Cucumber
---
# Acceptance testing vs unit test
It’s sometimes said that unit tests ensure you build the thing right, whereas acceptance tests ensure you build the right thing.

# Cucumber. 
The acceptance testing tool.

# Source of Truth
For many teams, the Cucumber feature files become the definitive source of truth as to what the system does.

# Scenarios
Scenarios are written before production code. They start their life as an executable specification. As the production code emerges, Scenarios take on a role as living documentation and automated tests.

Each Cucumber test is called a scenario, and each scenario contains steps that tell Cucumber what to do. 

# Gherkin
The keywords Feature, Scenario, Given, When, and Then are the structure, and everything else is documentation. 
The structure is called Gherkin.

# Structure
We start with features, which contain our scenarios and steps. The steps of our scenarios call step definitions that provide the link between the Gherkin fea- tures and the application being built.


This principle, deliberately doing the minimum useful work the tests will let us get away with, might seem lazy, but in fact it’s a discipline. It ensures that we make our tests thorough: if the test doesn’t drive us to write the right thing, then we need a better test.

# Step Definitions
Step definitions are the glue that binds your Cucumber tests to the application you’re testing. 

# Sample

## compile and run via CLI
```bash
javac -cp "jars/*" step_definitions/CheckoutSteps.java
java -cp "jars/*:." cucumber.api.cli.Main -p pretty --snippets camelcase \
                          -g step_definitions features
```
Line 1 compiles the CheckoutSteps class that we’ve just created. Then line 2 invokes Cucumber. There are two slight additions to Cucumber’s invocation:
1. We’ve added the current directory “.” to the classpath.
2. We’ve added the -g step_definitions command-line argument to tell Cucumber where to look for the step definitions that it will need to “glue” the steps in the feature file to the checkout application (which we haven’t written yet).

## feature file
```
Feature: Is it Friday yet?
  Everybody wants to know when it's Friday

  Scenario: Sunday isn't Friday
    Given today is Sunday
    When I ask whether it's Friday yet
    Then I should be told "Nope"
```

The first line of this file starts with the keyword Feature: followed by a name. It’s a good idea to use a name similar to the file name.

The second line is a brief description of the feature. Cucumber does not execute this line, it’s just documentation.

The fourth line, Scenario: Sunday is not Friday is a Scenario, which is a concrete example illustrating how the software should behave.

The last three lines starting with Given, When and Then are the steps of our scenario. This is what Cucumber will execute.

Notice how we go from Scenario to Scenario Outline when we start using Examples.
```
Feature: Is it Friday yet?
  Everybody wants to know when it's Friday

  Scenario Outline: Today is or is not Friday
    Given today is <day>
    When I ask whether it's Friday yet
    Then I should be told <answer>

  Examples:
    | day | answer |
    | "Friday" | "TGIF" |
    | "Sunday" | "Nope" |
    | "anything else!" | "Nope" |
```

### TGIF
Thanks God It's Friday

# BDD
The two main practices in the BDD approach are discovery workshops, which bridge the communication gap between business and IT, and executable specifications.

## Discovery Workshops

Discovery workshops (or Specification workshops) are short and frequent meetings where business and IT meet to gain a common understanding of how the software should behave.

## Relationship with TDD
The main difference is that Cucumber operates on a higher abstraction level, closer to the domain and farther away from classes and methods. BDD builds on TDD, while preserving a strong link between the business requirements and the technical solution.

## Outside in
This technique is called Outside-in because programmers typically start with the functionality that is closest to the user (the user interface, which is on the outside of the system) and gradually work towards the guts of the system (business logic, persistence, messaging and so on) as they discover more of what needs to be implemented.

> Your cucumber features should drive your implementation, not reflect it.

This means Cucumber features should be written before the code implementing the feature.

Keeping specifications, regression tests and documentation in a single place reduces the overhead of keeping multiple documents in sync - the Cucumber scenarios work as a shared source of truth for business and IT.

While many people focus on the value added by the automated “tests” you get out of BDD, the real value is actually the shared understanding we get at the beginning.


Cucumber is not a tool for testing software. It is a tool for testing people’s understanding of how software (yet to be written) should behave.

The biggest advantage of BDD approach for software development might be that they describe a set of functions that a user expects from a system in a very concrete and direct manner. The sum of these behaviors essentially document a contract with the user/client. If any of the tests fail, this contract is not upheld.

# Process
the most important stage of BDD. Three amigos (business persons, developers, testers) get together and identify the expected behavior of our product by discussing examples. We can use feature mapping approach to effectively analyse and elaborate the product behavior.

always make sure that your scenarios are not tightly coupled with your tests. Your BDD scenarios should change only when the requirement changes, not when the the implementation changes (i.e. your BDD scenarios must drive the implementation, not the other way around).


# Executable Specification

An Executable Specification is a Definition of Done that you can run as a test. In Behavior Driven Development (BDD), we refer to acceptance criteria as “executable specifications.” Executable Specifications are meant to be clear, unambiguous, written in business terms, and easy to automate. Each acceptance criteria is a concrete example of how a user interacts with the system to achieve some business goal.

The most well-known format for BDD acceptance criteria uses the “Given-When-Then” structure:
```bash
Given <some precondition>
When <something happens>
Then <we expect some outcome>
```
This format is a great way to make sure that we are thinking in terms of the outcomes we want to achieve. After all, the outcomes of an application are where the value lies.

These scenarios are also easy to automate with BDD tools like Cucumber and Specflow.

# No silver bullet
“The hardest single part of building a software system is deciding precisely what to build.”
We’ve all worked on projects where, because of a misunderstanding, code that we’d worked hard on for several days or more had to be thrown away. Better communication between developers and stakeholders is essential to help avoid this kind of wasted time. One technique that really helps facilitate this communication is the use of concrete examples to illustrate what we want the software to do.

## Concrete Examples
By using real-world examples to describe the desired behavior of the system we want to build, we stay grounded in language and terminology that makes sense to our stakeholders: we’re speaking their language. 

To illustrate this, let’s imagine you’re building a credit card payment system. One of the requirements is to make sure users can’t enter bad data. Here’s one way of expressing that:
`Customers should be prevented from entering invalid credit card details.`
This is an example of what Agile teams often call acceptance criteria or condi- tions of satisfaction.1 We use the word acceptance because they tell us what the system must be able to do in order for our stakeholders to find it acceptable.

The previous requirements statement is useful, but it leaves far too much room for ambiguity and misunderstanding. It lacks precision. What exactly makes a set of details invalid? How exactly should the user be prevented from entering them? We’ve seen too many projects get dragged into the tar pit2 by these kind of worthy but vague statements. Let’s try illustrating this requirement with a concrete example:
`If a customer enters a credit card number that isn’t exactly 16 digits long, when they try to submit the form, it should be redisplayed with an error message advising them of the correct number of digits.`

Can you see how much more specific this second statement is? As a developer implementing this feature, we know almost everything we need to be able to sit down and start working on the code. As a stakeholder, we have a much clearer idea of what the developer is going to build.
In fact, a stakeholder reading this might point out that there are certain types of cards that are valid with fewer than 16 digits and give us another example. This is the real power of examples: they stimulate our imagination, enabling us to explore and discover edge cases we might otherwise not have found until much later.

By giving an example to illustrate our requirement, we’ve turned an acceptance criterion into an acceptance test. Now we have something unambiguous that we can use to test the behavior of the system, either manually or by using an automated test script.

# Gherkins

Gherkin use main keywords: Feature, Scenario, Given, When, Then, And, But, Background, Scenario Outline, Examplesand some extra syntax “”” (Doc strings), | (Data tables), @(Tags), # (Comments).

## dry run
```bash
$ java -cp ".:jars/*" cucumber.api.cli.Main -g step_definitions --dry-run features 
```
The --dry-run switch tells Cucumber to parse the file without executing it. It
will tell you if your Gherkin isn’t valid.

## CucumberOptions
the @CucumberOptions. One can define the location of features, glue files (step definitions), and formatter plugins inside this Cucumber options. 

```java
@CucumberOptions(
        features = "src/test/resources/features",
        glue = {"stepdefs"},
        tags = {"~@Ignore"},
        format = {
                "pretty",
                "html:target/cucumber-reports/cucumber-pretty",
                "json:target/cucumber-reports/CucumberTestReport.json",
                "rerun:target/cucumber-reports/rerun.txt"
        })
public class TestRunner {
```


### Step definitions
Cucumber doesn’t know how to execute your scenarios out-of-the-box. It needs Step Definitions to translate plain text Gherkin steps into actionsthat will interact with the system. When Cucumber executes a Step in a Scenario, it will look for a matching Step Definition to execute.

### After
one can implement initial configurations of the project in TestNG’s BeforeClass method. In cucumber’s Before hook, one can implement code to open web browser which is a prerequisite for all scenarios. In Background of each feature, one can implement steps to navigate to web site and/or login to account. In Cucumber’s After hook, one can take a snapshot of failure and close the browser.

## tags
Grouping Features, Scenarios, and Step Definitions using Tags
Tags is a great way made for Cucumber power users to organize their features and scenarios. In above example, by changing tags = {“~@Ignore”} line totags = {“@UpdateProfile”}, one can choose run only the features and scenarios tagged with @UpdateProfile tag. A Scenario or feature can have as many tags as you like. Just separate them with spaces: @important @maintenance @db @auth

### config tag
Tags

Tags are a great way to organise your features and scenarios. Consider this example:

@billing
Feature: Verify billing

  @important
  Scenario: Missing product description
    Given hello

  Scenario: Several products
    Given hello
A feature or scenario or can have as many tags as you like. Just separate them with spaces:

@billing @bicker @annoy
Feature: Verify billing
Tags can be placed above the following Gherkin elements:

Feature
Scenario
Scenario Outline
Examples
It is not possible to place tags above Background or steps (Given, When, Then, And and But).

# Cucumber for java 8 lambda
Using Lambda Expressions for Step Definitions
Java Step Definitions are written in regular classes which don’t need to extend or implement anything. They can be written either using lambda expressions or method annotations. In the above, we used the method annotations. To use lambda expressions, use cucumber-java8 module instead of cucumber-java module in your pom.xml file.

When you use the cucumber-java8 module, you can write the Step Definitions using lambdas:

```java
package cucumber;

import cucumber.api.java8.En;
 
public class StepDefinitions implements En {
    public StepDefinitions() {
        Given("I have (\\d+) cukes in my belly", (Integer cukes) -> {
            System.out.format("Cukes: %n\n", cukes);
        });
    }
}


package steps;
 
import cucumber.api.java8.En;
 
public class MyStepdefs implements En {
 
    public MyStepdefs() {
       Given("I login as (.*)$",(String name)-> System.out.println(name));
    }
}

```

# Gherkin
Cucumber tests are expressed using a syntax called Gherkin. Gherkin files are plain text and have a .feature extension.

# Reference
- https://medium.com/agile-vision/cucumber-bdd-part-2-creating-a-sample-java-project-with-cucumber-testng-and-maven-127a1053c180
- https://codoid.com/cucumber-lambda-expressions/