---
title: Cucumber
---
# Acceptance testing vs unit test
It’s sometimes said that unit tests ensure you build the thing right, whereas acceptance tests ensure you build the right thing.

# Cucumber. 
The acceptance testing tool.

# Source of Truth
For many teams, the Cucumber feature files become the definitive source of truth as to what the system does.

# Scenarios
Scenarios are written before production code. They start their life as an executable specification. As the production code emerges, Scenarios take on a role as living documentation and automated tests.

Each Cucumber test is called a scenario, and each scenario contains steps that tell Cucumber what to do. 

# Gherkin
The keywords Feature, Scenario, Given, When, and Then are the structure, and everything else is documentation. 
The structure is called Gherkin.

Cucumber features are all about communicating with business users in their language, and it’s important that we don’t force them to sound like robots.

# Structure
We start with features, which contain our scenarios and steps. The steps of our scenarios call step definitions that provide the link between the Gherkin fea- tures and the application being built.


This principle, deliberately doing the minimum useful work the tests will let us get away with, might seem lazy, but in fact it’s a discipline. It ensures that we make our tests thorough: if the test doesn’t drive us to write the right thing, then we need a better test.

# Step Definitions
Step definitions are the glue that binds your Cucumber tests to the application you’re testing. 

# Sample

## compile and run via CLI
```bash
javac -cp "jars/*" step_definitions/CheckoutSteps.java
java -cp "jars/*:." cucumber.api.cli.Main -p pretty --snippets camelcase \
                          -g step_definitions features
```
Line 1 compiles the CheckoutSteps class that we’ve just created. Then line 2 invokes Cucumber. There are two slight additions to Cucumber’s invocation:
1. We’ve added the current directory “.” to the classpath.
2. We’ve added the -g step_definitions command-line argument to tell Cucumber where to look for the step definitions that it will need to “glue” the steps in the feature file to the checkout application (which we haven’t written yet).

## feature file
```
Feature: Is it Friday yet?
  Everybody wants to know when it's Friday

  Scenario: Sunday isn't Friday
    Given today is Sunday
    When I ask whether it's Friday yet
    Then I should be told "Nope"
```

The first line of this file starts with the keyword Feature: followed by a name. It’s a good idea to use a name similar to the file name.

The second line is a brief description of the feature. Cucumber does not execute this line, it’s just documentation.

The fourth line, Scenario: Sunday is not Friday is a Scenario, which is a concrete example illustrating how the software should behave.

The last three lines starting with Given, When and Then are the steps of our scenario. This is what Cucumber will execute.

Notice how we go from Scenario to Scenario Outline when we start using Examples.
```
Feature: Is it Friday yet?
  Everybody wants to know when it's Friday

  Scenario Outline: Today is or is not Friday
    Given today is <day>
    When I ask whether it's Friday yet
    Then I should be told <answer>

  Examples:
    | day | answer |
    | "Friday" | "TGIF" |
    | "Sunday" | "Nope" |
    | "anything else!" | "Nope" |
```

### TGIF
Thanks God It's Friday

# BDD
The two main practices in the BDD approach are discovery workshops, which bridge the communication gap between business and IT, and executable specifications.

## Discovery Workshops

Discovery workshops (or Specification workshops) are short and frequent meetings where business and IT meet to gain a common understanding of how the software should behave.

## Relationship with TDD
The main difference is that Cucumber operates on a higher abstraction level, closer to the domain and farther away from classes and methods. BDD builds on TDD, while preserving a strong link between the business requirements and the technical solution.

## Outside in
This technique is called Outside-in because programmers typically start with the functionality that is closest to the user (the user interface, which is on the outside of the system) and gradually work towards the guts of the system (business logic, persistence, messaging and so on) as they discover more of what needs to be implemented.

> Your cucumber features should drive your implementation, not reflect it.

This means Cucumber features should be written before the code implementing the feature.

Keeping specifications, regression tests and documentation in a single place reduces the overhead of keeping multiple documents in sync - the Cucumber scenarios work as a shared source of truth for business and IT.

While many people focus on the value added by the automated “tests” you get out of BDD, the real value is actually the shared understanding we get at the beginning.


Cucumber is not a tool for testing software. It is a tool for testing people’s understanding of how software (yet to be written) should behave.

The biggest advantage of BDD approach for software development might be that they describe a set of functions that a user expects from a system in a very concrete and direct manner. The sum of these behaviors essentially document a contract with the user/client. If any of the tests fail, this contract is not upheld.

# Process
the most important stage of BDD. Three amigos (business persons, developers, testers) get together and identify the expected behavior of our product by discussing examples. We can use feature mapping approach to effectively analyse and elaborate the product behavior.

always make sure that your scenarios are not tightly coupled with your tests. Your BDD scenarios should change only when the requirement changes, not when the the implementation changes (i.e. your BDD scenarios must drive the implementation, not the other way around).


# Executable Specification

An Executable Specification is a Definition of Done that you can run as a test. In Behavior Driven Development (BDD), we refer to acceptance criteria as “executable specifications.” Executable Specifications are meant to be clear, unambiguous, written in business terms, and easy to automate. Each acceptance criteria is a concrete example of how a user interacts with the system to achieve some business goal.

The most well-known format for BDD acceptance criteria uses the “Given-When-Then” structure:
```bash
Given <some precondition>
When <something happens>
Then <we expect some outcome>
```
This format is a great way to make sure that we are thinking in terms of the outcomes we want to achieve. After all, the outcomes of an application are where the value lies.

These scenarios are also easy to automate with BDD tools like Cucumber and Specflow.

# No silver bullet
“The hardest single part of building a software system is deciding precisely what to build.”
We’ve all worked on projects where, because of a misunderstanding, code that we’d worked hard on for several days or more had to be thrown away. Better communication between developers and stakeholders is essential to help avoid this kind of wasted time. One technique that really helps facilitate this communication is the use of concrete examples to illustrate what we want the software to do.

## Concrete Examples
By using real-world examples to describe the desired behavior of the system we want to build, we stay grounded in language and terminology that makes sense to our stakeholders: we’re speaking their language. 

To illustrate this, let’s imagine you’re building a credit card payment system. One of the requirements is to make sure users can’t enter bad data. Here’s one way of expressing that:
`Customers should be prevented from entering invalid credit card details.`
This is an example of what Agile teams often call acceptance criteria or condi- tions of satisfaction.1 We use the word acceptance because they tell us what the system must be able to do in order for our stakeholders to find it acceptable.

The previous requirements statement is useful, but it leaves far too much room for ambiguity and misunderstanding. It lacks precision. What exactly makes a set of details invalid? How exactly should the user be prevented from entering them? We’ve seen too many projects get dragged into the tar pit2 by these kind of worthy but vague statements. Let’s try illustrating this requirement with a concrete example:
`If a customer enters a credit card number that isn’t exactly 16 digits long, when they try to submit the form, it should be redisplayed with an error message advising them of the correct number of digits.`

Can you see how much more specific this second statement is? As a developer implementing this feature, we know almost everything we need to be able to sit down and start working on the code. As a stakeholder, we have a much clearer idea of what the developer is going to build.
In fact, a stakeholder reading this might point out that there are certain types of cards that are valid with fewer than 16 digits and give us another example. This is the real power of examples: they stimulate our imagination, enabling us to explore and discover edge cases we might otherwise not have found until much later.

By giving an example to illustrate our requirement, we’ve turned an acceptance criterion into an acceptance test. Now we have something unambiguous that we can use to test the behavior of the system, either manually or by using an automated test script.

# Gherkins

Gherkin use main keywords: Feature, Scenario, Given, When, Then, And, But, Background, Scenario Outline, Examplesand some extra syntax “”” (Doc strings), | (Data tables), @(Tags), # (Comments).

## dry run
```bash
$ java -cp ".:jars/*" cucumber.api.cli.Main -g step_definitions --dry-run features 
```
The --dry-run switch tells Cucumber to parse the file without executing it. It
will tell you if your Gherkin isn’t valid.

# Replacing Given/When/Then with Bullets
Some people find Given, When, Then, And, and But a little verbose. There is an additional keyword you can use to start a step: * (an asterisk). We could have written the previous scenario like this:
Scenario: Attempt withdrawal using stolen card * I have $100 in my account
* my card is invalid
* I request $50
* my card should not be returned
* I should be told to contact the bank
To Cucumber, this is exactly the same scenario. Do you find this version easier to read? Maybe. Did some of the meaning get lost? Maybe. It’s up to you and your team how you want to word things. The only thing that matters is that everybody understands what’s communicated.

## CucumberOptions
the @CucumberOptions. One can define the location of features, glue files (step definitions), and formatter plugins inside this Cucumber options. 

```java
@CucumberOptions(
        features = "src/test/resources/features",
        glue = {"stepdefs"},
        tags = {"~@Ignore"},
        format = {
                "pretty",
                "html:target/cucumber-reports/cucumber-pretty",
                "json:target/cucumber-reports/CucumberTestReport.json",
                "rerun:target/cucumber-reports/rerun.txt"
        })
public class TestRunner {
```


### Step definitions
Cucumber doesn’t know how to execute your scenarios out-of-the-box. It needs Step Definitions to translate plain text Gherkin steps into actionsthat will interact with the system. When Cucumber executes a Step in a Scenario, it will look for a matching Step Definition to execute.

### After
one can implement initial configurations of the project in TestNG’s BeforeClass method. In cucumber’s Before hook, one can implement code to open web browser which is a prerequisite for all scenarios. In Background of each feature, one can implement steps to navigate to web site and/or login to account. In Cucumber’s After hook, one can take a snapshot of failure and close the browser.

## tags
Grouping Features, Scenarios, and Step Definitions using Tags
Tags is a great way made for Cucumber power users to organize their features and scenarios. In above example, by changing tags = {“~@Ignore”} line totags = {“@UpdateProfile”}, one can choose run only the features and scenarios tagged with @UpdateProfile tag. A Scenario or feature can have as many tags as you like. Just separate them with spaces: @important @maintenance @db @auth

### config tag
Tags

Tags are a great way to organise your features and scenarios. Consider this example:

@billing
Feature: Verify billing

  @important
  Scenario: Missing product description
    Given hello

  Scenario: Several products
    Given hello
A feature or scenario or can have as many tags as you like. Just separate them with spaces:

@billing @bicker @annoy
Feature: Verify billing
Tags can be placed above the following Gherkin elements:

Feature
Scenario
Scenario Outline
Examples
It is not possible to place tags above Background or steps (Given, When, Then, And and But).

# Cucumber for java 8 lambda
Using Lambda Expressions for Step Definitions
Java Step Definitions are written in regular classes which don’t need to extend or implement anything. They can be written either using lambda expressions or method annotations. In the above, we used the method annotations. To use lambda expressions, use cucumber-java8 module instead of cucumber-java module in your pom.xml file.

When you use the cucumber-java8 module, you can write the Step Definitions using lambdas:

```java
package cucumber;

import cucumber.api.java8.En;
 
public class StepDefinitions implements En {
    public StepDefinitions() {
        Given("I have (\\d+) cukes in my belly", (Integer cukes) -> {
            System.out.format("Cukes: %n\n", cukes);
        });
    }
}


package steps;
 
import cucumber.api.java8.En;
 
public class MyStepdefs implements En {
 
    public MyStepdefs() {
       Given("I login as (.*)$",(String name)-> System.out.println(name));
    }
}

```

# Gherkin
Cucumber tests are expressed using a syntax called Gherkin. Gherkin files are plain text and have a .feature extension.

# Steps and Step Definitions
Let’s start by clarifying the distinction between a step and a step definition.
Each Gherkin scenario is made up of a series of steps, written in plain lan- guage. On its own, a step is just documentation; it needs a step definition to bring it to life. A step definition is a piece of code that says to Cucumber, “If you see a step that looks like this..., then here’s what I want you to do....”
When Cucumber tries to execute each step, it looks for a matching step defi- nition to execute. So, how does Cucumber match a step definition to a step?

# Creating a Step Definition
If Cucumber sees a step definition with this regular expression, it will execute it when it comes to the first step of our scenario. So, how do we create a step definition?

Step definitions live in ordinary files. To create a step definition in Java, you use a special Cucumber annotation, such as @Given, like this:
@Given("I have \\$100 in my Account")
public void iHave$100InMyAccount() throws Throwable {
    // TODO: code that puts $100 into User's Account goes here
}


## Given, When, Then Are the Same
It doesn’t actually matter which of the three methods you use to register a step definition, because Cucumber ignores the keyword when matching a step. Under the hood, all of the annotations are aliases for StepDefAnnotation.

The best way we’ve found to avoid this kind of problem is to pay careful attention to the precise wording in your steps. You could change both steps to be less ambiguous:
Given I have deposited $100 in my Account Then the balance of my Account should be $100
By rewording the steps like this, you’ve made them better at communicating exactly what they will do when executed. Learning to spot and remove this kind of ambiguity is something that takes practice. Paying attention to the distinction in wording between two steps like this can also give you hints about concepts that may not be expressed in your code but need to be. It might seem pedantic, but we’ve found that teams who pay this much careful attention to detail write much better software, faster.


### Alternation
We can specify a wildcard in a regular expression using a few different approaches. One of the simplest is alternation, where we express different options separated by a pipe character |, like this:
```java
@Given("I have deposited \\$(100|250) in my Account") public void iHaveDeposited$InMyAccount(int amount) {
  // TODO: code goes here
}
```
This step definition will now match a step with either of the two values 100 or 250 in it, and the number will be captured and passed to the method as an argument. Alternation can be useful if there are a fixed set of values that you want to accept in your step definition, but normally you’ll want something a little looser.

### The Dot
The dot is a metacharacter, meaning it has magical powers in a regular expression. Literally, a dot means match any single character. So, we can try this instead:
```java
@Given("I have deposited \\$(...) in my Account") public void iHaveDeposited$InMyAccount(int amount) {
  // TODO: code goes here
}
```
That will now match a step with any three-figure dollar sum and send the matched amount into the method. 

#### What If I Actually Want to Match a Dot?
   
Any of the metacharacters like the dot can be escaped by preceding them with a backslash. So, if you wanted to specifically match, say 3.14, you could use "3\\.14".
You might have noticed that there’s a backslash in front of the dollar amount in the step definition we’re using. That’s because $ itself is a metacharacter (it’s an anchor, which we’ll explain later), so we need to escape to make it match a normal dollar sign.

## Star modifier
The star modifier means any number of times. So, with .* we’re capturing any character, any number of times. Now we’re getting somewhere—this will allow us to capture all those different amounts. But there’s still a problem.
The star modifier is a bit of a blunt instrument. Because we’re using it with the dot that matches any character, it will gobble up any text at all up until the phrase in my Account. This is why, in regex terminology, the star modifier is known as a greedy operator. For example, it would happily match this step:
Given I have deposited $1 and a cucumber in my Account
The amount captured by our regular expression in this case would be 1 and a cucumber. We need to be more specific about the characters we want to match and just capture numbers. Instead of a dot, we can use something else.

### Character Classes
Character classes allow you to tell the regular expression engine to match one of a range of characters. You just place all of the characters you would accept inside square brackets:

```java
@Given("I have deposited \\$([01234567890]*) in my Account") public void iHaveDeposited$InMyAccount(int amount) {
  // TODO: code goes here
}
For a continuous range of characters like we have, you can use a hyphen:
@Given("I have deposited \\$([0-9]*) in my Account") public void iHaveDeposited$InMyAccount(int amount) {
  // TODO: code goes here
}
```

### Shorthand Character Classes
For common patterns of characters like [0-9], there are a few shorthand char- acter classes that you can use instead. You may find this just makes your regular expressions more cryptic, but there are only a few to learn. For a digit, you can use \d as a shorthand for [0-9]:
```java
@Given("I have deposited \\$(\\d*) in my Account") public void iHaveDeposited$InMyAccount(int amount) {
  // TODO: code goes here
}
```
Here are the most useful shorthand character classes: \d stands for digit, or [0-9].
\w stands for word character, specifically [A-Za-z0-9_]. Notice that underscores and digits are included but not hyphens.
\s stands for whitespace character, specifically [ \t\r\n]. That means a space, a tab, or a line break.
\b stands for word boundary, which is a lot like \s but actually means the opposite of \w. Anything that is not a word character is a word boundary.
You can also negate shorthand character classes by capitalizing them, so for example, \D means any character except a digit.
Back to matching our amount. It looks like we’re done, but there’s one last problem to fix. Can you see what it is?


### question mark
Like the star and the plus, the question mark modifies the character that precedes it, specifying how many times it can be repeated. The question mark modifier means zero or one times; in other words, it makes the preceding character optional. In step definitions, it’s particularly useful for plurals:
@Given("I have (\\d+) cucumbers? in my basket") public void iHaveCucumbersInMyBasket(int number) {
  // TODO: code goes here
}

### noncapturing group
@When("I (?:visit|go to) the homepage") public void iVisitTheHomepage() {
  // TODO: code goes here
}
Notice that we’ve had to prefix the list of alternates with another bit of regular expression magic. The ?: at the start of the group marks it as noncapturing, meaning Cucumber won’t pass it as an argument to our block.


### Anchors
The undefined steps start with a ^ and end with a $. These two metacharacters are called anchors, because they’re used to tie down each end of the regular expression to the beginning and end of the string that they match on.

Generally, it’s best to keep your regular expressions as tight as you can so that there’s less chance of two step definitions clashing with each other.
# Reference
- https://medium.com/agile-vision/cucumber-bdd-part-2-creating-a-sample-java-project-with-cucumber-testng-and-maven-127a1053c180
- https://codoid.com/cucumber-lambda-expressions/