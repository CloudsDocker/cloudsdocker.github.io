---
layout: page
title: Java Enum Misc
tags:
- java
- enum
---
# Enum Misc

- All enums implicitely extends **java.lang.Enum**
- Enum in Java are **type-safe**
- You can specify values of enum constants at the **creation** time. **Enum.values()** returns an array of MyEnumâ€™s values.
- Enum constants are implicitly static and final and can not be changed once created.
- Enum can be safely compare using:
   - Switch-Case Statement
   - == Operator
   - .equals() method
- You can not create instance of enums by using new operator in Java because constructor of Enum in Java can only be private and Enums constants can only be created inside Enums itself.
- Instance of Enum in Java **is created when** any Enum constants are **first called or referenced** in code.
- An enum can be declared outside or inside a class, but NOT in a method.
- An enum declared outside a class must NOT be marked static, final , abstract, protected , or private
- Enums can contain constructors, methods, variables, and constant class bodies.
- enum constructors can have arguments, and can be overloaded.
- enum constructors can NEVER be invoked directly in code. They are always called automatically when an enum is initialized.
- The semicolon at the end of an enum declaration is optional.

These are legal:
```java
    enum Foo { ONE, TWO, THREE}
    enum Foo { ONE, TWO, THREE};
```

# type safe
The advantage of this style of enumeration over the C/C++-style enum or constants is that they are **type-safe**, meaning that, for example, if you define a method
```java
public void setSuit(Suit suit) { ... }
```
the caller cannot pass in a value that does not correspond to an enumeration value

# Language level features
- Since enumeration instances are all effectively **singletons**, they can be compared for equality using identity ("==").
- In Java 5.0, the enum keyword is introduced as a special type of class that always extends **java.lang.Enum**.
- Note that the enumeration values are still **static class members**, though not declared as such.
- Enum is implemented using **Arrays and common operations result in constant time**. So if you are thinking of an high-performance Map, EnumMap could be a decent choice for enumeration data. We have already seen many examples of Java enum in our article 10 Examples of enum in Java  and using Enum as thread-safe Singleton. In this Java tutorial, we will see simple examples of using EnumMap in Java. 
- All keys used in EnumMap must be  from same Enum type which is specified while creating EnumMap in Java. For example if you can not use different enum instances from two different enum.
- EnumMap is ordered collection and they are maintained in the natural order of their keys( natural order of keys means  the order on which enum constant are declared inside enum type ). you can verify this while Iterating over an EnumMap in Java.
- Iterators of EnumMap are fail-fast Iterator , much like of ConcurrentHashMap and doesn't throw ConcurrentModificationException and may not show effect of any modification on EnumMap during Iteration process.
- You can not insert null keys inside EnumMap in Java.  EnumMap doesn't allow null key and throw NullPointerException, at same time null values are permitted.
- EnumMap is not synchronized and it has to be synchronized manually before using it in a concurrent or multi-threaded environment. like synchronized Map in Java  you can also make EnumMap synchronized by using Collections.synchronizedMap() method and as per javadoc this should be done while creating EnumMap in java to avoid accidental non synchronized access.

Read more: http://javarevisited.blogspot.com/2012/09/what-is-enummap-in-java-example-tutorial.html#ixzz4W6Yj4suq



Read more: http://javarevisited.blogspot.com/2012/09/what-is-enummap-in-java-example-tutorial.html#ixzz4W6YeTsfc



Read more: http://javarevisited.blogspot.com/2012/09/what-is-enummap-in-java-example-tutorial.html#ixzz4W6YalWYy


Read more: http://javarevisited.blogspot.com/2012/09/what-is-enummap-in-java-example-tutorial.html#ixzz4W6YVIyRB



Read more: http://javarevisited.blogspot.com/2012/09/what-is-enummap-in-java-example-tutorial.html#ixzz4W6YMLrn2


Read more: http://javarevisited.blogspot.com/2012/09/what-is-enummap-in-java-example-tutorial.html#ixzz4W6Xud2j2


# Reverse lookup
Often in your object model it is common to have data that is naturally "associated" with an enumeration. Since an enum is a class, it is easy to represent this associated information as class fields. Often it is desirable to "lookup" the associated enumeration using the field value. This is easy to do using a static java.util.Map. Take, for example, a Status enum that has an associated status code.
```java
public enum Status
{
     WAITING(0),
     READY(1),
     SKIPPED(-1),
     COMPLETED(5);

     private static final Map<Integer,Status> lookup
          = new HashMap<Integer,Status>();

     static {
          for(Status s : EnumSet.allOf(Status.class))
               lookup.put(s.getCode(), s);
     }

     private int code;

     private Status(int code) {
          this.code = code;
     }

     public int getCode() { return code; }

     public static Status get(int code) {
          return lookup.get(code);
     }
}
```
# Sleek EnumMap
Why would I use an EnumMap rather than a HashMap?  The primary reasons boil down to some inherent advantages of Java's enum as stated in the Javadoc documentation for EnumMap: "Enum maps are represented internally as arrays. This representation is extremely compact and efficient." Later in the same Javadoc documentation, there is an "Implementation Note" that states: "All basic operations execute in constant time. They are likely (though not guaranteed) to be faster than their HashMap counterparts."

The Javadoc documentation states similar advantages for the EnumSet over the HashSet:

> Enum sets are represented internally as **bit vectors**. This representation is extremely **compact and efficient**. The space and time performance of this class should be good enough to allow its use as a high-quality, typesafe alternative to traditional int-based 'bit flags.'  ... Implementation note: All basic operations execute **in constant time**. They are likely (though not guaranteed) to be much faster than their HashSet counterparts. Even **bulk operations execute in constant time** if their argument is also an enum set.





## Reference
- http://crunchify.com/why-and-for-what-should-i-use-enum-java-enum-examples/
- http://www.ajaxonomy.com/2007/java/making-the-most-of-java-50-enum-tricks
- http://www.javaworld.com/article/2073430/the-sleek-enummap-and-enumset.html
