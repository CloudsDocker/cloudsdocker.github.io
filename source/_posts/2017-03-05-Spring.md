---
layout: page
title: Spring notes
tags:
- java
- spring
---

# Spring in action

## AOP

```java
 execution(* concert.Performance.perform())  and !bean('woodstock')
 @Aspect
public class Audience {
  @Before("execution(** concert.Performance.perform(..))")
  public void silenceCellPhones() {
Before performance
```

- Fortunately, there’s a way: the @Pointcut annotation defines a reusable pointcut within an @AspectJ aspect. The next listing shows the Audience aspect, updated to use @Pointcut.

- Reuse pointuct
```java
@Aspect
public class Audience {
  @Pointcut("execution(** concert.Performance.perform(..))")
  public void performance() {} //Define named pointcut

    @Before("performance()")
  public void silenceCellPhones() {
    System.out.println("Silencing cell phones");
  @Before("performance()")
  public void takeSeats() {
    System.out.println("Taking seats");
  }
```

- The body of the performance() method is irrelevant and, in fact, should be empty. The method itself is just a marker, giving the @Pointcut annotation something to attach itself to.




```java
import org.aspectj.lang.ProceedingJoinPoint; public class Audience {
public void watchPerformance(ProceedingJoinPoint jp) { try {

System.out.println("Silencing cell phones"); System.out.println("Taking seats");
```

```xml
<aop:config>
<aop:aspect ref="audience">
<aop:pointcut
id="performance"
expression="execution(** concert.Performance.perform(..))" />
<aop:around     Declare around advice
        
pointcut-ref="performance" method="watchPerformance"/> </aop:aspect>
</aop:config>   
```

- to use AspectJ’s @DeclareParents annota¬tion to magically introduce a new method into an advised bean. But AOP introduc¬tions aren’t exclusive to AspectJ. Using the <aop:declare-parents> element from Spring’s aop namespace, you can do similar magic in XML.


- Listing 1.7 Spring offers Java-based configuration as an alternative to XML.
```java
package com.springinaction.knights.config;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import com.springinaction.knights.BraveKnight; import com.springinaction.knights.Knight; import com.springinaction.knights.Quest; import com.springinaction.knights.SlayDragonQuest;
@Configuration
public class KnightConfig {
@Bean
public Knight knight() {
return new BraveKnight(quest());
}
@Bean
public Quest quest() {
return new SlayDragonQuest(System.out);
}
}
```

- In a Spring application, an application context loads bean definitions and wires them together. The Spring application context is fully responsible for the creation of and wiring of the objects that make up the application. Spring comes with several imple¬mentations of its application context, each primarily differing only in how it loads its configuration.

- When the beans in knights.xml are declared in an XML file, an appropriate choice for application context might be ClassPathXmlApplicationContext.1

- These system services are commonly referred to as cross-cut¬ting concerns because they tend to cut across multiple components in a system.

- Your components are littered with code that isn’t aligned with their core func¬tionality. A method that adds an entry to an address book should only be con¬cerned with how to add the address and not with whether it’s secure or transactional.

- Spring seeks to eliminate boilerplate code by encapsulating it in templates. Spring’s JdbcTemplate makes it possible to perform database operations without all the ceremony required by traditional JDBC.
The container is at the core of the Spring Framework. Spring’s container uses DI to manage the components that make up an application. This includes creating associa¬tions between collaborating components. As such, these objects are cleaner and easier to understand, they support reuse, and they’re easy to unit test.
- There’s no single Spring container. Spring comes with several container imple¬mentations that can be categorized into two distinct types. Bean factories (defined by the org.springframework.beans.factory.BeanFactory interface) are the simplest of containers, providing basic support for DI. Application contexts (defined by the org.springframework.context.ApplicationContext interface) build on the notion of a bean factory by providing application-framework services, such as the ability to resolve textual messages from a properties file and the ability to publish application events to interested event listeners.
- Although it’s possible to work with Spring using either bean factories or applica¬tion contexts, bean factories are often too low-level for most applications. Therefore, application contexts are preferred over bean factories. We’ll focus on working with application contexts and not spend any more time talking about bean factories.

- As you can see, a bean factory performs several setup steps before a bean is ready to use. Let’s break down figure 1.5 in more detail:
1 Spring instantiates the bean.
2 Spring injects values and bean references into the bean’s properties.
3 If the bean implements BeanNameAware, Spring passes the bean’s ID to the set-BeanName() method.
4 If the bean implements BeanFactoryAware, Spring calls the setBeanFactory() method, passing in the bean factory itself.
5 If the bean implements ApplicationContextAware, Spring calls the set-ApplicationContext() method, passing in a reference to the enclosing appli¬cation context.
6       If the bean implements the BeanPostProcessor interface, Spring calls its post- 
ProcessBeforeInitialization() method.
7       If the bean implements the InitializingBean interface, Spring calls its after- 
PropertiesSet() method. Similarly, if the bean was declared with an init-method, then the specified initialization method is called.
8 If the bean implements BeanPostProcessor, Spring calls its postProcess-AfterInitialization() method.
9 At this point, the bean is ready to be used by the application and remains in the application context until the application context is destroyed.
10 If the bean implements the DisposableBean interface, Spring calls its destroy() method. Likewise, if the bean was declared with a destroy-method, the specified method is called.

- Spring Boot heavily employs automatic configuration techniques that can elimi¬nate most (and in many cases, all) Spring configuration. It also provides several starter projects to help reduce the size of your Spring project build files, whether you’re using Maven or Gradle.

·   Spring began to support Servlet 3.0, including the ability to declare servlets and filters in Java-based configuration instead of web.xml.
·   You should now have a good idea of what Spring brings to the table. Spring aims to make enterprise Java development easier and to promote loosely coupled code. Vital to this are dependency injection and aspect-oriented programming.
When it comes to expressing a bean wiring specification, Spring is incredibly flexible, offering three primary wiring mechanisms:
·   Explicit configuration in XML
·   Explicit configuration in Java
·   Implicit bean discovery and automatic wiring
·   in many cases, the choice is largely a matter of personal taste, and you’re welcome to choose the approach that feels best for you.
Spring attacks automatic wiring from two angles:
·   Component scanning—Spring automatically discovers beans to be created in the application context.
·   Autowiring—Spring automatically satisfies bean dependencies.
Working together, component scanning and autowiring are a powerful force and can help keep explicit configuration to a minimum.

```java
package soundsystem;
public interface CompactDisc { void play();
}
```

- The specifics of the CompactDisc interface aren’t important. What is important is that you’ve defined it as an interface. As an interface, it defines the contract through which a CD player can operate on the CD. And it keeps the coupling between any CD player implementation and the CD itself to a minimum.

```java
package soundsystem;
import org.springframework.stereotype.Component;
@Component
public class SgtPeppers implements CompactDisc {
private String title = "Sgt. Pepper's Lonely Hearts Club Band"; private String artist = "The Beatles";
public void play() {
System.out.println("Playing " + title + " by " + artist);
}
}
```

- that SgtPeppers is annotated with @Component. This simple annotation identifies this class as a component class and serves as a clue to Spring that a bean should be created for the class.
Component scanning isn’t turned on by default, however. You’ll still need to write an explicit configuration to tell Spring to seek out classes annotated with @Component and to create beans from them. The configuration class in the following listing shows the minimal configuration to make this possible.
 

```java
package soundsystem;
import org.springframework.context.annotation.ComponentScan; import org.springframework.context.annotation.Configuration;
@Configuration @ComponentScan
public class CDPlayerConfig {
}
```



- you can explicitly identify any state as the starting state by setting the start-state attri¬bute in the <flow> element:
```xml
<?xml version="1.0" encoding="UTF-8"?>
<flow xmlns="http://www.springframework.org/schema/webflow" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/webflow http://www.springframework.org/schema/webflow/spring-webflow-2.3.xsd" start-state="identifyCustomer">
...
</flow>


<body>
<h2>Welcome to Spizza!!!</h2>
<form:form>
<input type="hidden" name="_flowExecutionKey"
value="${flowExecutionKey}"/>
<input type="text" name="phoneNumber"/><br/>
<input type="submit" name="_eventId_phoneEntered"
value="Lookup Customer" />
</form:form>
</body>
</html>
```

- The _eventId_ portion of the button’s name is a clue to Spring Web Flow that what follows is an event that should be fired. When the form is submitted by clicking that button, a phoneEntered event is fired, triggering a transition to lookupCustomer.

    Flow execution key
```xml
<p>The address is outside of our delivery area. You may
still place the order, but you will need to pick it up
yourself.</p>
<![CDATA[
<a href="${flowExecutionUrl}&_eventId=accept">
Continue, I'll pick up the order</a> |
<a href="${flowExecutionUrl}&_eventId=cancel">Never mind</a>
11>
```

- Note that the customerReady end state includes an <output> element. This ele-ment is a flow’s equivalent of Java’s return statement. It passes back some data from a subflow to the calling flow. In this case, <output> returns the customer flow variable so that the identifyCustomer subflow state in the pizza flow can assign it to the order.
you use the <input> element to pass the Order in to the flow. Here you’re using it to accept that Order object. If you think of this subflow as being analo¬gous to a method in Java, the <input> element used here is effectively defining the subflow’s signature. This flow requires a single parameter called order.

- States, transitions, and entire flows can be secured in Spring Web Flow by using the <secured> element as a child of those elements. For example, to secure access to a view state, you might use <secured> like this:
<view-state id="restricted">
<secured attributes="ROLE_ADMIN" match="all"/> </view-state>
As configured here, access to the view state will be restricted to only users who are granted ROLE_ADMIN access (per the attributes attribute). The attributes attribute takes a comma-separated list of authorities that the user must have to gain access to the state, transition, or flow.

