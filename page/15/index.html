<!DOCTYPE html>





<html class="theme-next pisces use-motion" lang="en">
<head>
  <meta charset="UTF-8">
<meta name="generator" content="Hexo 3.8.0">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.3.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.3.0">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.3.0">
  <link rel="mask-icon" href="/images/logo.svg?v=7.3.0" color="#222">

<link rel="stylesheet" href="/css/main.css?v=7.3.0">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '7.3.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    save_scroll: false,
    copycode: {"enable":false,"show_result":false,"style":null},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: 'Copy',
      copy_success: 'Copied',
      copy_failure: 'Copy failed'
    }
  };
</script>

  <meta name="description" content="Contact me via phray.zhang@gmail.com or wechat at helloworld_2000">
<meta property="og:type" content="website">
<meta property="og:title" content="Clouds &amp; Docker">
<meta property="og:url" content="http://www.todzhang.com/page/15/index.html">
<meta property="og:site_name" content="Clouds &amp; Docker">
<meta property="og:description" content="Contact me via phray.zhang@gmail.com or wechat at helloworld_2000">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Clouds &amp; Docker">
<meta name="twitter:description" content="Contact me via phray.zhang@gmail.com or wechat at helloworld_2000">
  <link rel="canonical" href="http://www.todzhang.com/page/15/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false,
    isPage: false,
    isArchive: false
  };
</script>

  <title>Clouds & Docker</title>
  








  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  <div class="container sidebar-position-left">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Clouds & Docker</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
      
      
      
        
        <li class="menu-item menu-item-home">
      
    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>Home</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-archives">
      
    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>Archives</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    

  <a href="https://github.com/CloudsDocker" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewbox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"/><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"/><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"/></svg></a>


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
            

          <div id="content" class="content page-home">
            
  <section id="posts" class="posts-expand">
      

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.todzhang.com/2019-01-03-IPC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Todd Zhang">
      <meta itemprop="description" content="Contact me via phray.zhang@gmail.com or wechat at helloworld_2000">
      <meta itemprop="image" content="/images/globe.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Clouds & Docker">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
              
              <a href="/2019-01-03-IPC/" class="post-title-link" itemprop="url">Inter Processes Communication</a>
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-05-31 23:03:27" itemprop="dateCreated datePublished" datetime="2019-05-31T23:03:27+10:00">2019-05-31</time>
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h1 id="IPC"><a href="#IPC" class="headerlink" title="IPC"></a>IPC</h1><p>interprocess communication (IPC)</p>
<p>Posted by: Margaret Rouse<br>WhatIs.com</p>
<p>Interprocess communication (IPC) is a set of programming interfaces that allow a programmer to coordinate activities among different program processes that can run concurrently in an operating system. This allows a program to handle many user requests at the same time. Since even a single user request may result in multiple processes running in the operating system on the user’s behalf, the processes need to communicate with each other. The IPC interfaces make this possible. Each IPC method has its own advantages and limitations so it is not unusual for a single program to use all of the IPC methods.</p>
<p>Inter process communication (IPC) is a mechanism which allows processes to communicate each other and synchronize their actions. The communication between these processes can be seen as a method of co-operation between them. Processes can communicate with each other using these two ways:<br>Shared Memory<br>Message passing</p>

          
        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.todzhang.com/2019-01-17-FX-ForeignExchange/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Todd Zhang">
      <meta itemprop="description" content="Contact me via phray.zhang@gmail.com or wechat at helloworld_2000">
      <meta itemprop="image" content="/images/globe.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Clouds & Docker">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
              
              <a href="/2019-01-17-FX-ForeignExchange/" class="post-title-link" itemprop="url">Foreign Exchange</a>
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-05-31 23:03:27" itemprop="dateCreated datePublished" datetime="2019-05-31T23:03:27+10:00">2019-05-31</time>
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h1 id="currency-pairs"><a href="#currency-pairs" class="headerlink" title="currency pairs"></a>currency pairs</h1><ul>
<li>Direct ccy: means USD is part of currency pair</li>
<li>Cross ccy: means ccy wihtout USD, so except NDF, the deal will be split to legs, both with USD. e.g. EUR/GBP will split to EURUSD and USDGBP</li>
<li>non-convention ccy pair: that’s depends on where you sit on. e.g. for Aussie traders, they would trade AUDNZD, but for kiwi traders, they would trade for NZDAUD, then AUDNZD would be non-convention</li>
</ul>

          
        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.todzhang.com/2019-01-17-Mifid/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Todd Zhang">
      <meta itemprop="description" content="Contact me via phray.zhang@gmail.com or wechat at helloworld_2000">
      <meta itemprop="image" content="/images/globe.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Clouds & Docker">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
              
              <a href="/2019-01-17-Mifid/" class="post-title-link" itemprop="url">Mifid</a>
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-05-31 23:03:27" itemprop="dateCreated datePublished" datetime="2019-05-31T23:03:27+10:00">2019-05-31</time>
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <p>FX Spot is not covered by the regulation, as it is not considered to be a financial instrument by ESMA, the European Union (EU) regulator. As FX is considered “illiquid” it does not have pre-trade reporting requirements.</p>
<p>Recordkeeping – MiFID II requires firms to keep extensive records of all transactions, communications, services and activities for 10 years, in order for them to be able to provide transparency into the trade life cycle. This is to support trade reconstruction if required.</p>
<p>Overall there are 3 points in the text which we think will be of particular interest to foreign exchange brokers.</p>
<p>The EC has determined that FX Forward contracts remain outside the scope of MiFID II if they satisfy all of the following conditions:<br>The contract for deliverable FX is physically settled<br>At least one of the parties to the contract is a non-financial counterparty<br>The purpose of the contract is to facilitate payment for identifiable goods, services or direct investment<br>The contract is not traded on a trading venue  </p>
<hr>
<p>FX Forwards will qualify for the means of payment exclusion if they meet the following criteria:</p>
<ol>
<li><p>The counterparty is a corporate entity (a non-financial counterparty (‘NFC’) as defined under EMIR);</p>
</li>
<li><p>The FX forwards are traded for the purpose of facilitating payment for identifiable goods or services (for example, entering into an FX forward in order to pay an upcoming invoice in a foreign currency, or in preparation of an upcoming purchase in a foreign currency, as opposed to trading FX forwards for speculative purposes); and</p>
</li>
<li><p>The FX forwards are traded bilaterally, as opposed to on a regulated trading venue (note that Agile Markets is not a regulated trading venue and does not affect eligibility);</p>
</li>
</ol>
<p>The Financial Conduct Authority has provided some examples of scenarios that would fit within the exclusion.  Please find the examples provided on the link here.</p>

          
        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.todzhang.com/2017-01-14-Java-8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Todd Zhang">
      <meta itemprop="description" content="Contact me via phray.zhang@gmail.com or wechat at helloworld_2000">
      <meta itemprop="image" content="/images/globe.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Clouds & Docker">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
              
              <a href="/2017-01-14-Java-8/" class="post-title-link" itemprop="url">Java 8 Tips</a>
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-05-31 23:03:27" itemprop="dateCreated datePublished" datetime="2019-05-31T23:03:27+10:00">2019-05-31</time>
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h1 id="This-blog-is-listing-key-new-features-introduced-in-Java-8"><a href="#This-blog-is-listing-key-new-features-introduced-in-Java-8" class="headerlink" title="This blog is listing key new features introduced in Java 8"></a>This blog is listing key new features introduced in Java 8</h1><p>It is best to think of a lambda expression as a function, not an object, and to accept that it can be converted to a functional interface.</p>
<h2 id="New-comparator-method-in-Java-8"><a href="#New-comparator-method-in-Java-8" class="headerlink" title="New comparator method in Java 8"></a>New comparator method in Java 8</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Track&gt; tracks = asList(<span class="keyword">new</span> Track(<span class="string">"Bakai"</span>, <span class="number">524</span>),</span><br><span class="line">                            <span class="keyword">new</span> Track(<span class="string">"Violets for Your Furs"</span>, <span class="number">378</span>),</span><br><span class="line">                            <span class="keyword">new</span> Track(<span class="string">"Time Was"</span>, <span class="number">451</span>));</span><br><span class="line"></span><br><span class="line">Track shortestTrack = tracks.stream()</span><br><span class="line">                            .min(Comparator.comparing(track -&gt; track.getLength()))</span><br><span class="line">                            .get();</span><br><span class="line"></span><br><span class="line">assertEquals(tracks.get(<span class="number">1</span>), shortestTrack);</span><br></pre></td></tr></table></figure>

<p>When we think about maximum and minimum elements, the first thing we need to think about is the ordering that we’re going to be using. When it comes to finding the shortest track, the ordering is provided by the length of the ”</p>
<p>In order to inform the Stream that we’re using the length of the track, we give it a Comparator. Conveniently, Java 8 has added a static method called comparing that lets us build a comparator using keys. Previously, we always encountered an ugly pattern in which we had to write code that got a field out of both the objects being compared, then compare these field values. Now, to get the same element out of both elements being compared, we just provide a getter function for the value. In this case we’ll use length, which is a getter function in disguise.<br>It’s worth reflecting on the comparing method for a moment. This is actually a function that takes a function and returns a function. Pretty meta, I know, but also incredibly useful. At any point in the past, this method could have been added to the Java standard library, but the poor readability and verbosity issues surrounding anonymous inner classes would have made it impractical. Now, with lambda expressions, it’s convenient and concise.<br>”
But thinking of passing code to methods as a mere consequence of Streamsdownplays its range of uses within Java 8. It gives you a new concise way to express behavior parameterization.</p>
<p>It might sound surprising, but interfaces in Java 8 can now declare methods with implementation code; this can happen in two ways. First, Java 8 allows static methods inside interfaces. Second, Java 8 introduces a new feature called default methods that allows you to provide a default implementation for methods in an interface. In other words, interfaces can provide concrete implementation for methods. As a result, existing classes implementing an interface will automatically inherit the default implementations if they don’t provide one explicitly. This allows you to evolve interfaces nonintrusively. You’ve been using several default methods all along. Two examples you’ve seen are sort in the List interface and stream in the Collection interface.<br>Wow! Are interfaces like abstract classes now? Yes and no; there are fundamental differences, which we explain in this chapter. But more important, why should you care about default methods? The main users of default methods are library designers. As we explain later, default methods were introduced to evolve libraries such as the Java API in a compatible way,</p>
<p>Now that static methods can exist inside interfaces, such utility classes in your code can go away and their static methods can be moved inside an interface. These companion classes will remain in the Java API in order to preserve backward compatibility.<br>Adding a new method to an interface is binary compatible; this means existing class file implementations will still run without the implementation of the new method, if there’s no attempt to recompile them. In this case the game will still run (unless it’s recompiled) despite adding the method setRelativeSize to the Resizable interface</p>
<h2 id="Abstract-classes-vs-interfaces-in-Java-8"><a href="#Abstract-classes-vs-interfaces-in-Java-8" class="headerlink" title="Abstract classes vs. interfaces in Java 8"></a>Abstract classes vs. interfaces in Java 8</h2><p>So what’s the difference between an abstract class and an interface? They both can contain abstract methods and methods with a body.</p>
<ul>
<li><p>First, a class can extend only from one abstract class, but a class can implement multiple interfaces.</p>
</li>
<li><p>Second, an abstract class can enforce a common state through instance variables (fields). An interface can’t have instance variables.</p>
</li>
</ul>
<p>Keeping interfaces minimal and orthogonal lets you achieve great reuse and composition of behavior inside your codebase.</p>
<p>Minimal interfaces with orthogonal functionalities<br>Inheritance considered harmful<br>Inheritance shouldn’t be your answer to everything when it comes down to reusing code. For example, inheriting from a class that has 100 methods and fields just to reuse one method is a bad idea, because it adds unnecessary complexity. You’d be better off using delegation: create a method that calls directly the method of the class you need via a member variable. This is why you’ll sometime find classes that are declared “final” intentionally: they can’t be inherited from to prevent this kind of antipattern or have their core behavior messed with. Note that sometimes final classes have a place; for example, String is final because we don’t want anybody to be able to interfere with such core functionality.</p>
<h2 id="Three-resolution-rules-to-know"><a href="#Three-resolution-rules-to-know" class="headerlink" title="Three resolution rules to know"></a>Three resolution rules to know</h2><p>There are three rules to follow when a class inherits a method with the same signature from multiple places (such as another class or interface):</p>
<ol>
<li><p>Classes always win. A method declaration in the class or a superclass takes priority over any default method declaration.</p>
</li>
<li><p>Otherwise, sub-interfaces win: the method with the same signature in the most specific default-providing interface is selected. (If B extends A, B is more specific than A).</p>
</li>
<li><p>Finally, if the choice is still ambiguous, the class inheriting from multiple interfaces has to explicitly select which default method implementation to use by overriding it and calling the desired method explicitly.</p>
</li>
</ol>
<p>These are the only rules you need to know! </p>
<h2 id="Lambda-Interfaces"><a href="#Lambda-Interfaces" class="headerlink" title="Lambda Interfaces"></a>Lambda Interfaces</h2><p>This conversion to interfaces is what makes lambda expressions so compelling. The syntax is short and simple.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BiFunction&lt;String, String, Integer&gt; comp</span><br><span class="line">   = (first, second) -&gt; Integer.compare(first.length(), second.length());</span><br></pre></td></tr></table></figure>

<p>The expression System.out::printlnis a method reference that is equivalent to the lambda expression x -&gt; System.out.println(x).</p>
<p>There are three principal cases:</p>
<ul>
<li>object::instanceMethod</li>
<li>Class::staticMethod</li>
<li>Class::instanceMethod</li>
</ul>
<p>In the third case, the first parameter becomes the target of the method. For example, String::compareToIgnoreCaseis the same as (x, y) -&gt; x.compareToIgnoreCase(y).</p>
<p>Just like lambda expressions, method references don’t live in isolation. They are always turned into instances of functional interfaces.</p>
<h2 id="Constructor-References"><a href="#Constructor-References" class="headerlink" title="Constructor References"></a>Constructor References</h2><p><code>Constructor references are just like method references, except that the name of the method is new</code>å. For example, Button::new is a reference to a Button constructor. Which constructor? It depends on the context.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; labels = ...;</span><br><span class="line">Stream&lt;Button&gt; stream = labels.stream().map(Button::<span class="keyword">new</span>);</span><br><span class="line">List&lt;Button&gt; buttons = stream.collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<p>For example, suppose we want to have an array of buttons. The Stream interface has a toArraymethod that returns an Object array:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object[] buttons = stream.toArray();</span><br></pre></td></tr></table></figure>

<p>we need to refine our understanding of a lambda expression. A lambda expression has three ingredients:</p>
<ol>
<li>A block of code</li>
<li>Parameters</li>
<li>Values for the free variables, that is, the variables that are not parameters and not defined inside the code</li>
</ol>
<p>The technical term for a block of code together with the values of the free variables is a closure. If someone gloats that their language has closures, rest assured that Java has them as well. In Java, lambda expressions are closures. In fact, inner classes have been closures all along. Java 8 gives us closures with an attractive syntax.</p>
<p>Inner classes can also capture values from an enclosing scope. Before Java 8, inner classes were only allowed to access finallocal variables. This rule has now been relaxed to match that for lambda expressions. An inner class can access any effectively final local variable—that is, any variable whose value does not change.</p>
<p>When you use the this keyword in a lambda expression, you refer to the this parameter of the method that creates the lambda. For example, consider</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doWork</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      Runnable runner = () -&gt; &#123; ...; System.out.println(<span class="keyword">this</span>.toString()); ... &#125;;</span><br><span class="line">      ...</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The expression this.toString()calls the toString method of the Application object, not the Runnable instance. There is nothing special about the use of this in a lambda expression. The scope of the lambda expression is nested inside the doWork method, and this has the same meaning anywhere in that method.</p>
<h1 id="default-methods"><a href="#default-methods" class="headerlink" title="default methods"></a>default methods</h1><p>The Java designers decided to solve this problem once and for all by allowing interface methods with concrete implementations (called default methods). Those methods can be safely added to existing interfaces.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">long</span> <span class="title">getId</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">default</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">"John Q. Public"</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The interface has two methods: getId, which is an abstract method, and the default method getName. A concrete class that implements the Person interface must, of course, provide an implementation of getId, but it can choose to keep the implementation of getName or to override it.</p>
<p>Default methods put an end to the classic pattern of providing an interface and an abstract class that implements most or all of its methods, such as Collection/AbstractCollectionor/WindowListener/WindowAdapter. Now you can just implement the methods in the interface.</p>
<p>To compare Person objects by name, use Comparator.comparing(Person::getName).</p>
<p>we have compared strings by length with the lambda expression </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(first, second) -&gt; Integer.compare(first.length(), second.length()).</span><br></pre></td></tr></table></figure>

<p>But with the static compare method, we can do much better and simply use </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Comparator.comparing(String::length).</span><br></pre></td></tr></table></figure>

<p>In Java 8, static methods have been added to quite a few interfaces. For example, the Comparator interface has a very useful static comparing method that accepts a “key extraction” function and yields a comparator that compares the extracted keys.</p>
<h2 id="Stream-vs-collections"><a href="#Stream-vs-collections" class="headerlink" title="Stream vs collections"></a>Stream vs collections</h2><p>A stream seems superficially similar to a collection, allowing you to transform and retrieve data. But there are significant differences:</p>
<ul>
<li>A stream does not store its elements. They may be stored in an underlying collection or generated on demand.</li>
<li>Stream operations don’t mutate their source. Instead, they return new streams that hold the result.</li>
<li>Stream operations are lazy when possible. This means they are not executed until their result is needed. For example, if you only ask for the first five long words instead of counting them all, then the filter method will stop filtering after the fifth match. As a consequence, you can even have infinite streams!</li>
</ul>
<p><code>Streams follow the “what, not how” principle</code>. In our stream example, we describe what needs to be done: get the long words and count them. We don’t specify in which order, or in which thread, this should happen.</p>
<h2 id="Work-with-streams"><a href="#Work-with-streams" class="headerlink" title="Work with streams"></a>Work with streams</h2><p>When you work with streams, you set up a pipeline of operations in three stages.</p>
<ol>
<li>You create a stream.</li>
<li>You specify intermediate operations for transforming the initial stream into others, in one or more steps.</li>
<li>You apply a terminal operation to produce a result. This operation forces the execution of the lazy operations that precede it. Afterwards, the stream can no longer be used.</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> count = words.parallelStream().filter(w -&gt; w.length() &gt; <span class="number">12</span>).count();</span><br></pre></td></tr></table></figure>

<p>Stream operations are not executed on the elements in the order in which they are invoked on the streams. In our example, nothing happens until count is called. When the count method asks for the first element, then the filter method starts requesting elements, until it finds one that has length &gt; 12.</p>
<p>To produce infinite sequences such as 0 1 2 3 …, use the iterate method instead. It takes a “seed” value and a function (technically, a UnaryOperator<t>), and repeatedly applies the function to the previous result. For example,</t></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;BigInteger&gt; integers</span><br><span class="line">   = Stream.iterate(BigInteger.ZERO, n -&gt; n.add(BigInteger.ONE));</span><br></pre></td></tr></table></figure>

<p>The first element in the sequence is the seed</p>
<p>You can use the following statement to split a string into words:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; words</span><br><span class="line">   = Pattern.compile(<span class="string">"[\\P&#123;L&#125;]+"</span>).splitAsStream(contents);</span><br></pre></td></tr></table></figure>

<p>The static Files.linesmethod returns a Stream of all lines in a file.</p>
<p>The Stream interface has AutoCloseableas a superinterface. When the close method is called on the stream, the underlying file is also closed.</p>
<p>To make sure that this happens, it is best to use the Java 7 try-with-resources statement:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (Stream&lt;String&gt; lines = Files.lines(path)) &#123;</span><br><span class="line">   Do something with lines</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The stream, and the underlying file with it, will be closed when the try block exits normally or through an exception.</p>
<p>The filter, map, and flatMapMethods<br>A stream transformation reads data from a stream and puts the transformed data into another stream. You have already seen the filter transformation that yields a new stream with all elements that match a certain condition.</p>
<p>2.3. The filter, map, and flatMap Methods<br>A stream transformation reads data from a stream and puts the transformed data into another stream. You have already seen the filtertransformation that yields a new stream with all elements that match a certain condition. Here, we transform a stream of strings into another stream containing only long words:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; wordList = ...;</span><br><span class="line">Stream&lt;String&gt; words = wordList.stream();</span><br><span class="line">Stream&lt;String&gt; longWords = words.filter(w -&gt; w.length() &gt; <span class="number">12</span>);</span><br></pre></td></tr></table></figure>

<p>The argument of filter is a Predicate<t>—that is, a function from T to boolean.</t></p>
<p>Often, you want to transform the values in a stream in some way. Use the map method and pass the function that carries out the transformation. For example, you can transform all words to lowercase like this:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; lowercaseWords = words.map(String::toLowerCase);</span><br></pre></td></tr></table></figure>

<p>Here, we used mapwith a method reference. Often, you will use a lambda expression instead:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Character&gt; firstChars = words.map(s -&gt; s.charAt(<span class="number">0</span>));</span><br></pre></td></tr></table></figure>

<p>The resulting stream contains the first character of each word.</p>
<p>When you use map, a function is applied to each element, and the return values are collected in a new stream. Now suppose that you have a function that returns not just one value but a stream of values, such as this one:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Stream&lt;Character&gt; <span class="title">characterStream</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">   List&lt;Character&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">char</span> c : s.toCharArray()) result.add(c);</span><br><span class="line">   <span class="keyword">return</span> result.stream();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>For example, characterStream(“boat”)is the stream [‘b’, ‘o’, ‘a’, ‘t’]. Suppose you map this method on a stream of strings:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Stream&lt;Character&gt;&gt; result = words.map(w -&gt; characterStream(w));</span><br></pre></td></tr></table></figure>

<p>You will get a stream of streams, like [… [‘y’, ‘o’, ‘u’, ‘r’], [‘b’, ‘o’, ‘a’, ‘t’], …] To flatten it out to a stream of characters [… ‘y’, ‘o’, ‘u’, ‘r’, ‘b’, ‘o’, ‘a’, ‘t’, …], use the flatMapmethod instead of map:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Character&gt; letters = words.flatMap(w -&gt; characterStream(w))</span><br><span class="line">    <span class="comment">// CallscharacterStream on each word and flattens the results</span></span><br></pre></td></tr></table></figure>

<p> NOTE</p>
<p>You may find a flatMap method in classes other than streams. It is a general concept in computer science. Suppose you have a generic type G (such as Stream) and functions ffrom some type T to G<u>and g from U to G<v>. Then you can compose them, that is, first apply f and then g, by using flatMap. This is a key idea in the theory of monads. But don’t worry—you can use flatMapwithout knowing anything about monads.</v></u></p>
<p>This method is particularly useful for cutting infinite streams down to size. For example,</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Double&gt; randoms = Stream.generate(Math::random).limit(<span class="number">100</span>);</span><br></pre></td></tr></table></figure>

<p>yields a stream with 100 random numbers.</p>
<p>The peek method yields another stream with the same elements as the original, but a function is invoked every time an element is retrieved. That is handy for debugging:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object[] powers = Stream.iterate(<span class="number">1.0</span>, p -&gt; p * <span class="number">2</span>)</span><br><span class="line">   .peek(e -&gt; System.out.println(<span class="string">"Fetching "</span> + e))</span><br><span class="line">   .limit(<span class="number">20</span>).toArray();</span><br></pre></td></tr></table></figure>

<p>When an element is actually accessed, a message is printed. This way you can verify that the infinite stream returned by iterate is processed lazily.</p>
<p>The stream transformations of the preceding sections were stateless. When an element is retrieved from a filtered or mapped stream, the answer does not depend on the previous elements. There are also a few stateful transformations. For example, the distinct method returns a stream that yields elements from the original stream, in the same order, except that duplicates are suppressed.</p>
<p>The stream must obviously remember the elements that it has already seen.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; uniqueWords</span><br><span class="line">   = Stream.of(<span class="string">"merrily"</span>, <span class="string">"merrily"</span>, <span class="string">"merrily"</span>, <span class="string">"gently"</span>).distinct();</span><br><span class="line">   <span class="comment">// Only one"merrily" is retained</span></span><br></pre></td></tr></table></figure>

<p>The sorted method must see the entire stream and sort it before it can give out any elements—after all, the smallest one might be the last one. Clearly, you can’t sort an infinite stream.</p>
<p>There are several sorted methods. One works for streams of Comparableelements, and another accepts a Comparator. Here, we sort strings so that the longest ones come first:</p>
<p>Click here to view code image</p>
<p>Stream<string> longestFirst =<br>   words.sorted(Comparator.comparing(String::length).reversed());<br>Of course, you can sort a collection without using streams. The sorted method is useful when the sorting process is a part of a stream pipeline.</string></p>
<p> NOTE</p>
<p>The Collections.sortmethod sorts a collection in place, whereas Stream.sortedreturns a new sorted stream.</p>
<p>The methods that we cover in this section are called reductions. They reduce the stream to a value that can be used in your program. Reductions are terminal operations. After a terminal operation has been applied, the stream ceases to be usable.</p>
<p>In Java 8, the Optional type is the preferred way of indicating a missing return value. We discuss the Optional type in detail in the next section. Here is how you can get the maximum of a stream:</p>
<p>Click here to view code image</p>
<p>Optional<string> largest = words.max(String::compareToIgnoreCase);<br>if (largest.isPresent())<br>   System.out.println(“largest: “ + largest.get());</string></p>
<p>reduce. Each segment needs to start out with its own empty hash set, and reduce only lets you supply one identity value. Instead, use collect. It takes three arguments:</p>
<ol>
<li><p>A supplier to make new instances of the target object, for example, a constructor for a hash set</p>
</li>
<li><p>An accumulatorthat adds an element to the target, for example, an addmethod</p>
</li>
<li><p>A combiner that merges two objects into one, such as addAll</p>
</li>
</ol>
<p> NOTE</p>
<p>The target object need not be a collection. It could be a StringBuilderor an object that tracks a count and a sum.</p>
<p>Here is how the collect method works for a hash set:</p>
<p>Click here to view code image</p>
<p>HashSet<string> result = stream.collect(HashSet::new, HashSet::add, HashSet::addAll);</string></p>
<p>In practice, you don’t have to do that because there is a convenient Collector interface for these three functions, and a Collectors class with factory methods for common collectors. To collect a stream into a list or set, you can simply call</p>
<p>Click here to view code image</p>
<p>List<string> result = stream.collect(Collectors.toList());</string></p>
<p>or</p>
<p>Click here to view code image</p>
<p>Set<string> result = stream.collect(Collectors.toSet());</string></p>
<p>If you want to control which kind of set you get, use the following call instead:</p>
<p>Click here to view code image</p>
<p>TreeSet<string> result = stream.collect(Collectors.toCollection(TreeSet::new));</string></p>
<p>Suppose you want to collect all strings in a stream by concatenating them. You can call</p>
<p>String result = stream.collect(Collectors.joining());</p>
<p>If you want a delimiter between elements, pass it to the joiningmethod:</p>
<p>Click here to view code image</p>
<p>String result = stream.collect(Collectors.joining(“, “));</p>
<p>If your stream contains objects other than strings, you need to first convert them to strings, like this:</p>
<p>Click here to view code image</p>
<p>String result = stream.map(Object::toString).collect(Collectors.joining(“, “));</p>
<p>If you want to reduce the stream results to a sum, average, maximum, or minimum, then use one of the methods summarizing(Int|Long|Double). These methods take a function that maps the stream objects to a number and yield a result of type (Int|Long|Double)SummaryStatistics, with methods for obtaining the sum, average, maximum, and minumum.</p>
<p>Click here to view code image</p>
<p>IntSummaryStatistics summary = words.collect(<br>   Collectors.summarizingInt(String::length));<br>double averageWordLength = summary.getAverage();<br>double maxWordLength = summary.getMax();</p>
<p> NOTE</p>
<p>So far, you have seen how to reduce or collect stream values. But perhaps you just want to print them or put them in a database. Then you can use the forEachmethod:</p>
<p>stream.forEach(System.out::println);</p>
<p>The function that you pass is applied to each element. On a parallel stream, it’s your responsibility to ensure that the function can be executed concurrently. We discuss this in Section 2.13, “Parallel Streams,” on page 40.</p>
<p>On a parallel stream, the elements can be traversed in arbitrary order. If you want to execute them in stream order, call forEachOrderedinstead. Of course, you might then give up most or all of the benefits of parallelism.</p>
<p>The forEachand forEachOrderedmethods are terminal operations. You cannot use the stream again after calling them. If you want to continue using the stream, use peekinstead—see</p>
<p>In the common case that the values should be the actual elements, use Function.identity()for the second function.</p>
<p>Click here to view code image</p>
<p>Map&lt;Integer, Person&gt; idToPerson = people.collect(<br>   Collectors.toMap(Person::getId, Function.identity()));<br>If there is more than one element with the same key, the collector will throw an IllegalStateException. You can override that behavior by supplying a third function argument that determines the value for the key, given the existing and the new value. Your function could return the existing value, the new value, or a combination of them.</p>
<p>Here, we construct a map that contains, for each language in the available locales, as key its name in your default locale (such as “German”), and as value its localized name (such as “Deutsch”).</p>
<p>Click here to view code image</p>
<p>Stream<locale> locales = Stream.of(Locale.getAvailableLocales());<br>Map&lt;String, String&gt; languageNames = locales.collect(<br>   Collectors.toMap(<br>      l -&gt; l.getDisplayLanguage(),<br>      l -&gt; l.getDisplayLanguage(l),<br>      (existingValue, newValue) -&gt; existingValue));<br>We don’t care that the same language might occur twice—for example, German in Germany and in Switzerland, and we just keep the first entry.</locale></p>
<p>However, suppose we want to know all languages in a given country. Then we need a Map&lt;String, Set<string>&gt;. For example, the value for “Switzerland”is the set [French, German, Italian]. At first, we store a singleton set for each language. Whenever a new language is found for a given country, we form the union of the existing and the new set.</string></p>
<p>Click here to view code image</p>
<p>Map&lt;String, Set<string>&gt; countryLanguageSets = locales.collect(<br>   Collectors.toMap(<br>      l -&gt; l.getDisplayCountry(),<br>      l -&gt; Collections.singleton(l.getDisplayLanguage()),<br>      (a, b) -&gt; { // Union of a and b<br>         Set<string> r = new HashSet&lt;&gt;(a);<br>         r.addAll(b);<br>         return r; }));<br>You will see a simpler way of obtaining this map in the next section.</string></string></p>
<p>If you want a TreeMap, then you supply the constructor as the fourth argument. You must provide a merge function. Here is one of the examples from the beginning of the section, now yielding a TreeMap:</p>
<p>Click here to view code image</p>
<p>Map&lt;Integer, Person&gt; idToPerson = people.collect(<br>   Collectors.toMap(<br>      Person::getId,<br>      Function.identity(),<br>      (existingValue, newValue) -&gt; { throw new IllegalStateException(); },<br>      TreeMap::new));</p>
<p>For example, if you want sets instead of lists, you can use the Collectors.toSetcollector that you saw in the preceding section:</p>
<p>Click here to view code image</p>
<p>Map&lt;String, Set<locale>&gt; countryToLocaleSet = locales.collect(<br>   groupingBy(Locale::getCountry, toSet()));</locale></p>
<p>Several other collectors are provided for downstream processing of grouped elements:</p>
<p>• countingproduces a count of the collected elements. For example,</p>
<p>Click here to view code image</p>
<p>Map&lt;String, Long&gt; countryToLocaleCounts = locales.collect(<br>   groupingBy(Locale::getCountry, counting()));<br>counts how many locales there are for each country.</p>
<p>• summing(Int|Long|Double) takes a function argument, applies the function to the downstream elements, and produces their sum. For example,</p>
<p>Click here to view code image</p>
<p>Map&lt;String, Integer&gt; stateToCityPopulation = cities.collect(<br>   groupingBy(City::getState, summingInt(City::getPopulation)));<br>computes the sum of populations per state in a stream of cities.</p>
<p>• maxBy and minBytake a comparator and produce maximum and minimum of the downstream elements. For example,</p>
<p>Click here to view code image</p>
<p>Map&lt;String, City&gt; stateToLargestCity = cities.collect(<br>   groupingBy(City::getState,<br>      maxBy(Comparator.comparing(City::getPopulation))));<br>produces the largest city per state.</p>
<p>• mapping applies a function to downstream results, and it requires yet another collector for processing its results. For example,</p>
<p>Click here to view code image</p>
<p>Map&lt;String, Optional<string>&gt; stateToLongestCityName = cities.collect(<br>   groupingBy(City::getState,<br>      mapping(City::getName,<br>         maxBy(Comparator.comparing(String::length)))));<br>Here, we group cities by state. Within each state, we produce the names of the cities and reduce by maximum length.</string></p>
<p>The mappingmethod also yields a nicer solution to a problem from the preceding section, to gather a set of all languages in a country.</p>
<p>Click here to view code image</p>
<p>Map&lt;String, Set<string>&gt; countryToLanguages = locales.collect(<br>   groupingBy(l -&gt; l.getDisplayCountry(),<br>      mapping(l -&gt; l.getDisplayLanguage(),<br>         toSet())));<br>In the preceding section, I used toMap instead of groupingBy. In this form, you don’t need to worry about combining the individual sets.</string></p>
<p>• If the grouping or mapping function has return type int, long, or double, you can collect elements into a summary statistics object, as discussed in Section 2.9, “Collecting Results,” on page 33. For example,</p>
<p>Click here to view code image</p>
<p>Map&lt;String, IntSummaryStatistics&gt; stateToCityPopulationSummary = cities.collect(<br>   groupingBy(City::getState,<br>      summarizingInt(City::getPopulation)));<br>Then you can get the sum, count, average, minimum, and maximum of the function values from the summary statistics objects of each group.</p>
<p>• Finally, the reducingmethods apply a general reduction to downstream elements. There are three forms: reducing(binaryOperator), reducing(identity, binaryOperator), and reducing(identity, mapper, binaryOperator). In the first form, the identity is null. (Note that this is different from the forms of Stream::reduce, where the method without an identity parameter yields an Optional result.) In the third form, the mapperfunction is applied and its values are reduced.</p>
<p>Here is an example that gets a comma-separated string of all city names in each state. We map each city to its name and then concatenate them.</p>
<p>Click here to view code image</p>
<p>Map&lt;String, String&gt; stateToCityNames = cities.collect(<br>   groupingBy(City::getState,<br>      reducing(“”, City::getName,<br>         (s, t) -&gt; s.length() == 0 ? t : s + “, “ + t)));<br>As with Stream.reduce, Collectors.reducingis rarely necessary. In this case, you can achieve the same result more naturally as</p>
<p>Click here to view code image</p>
<p>Map&lt;String, String&gt; stateToCityNames = cities.collect(<br>   groupingBy(City::getState,<br>      mapping(City::getName,<br>         joining(“, “))));<br>Frankly, the downstream collectors can yield very convoluted expressions. You should only use them in connection with groupingBy or partitioningBy to process the “downstream” map values. Otherwise, simply apply methods such as map, reduce, count, max, or mindirectly on streams.</p>
<p>2.12. Primitive Type Streams<br>So far, we have collected integers in a Stream<integer>, even though it is clearly inefficient to wrap each integer into a wrapper object. The same is true for the other primitive types double, float, long, short, char, byte, and boolean. The stream library has specialized types IntStream, LongStream, and DoubleStream that store primitive values directly, without using wrappers. If you want to store short, char, byte, and boolean, use an IntStream, and for float, use a DoubleStream. The library designers didn’t think it was worth adding another five stream types.</integer></p>
<p>To create an IntStream, you can call the IntStream.of and Arrays.streammethods:</p>
<p>Click here to view code image</p>
<p>IntStream stream = IntStream.of(1, 1, 2, 3, 5);<br>stream = Arrays.stream(values, from, to); // values is an int[] array<br>As with object streams, you can also use the static generate and iterate methods. In addition, IntStreamand LongStreamhave static methods range and rangeClosed that generate integer ranges with step size one:</p>
<p>Click here to view code image</p>
<p>IntStream zeroToNinetyNine = IntStream.range(0, 100); // Upper bound is excluded<br>IntStream zeroToHundred = IntStream.rangeClosed(0, 100); // Upper bound is included<br>The CharSequenceinterface has methods codePoints and chars that yield an IntStream of the Unicode codes of the characters or of the code units in the UTF-16 encoding. (If you don’t know what code units are, you probably shouldn’t use the chars method. Read up on the sordid details in Core Java, 9th Edition, Volume 1, Section 3.3.3.)</p>
<p>Click here to view code image</p>
<p>String sentence = “\uD835\uDD46 is the set of octonions.”;<br>   // \uD835\uDD46 is the UTF-16 encoding of the letter</p>
<p> , unicode U+1D546</p>
<p>IntStream codes = sentence.codePoints();<br>   // The stream with hex values 1D546 20 69 73 20 …<br>When you have a stream of objects, you can transform it to a primitive type stream with the mapToInt, mapToLong, or mapToDoublemethods. For example, if you have a stream of strings and want to process their lengths as integers, you might as well do it in an IntStream:</p>
<p>Click here to view code image</p>
<p>Stream<string> words = …;<br>IntStream lengths = words.mapToInt(String::length);<br>To convert a primitive type stream to an object stream, use the boxed method:</string></p>
<p>Click here to view code image</p>
<p>Stream<integer> integers = IntStream.range(0, 100).boxed();</integer></p>
<p>Generally, the methods on primitive type streams are analogous to those on object streams. Here are the most notable differences:</p>
<p>• The toArraymethods return primitive type arrays.</p>
<p>• Methods that yield an optional result return an OptionalInt, OptionalLong, or OptionalDouble. These classes are analogous to the Optional class, but they have methods getAsInt, getAsLong, and getAsDoubleinstead of the getmethod.</p>
<p>• There are methods sum, average, max, and min that return the sum, average, maximum, and minimum. These methods are not defined for object streams.</p>
<p>• The summaryStatisticsmethod yields an object of type IntSummaryStatistics, LongSummaryStatistics, or DoubleSummaryStatisticsthat can simultaneously report the sum, average, maximum, and minimum of the stream.</p>
<p> NOTE</p>
<p>The Randomclass has methods ints, longs, and doubles that return primitive type streams of random numbers.</p>
<p>2.13. Parallel Streams<br>Streams make it easy to parallelize bulk operations. The process is mostly automatic, but you need to follow a few rules. First of all, you must have a parallel stream. By default, stream operations create sequential streams, except for Collection.parallelStream(). The parallelmethod converts any sequential stream into a parallel one. For example:</p>
<p>Click here to view code image</p>
<p>Stream<string> parallelWords = Stream.of(wordArray).parallel();</string></p>
<p>As long as the stream is in parallel mode when the terminal method executes, all lazy intermediate stream operations will be parallelized.</p>
<p>When stream operations run in parallel, the intent is that the same result is returned as if they had run serially. It is important that the operations are stateless and can be executed in an arbitrary order.</p>
<p>Here is an example of something you cannot do. Suppose you want to count all short words in a stream of strings:</p>
<p>Click here to view code image</p>
<p>int[] shortWords = new int[12];<br>words.parallel().forEach(<br>   s -&gt; { if (s.length() &lt; 12) shortWords[s.length()]++; });<br>      // Error—race condition!
System.out.println(Arrays.toString(shortWords));<br>This is very, very bad code. The function passed to forEachruns concurrently in multiple threads, updating a shared array. That’s a classic race condition. If you run this program multiple times, you are quite likely to get a different sequence of counts in each run, each of them wrong.</p>
<p>It is your responsibility to ensure that any functions that you pass to parallel stream operations are threadsafe. In our example, you could use an array of AtomicIntegerobjects for the counters (see Exercise 12). Or you could simply use the facilities of the streams library and group strings by length (see Exercise 13).</p>
<p>By default, streams that arise from ordered collections (arrays and lists), from ranges, generators, and iterators, or from calling Stream.sorted, are ordered. Results are accumulated in the order of the original elements, and are entirely predictable. If you run the same operations twice, you will get exactly the same results.</p>
<p>Ordering does not preclude parallelization. For example, when computing stream.map(fun), the stream can be partitioned into nsegments, each of which is concurrently processed. Then the results are reassembled in order.</p>
<p>Some operations can be more effectively parallelized when the ordering requirement is dropped. By calling the Stream.unorderedmethod, you indicate that you are not interested in ordering. One operation that can benefit from this is Stream.distinct. On an ordered stream, distinct retains the first of all equal elements. That impedes parallelization—the thread processing a segment can’t know which elements to discard until the preceding segment has been processed. If it is acceptable to retain any of the unique elements, all segments can be processed concurrently (using a shared set to track duplicates).</p>
<p>You can also speed up the limit method by dropping ordering. If you just want any nelements from a stream and you don’t care which ones you get, call</p>
<p>Click here to view code image</p>
<p>Stream<t> sample = stream.parallel().unordered().limit(n);</t></p>
<p>As discussed in Section 2.10, “Collecting into Maps,” on page 34, merging maps is expensive. For that reason, the Collectors.groupingByConcurrentmethod uses a shared concurrent map. Clearly, to benefit from parallelism, the order of the map values will not be the same as the stream order. Even on an ordered stream, that collector has a “characteristic” of being unordered, so that it can be used efficiently without having to make the stream unordered. You still need to make the stream parallel, though:</p>
<p>Click here to view code image</p>
<p>Map&lt;String, List<string>&gt; result = cities.parallel().collect(<br>   Collectors.groupingByConcurrent(City::getState));<br>   // Values aren’t collected in stream order</string></p>
<p> CAUTION</p>
<p>It is very important that you don’t modify the collection that is backing a stream while carrying out a stream operation (even if the modification is threadsafe). Remember that streams don’t collect their own data—the data is always in a separate collection. If you were to modify that collection, the outcome of the stream operations would be undefined. The JDK documentation refers to this requirement as noninterference. It applies both to sequential and parallel streams.</p>
<p>To be exact, since intermediate stream operations are lazy, it is possible to mutate the collection up to the point when the terminal operation executes. For example, the following is correct:</p>
<p>Click here to view code image</p>
<p>List<string> wordList = …;<br>Stream<string> words = wordList.stream();<br>wordList.add(“END”); // Ok<br>long n = words.distinct().count();<br>But this code is not:</string></string></p>
<p>Click here to view code image</p>
<p>Stream<string> words = wordList.stream();<br>words.forEach(s -&gt; if (s.length() &lt; 12) wordList.remove(s));<br>   // Error—interference</string></p>
<p>Exercises</p>
<ol>
<li><p>Write a parallel version of the forloop in Section 2.1, “From Iteration to Stream Operations,” on page 22. Obtain the number of processors. Make that many separate threads, each working on a segment of the list, and total up the results as they come in. (You don’t want the threads to update a single counter. Why?)</p>
</li>
<li><p>Verify that asking for the first five long words does not call the filter method once the fifth long word has been found. Simply log each method call.</p>
</li>
<li><p>Measure the difference when counting long words with a parallelStreaminstead of a stream. Call System.nanoTimebefore and after the call, and print the difference. Switch to a larger document (such as War and Peace) if you have a fast computer.</p>
</li>
<li><p>Suppose you have an array int[] values = { 1, 4, 9, 16 }. What is Stream.of(values)? How do you get a stream of intinstead?</p>
</li>
<li><p>Using Stream.iterate, make an infinite stream of random numbers—not by calling Math.random but by directly implementing a linear congruential generator. In such a generator, you start with x0 = seedand then produce xn + 1 = (a xn + c) %m, for appropriate values of a, c, and m. You should implement a method with parameters a, c, m, and seed that yields a Stream<long>. Try out a = 25214903917, c = 11, and m = 248.</long></p>
</li>
<li><p>The characterStreammethod in Section 2.3, “The filter, map, and flatMapMethods,” on page 25, was a bit clumsy, first filling an array list and then turning it into a stream. Write a stream-based one-liner instead. One approach is to make a stream of integers from 0 to s.length() - 1and map that with the s::charAtmethod reference.</p>
</li>
<li><p>Your manager asks you to write a method public static <t> boolean isFinite(Stream<t> stream). Why isn’t that such a good idea? Go ahead and write it anyway.</t></t></p>
</li>
<li><p>Write a method public static <t> Stream<t> zip(Stream<t> first, Stream<t> second) that alternates elements from the streams first and second, stopping when one of them runs out of elements.</t></t></t></t></p>
</li>
<li><p>Join all elements in a Stream&lt;ArrayList<t>&gt;to one ArrayList<t>. Show how to do this with the three forms of reduce.</t></t></p>
</li>
<li><p>Write a call to reduce that can be used to compute the average of a Stream<double>. Why can’t you simply compute the sum and divide by count()?</double></p>
</li>
<li><p>It should be possible to concurrently collect stream results in a single ArrayList, instead of merging multiple array lists, provided it has been constructed with the stream’s size, since concurrent setoperations at disjoint positions are threadsafe. How can you achieve that?</p>
</li>
<li><p>Count all short words in a parallel Stream<string>, as described in Section 2.13, “Parallel Streams,” on page 40, by updating an array of AtomicInteger. Use the atomic getAndIncrementmethod to safely increment each counter.</string></p>
</li>
<li><p>Repeat the preceding exercise, but filter out the short strings and use the collectmethod with Collectors.groupingByand Collectors.counting.</p>
</li>
</ol>
<p>A function type is alwayscontravariant in its arguments and covariant in its return value. For example, if you have a Function&lt;Person, Employee&gt;, you can safely pass it on to someone who needs a Function&lt;Employee, Person&gt;. They will only call it with employees, whereas your function can handle any person. They will expect the function to return a person, and you give them something even better.</p>
<p>For example, look at the javadoc for Stream<t>:</t></p>
<p>Click here to view code image</p>
<p>void forEach(Consumer&lt;? super T&gt; action)<br>Stream<t> filter(Predicate&lt;? super T&gt; predicate)<br><r> Stream<r> map(Function&lt;? super T, ? extends R&gt; mapper)<br>The general rule is that you use superfor argument types, extends for return types. That way, you can pass a Consumer<object>to forEach on a Stream<string>. If it is willing to consume any object, surely it can consume strings.</string></object></r></r></t></p>
<p>But the wildcards are not always there. Look at</p>
<p>For example, consider the doInOrderAsyncmethod of the preceding section. Instead of</p>
<p>Click here to view code image</p>
<p>public static <t> void doInOrderAsync(Supplier<t> first,<br>   Consumer<t> second, Consumer<throwable> handler)<br>it should be</throwable></t></t></t></p>
<p>Click here to view code image</p>
<p>public static <t> void doInOrderAsync(Supplier&lt;? extends T&gt; first,<br>   Consumer&lt;? super T&gt; second, Consumer&lt;? superThrowable&gt; handler)</t></p>
<p>In our example, we can call</p>
<p>Click here to view code image</p>
<p>largest.updateAndGet(x -&gt; Math.max(x, observed));</p>
<p>or</p>
<p>Click here to view code image</p>
<p>largest.accumulateAndGet(observed, Math::max);</p>
<p>The accumulateAndGetmethod takes a binary operator that is used to combine the atomic value and the supplied argument.</p>
<h2 id="default-in-Java"><a href="#default-in-Java" class="headerlink" title="default in Java"></a><strong>default</strong> in Java</h2><h3 id="There-are-three-rules-about-default"><a href="#There-are-three-rules-about-default" class="headerlink" title="There are three rules about default"></a>There are three rules about <strong>default</strong></h3><p>Regarding how to handle the situation of same default method in multiple inheritance.</p>
<ul>
<li><strong>class win</strong>, any class wins over any interfaces.So if there’s a method with a body, or an abstract declaration, in the superclass chain, we can ignore the interfaces completely.</li>
<li><strong>subtype win supertype</strong>, “which two interfaces are competing to provide a default method and one interface extends the other, the subclass wins.”</li>
<li><strong>No rule 3</strong>. if the previous two rules don’t give us the answer, the subclass must either implement the method or declare it <strong>abstract</strong>.</li>
</ul>
<p>“Interfaces give you multiple inheritance but no fields, while abstract classes let you “inherit fields but you don’t get multiple inheritance.”</p>
<h2 id="Static-method-in-Interface"><a href="#Static-method-in-Interface" class="headerlink" title="Static method in Interface"></a>Static method in Interface</h2><p>We’ve seen a lot of calling of <strong>Stream.of</strong> but haven’t gotten into its details yet. You may recall that Stream is an interface, but this is a static method on an interface. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stream.collect(toCollection(TreeSet::<span class="keyword">new</span>));</span><br></pre></td></tr></table></figure>

<h1 id="Optional-is-a-better-of-null"><a href="#Optional-is-a-better-of-null" class="headerlink" title="Optional is a better of null"></a><strong>Optional</strong> is a better of <strong>null</strong></h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Optional can be created via factory method 'of', </span></span><br><span class="line">Optional&lt;String&gt; a = Optional.of(<span class="string">"a"</span>);</span><br><span class="line"><span class="comment">// Optional is just a container, you can get the underlying value by 'get' method</span></span><br><span class="line">assertEquals(<span class="string">"a"</span>, a.get());</span><br><span class="line"></span><br><span class="line"><span class="comment">// at the meanwhile, Optional can represent 'absent'</span></span><br><span class="line"><span class="comment">// factory method empty or ofNullable from a nullable object can be used</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testOptional</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Optional&lt;String&gt; optA=Optional.of(<span class="string">"a"</span>);</span><br><span class="line">        Assert.assertEquals(<span class="string">"a"</span>, optA.get());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Optional emp=Optional.ofNullable(<span class="keyword">null</span>);</span><br><span class="line">        Assert.assertEquals(Optional.empty(), emp);</span><br><span class="line">        Assert.assertFalse(emp.isPresent());</span><br><span class="line">        Assert.assertEquals(<span class="string">"b"</span>, emp.orElse(<span class="string">"b"</span>));</span><br><span class="line">        Assert.assertEquals(<span class="string">"c"</span>, emp.orElseGet(()-&gt;<span class="string">"c"</span>));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="method-reference"><a href="#method-reference" class="headerlink" title="method reference"></a>method reference</h1><ul>
<li>** Classname::methodname** , such as Artist::getName is equivalant to artist-&gt;artist.getName()</li>
<li>For constructors can be used Artist::new</li>
<li>You can alos to create new array, String[]::new</li>
</ul>
<h1 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h1><p>“The purpose of streams isn’t just to convert from one collection to another; it’s to be able to provide a common set of operations over data.”</p>
<h2 id="partitioningBy"><a href="#partitioningBy" class="headerlink" title="partitioningBy"></a>partitioningBy</h2><p>To split a stream into two groups, one for ‘trueGroup’ and another group</p>
<h2 id="Lanmbda"><a href="#Lanmbda" class="headerlink" title="Lanmbda"></a>Lanmbda</h2><ul>
<li>It is best to think of a lambda expression as a function, not an object, and to accept that it can be converted to a functional interface.</li>
<li>This conversion to interfaces is what makes lambda expressions so compelling. The syntax is short and simple. <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BiFunction&lt;String, String, Integer&gt; comp</span><br><span class="line">   = (first, second) -&gt; Integer.compare(first.length(), second.length());</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>The expression System.out::printlnis a method reference that is equivalent to the lambda expression x -&gt; System.out.println(x).</p>
<h3 id="There-are-three-principal-cases"><a href="#There-are-three-principal-cases" class="headerlink" title="There are three principal cases:"></a>There are three principal cases:</h3><ul>
<li>object::instanceMethod</li>
<li>Class::staticMethod</li>
<li>Class::instanceMethod</li>
</ul>
<p>In the third case, the first parameter becomes the target of the method. For example, String::compareToIgnoreCaseis the same as (x, y) -&gt; x.compareToIgnoreCase(y).</p>
<p>Just like lambda expressions, method references don’t live in isolation. They are always turned into instances of functional interfaces.</p>
<h3 id="Constructor-References-1"><a href="#Constructor-References-1" class="headerlink" title="Constructor References"></a>Constructor References</h3><p>Constructor references are just like method references, except that the name of the method is new. For example, Button::new is a reference to a Button constructor. Which constructor? It depends on the context. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; labels = ...;</span><br><span class="line">Stream&lt;Button&gt; stream = labels.stream().map(Button::<span class="keyword">new</span>);</span><br><span class="line">List&lt;Button&gt; buttons = stream.collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<p>For example, suppose we want to have an array of buttons. The Stream interface has a toArraymethod that returns an Object array:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Object[] buttons = stream.toArray();</span><br></pre></td></tr></table></figure>

<p>we need to refine our understanding of a lambda expression. A lambda expression has three ingredients:</p>
<ul>
<li><ol>
<li>A block of code</li>
</ol>
</li>
<li><ol start="2">
<li>Parameters</li>
</ol>
</li>
<li><ol start="3">
<li>Values for the free variables, that is, the variables that are not parameters and not defined inside the code</li>
</ol>
</li>
</ul>
<p>The technical term for a block of code together with the values of the <code>free variables</code> is a <code>closure</code>. If someone gloats that their language has closures, rest assured that Java has them as well. In Java, lambda expressions are closures. In fact, inner classes have been closures all along. Java 8 gives us closures with an attractive syntax.</p>
<p>Inner classes can also capture values from an enclosing scope. Before Java 8, inner classes were only allowed to access <code>final local variables</code>. This rule has now been relaxed to match that for lambda expressions. An inner class can access any effectively final local variable—that is, any variable whose value does not change.</p>
<p>When you use the this keyword in a lambda expression, you refer to the this parameter of the method that creates the lambda. For example, consider</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doWork</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      Runnable runner = () -&gt; &#123; ...; System.out.println(<span class="keyword">this</span>.toString()); ... &#125;;</span><br><span class="line">      ...</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The expression this.toString()calls the toString method of the Application object, not the Runnable instance. There is nothing special about the use of this in a lambda expression. The scope of the lambda expression is nested inside the doWorkmethod, and thishas the same meaning anywhere in that method.</p>
<p>The Java designers decided to solve this problem once and for all by allowing interface methods with concrete implementations (called default methods). Those methods can be safely added to existing interfaces. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">long</span> <span class="title">getId</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">default</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">"John Q. Public"</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The interface has two methods: getId, which is an abstract method, and the default method getName. A concrete class that implements the Person interface must, of course, provide an implementation of getId, but it can choose to keep the implementation of getName or to override it.</p>
<p>Default methods put an end to the classic pattern of providing an interface and an abstract class that implements most or all of its methods, such as Collection/AbstractCollectionor WindowListener/WindowAdapter. Now you can just implement the methods in the interface.</p>
<p>To compare Person objects by name, use Comparator.comparing(Person::getName).</p>
<p>In this chapter, we have compared strings by length with the lambda expression (first, second) -&gt; Integer.compare(first.length(), second.length()). But But with the static compare method, we can do much better and simply use Comparator.comparing(String::length). </p>
<p>In Java 8, static methods have been added to quite a few interfaces. For example, the Comparator interface has a very useful static comparing method that accepts a “key extraction” function and yields a comparator that compares the extracted keys. </p>
<h3 id="Exercises"><a href="#Exercises" class="headerlink" title="Exercises"></a>Exercises</h3><ol>
<li><p>Is the comparator code in the Arrays.sort method called in the same thread as the call to sortor a different thread?</p>
</li>
<li><p>Using the listFiles(FileFilter)and isDirectorymethods of the java.io.Fileclass, write a method that returns all subdirectories of a given directory. Use a lambda expression instead of a FileFilterobject. Repeat with a method reference.</p>
</li>
<li><p>Using the list(FilenameFilter)method of the java.io.Fileclass, write a method that returns all files in a given directory with a given extension. Use a lambda expression, not a FilenameFilter. Which variables from the enclosing scope does it capture?</p>
</li>
<li><p>Given an array of File objects, sort it so that the directories come before the files, and within each group, elements are sorted by path name. Use a lambda expression, not a Comparator.</p>
</li>
<li><p>Take a file from one of your projects that contains a number of ActionListener, Runnable, or the like. Replace them with lambda expressions. How many lines did it save? Was the code easier to read? Were you able to use method references?</p>
</li>
<li><p>Didn’t you always hate it that you had to deal with checked exceptions in a Runnable? Write a method uncheck that catches all checked exceptions and turns them into unchecked exceptions. For example,</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(uncheck(</span><br><span class="line">   () -&gt; &#123; System.out.println(<span class="string">"Zzz"</span>); Thread.sleep(<span class="number">1000</span>); &#125;)).start();</span><br><span class="line">      <span class="comment">// Look, nocatch (InterruptedException)!</span></span><br></pre></td></tr></table></figure>

<p>Hint: Define an interface RunnableExwhose runmethod may throw any exceptions. Then implement public static Runnable uncheck(RunnableEx runner). Use a lambda expression inside the uncheckmethod.</p>
<p>Why can’t you just use Callable<void>instead of RunnableEx?</void></p>
<ol start="7">
<li><p>Write a static method andThenthat takes as parameters two Runnableinstances and returns a Runnable that runs the first, then the second. In the main method, pass two lambda expressions into a call to andThen, and run the returned instance.</p>
</li>
<li><p>What happens when a lambda expression captures values in an enhanced forloop such as this one?</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">String[] names = &#123; <span class="string">"Peter"</span>, <span class="string">"Paul"</span>, <span class="string">"Mary"</span> &#125;;</span><br><span class="line">List&lt;Runnable&gt; runners = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (String name : names)</span><br><span class="line">   runners.add(() -&gt; System.out.println(name));</span><br></pre></td></tr></table></figure>

<p>Is it legal? Does each lambda expression capture a different value, or do they all get the last value? What happens if you use a traditional loop for (int i = 0; i &lt; names.length; i++)?</p>
<ol start="9">
<li><p>Form a subinterface Collection2from Collectionand add a default method void forEachIf(Consumer<t> action, Predicate<t> filter) that applies action to each element for which filterreturns true. How could you use it?</t></t></p>
</li>
<li><p>Go through the methods of the Collectionsclass. If you were king for a day, into which interface would you place each method? Would it be a default method or a static method?</p>
</li>
<li><p>Suppose you have a class that implements two interfaces I and J, each of which has a method void f(). Exactly what happens if f is an abstract, default, or static method of I and an abstract, default, or static method of J? Repeat where a class extends a superclass S and implements an interface I, each of which has a method void f().</p>
</li>
<li><p>In the past, you were told that it’s bad form to add methods to an interface because it would break existing code. Now you are told that it’s okay to add new methods, provided you also supply a default implementation. How safe is that? Describe a scenario where the new streammethod of the Collectioninterface causes legacy code to fail compilation. What about binary compatibility? Will legacy code from a JAR file still run?</p>
</li>
</ol>
<h3 id="Stream-vs-Collections"><a href="#Stream-vs-Collections" class="headerlink" title="Stream vs Collections"></a>Stream vs Collections</h3><p>A stream seems superficially similar to a collection, allowing you to transform and retrieve data. But there are significant differences:</p>
<ol>
<li>A stream <code>does not store</code> its elements. They may be stored in an underlying collection or generated on demand.</li>
<li><code>Stream operations don’t mutate their source</code>. Instead, they return new streams that hold the result.</li>
<li><code>Stream operations are lazy</code> when possible. This means they are not executed until their result is needed. For example, if you only ask for the first five long words instead of counting them all, then the filter method will stop filtering after the fifth match. As a consequence, you can even have infinite streams!</li>
</ol>
<ul>
<li>Streams follow <code>the “what, not how” principle</code>. In our stream example, we describe what needs to be done: get the long words and count them. We don’t specify in which order, or in which thread, this should happen.</li>
</ul>
<ul>
<li>When you work with streams, you set up a pipeline of operations in three stages.</li>
</ul>
<ol>
<li>You create a stream.</li>
<li>You specify intermediate operations for transforming the initial stream into others, in one or more steps.</li>
<li>You apply a terminal operation to produce a result. This operation forces the execution of the lazy operations that precede it. Afterwards, the stream can no longer be used.<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> count = words.parallelStream().filter(w -&gt; w.length() &gt; <span class="number">12</span>).count();</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p><code>Stream operations are not executed on the elements in the order in which they are invoked on the streams</code>. In our example, nothing happens until count is called. When the count method asks for the first element, then the filter method starts requesting elements, until it finds one that has length &gt; 12.</p>
<p>To produce infinite sequences such as 0 1 2 3 …, use the iterate method instead. It takes a “seed” value and a function (technically, a UnaryOperator<t>), and repeatedly applies the function to the previous result. For example,</t></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;BigInteger&gt; integers</span><br><span class="line">   = Stream.iterate(BigInteger.ZERO, n -&gt; n.add(BigInteger.ONE));</span><br></pre></td></tr></table></figure>

<p>The first element in the sequence is the seed</p>
<p>You can use the following statement to split a string into words:</p>
<p>Stream<string> words<br>   = Pattern.compile(“[\P{L}]+”).splitAsStream(contents);<br>The static Files.linesmethod returns a Stream of all lines in a file. </string></p>
<p>The Streaminterface has AutoCloseableas a superinterface. When the close method is called on the stream, the underlying file is also closed. </p>
<p>To make sure that this happens, it is best to use the Java 7 try-with-resources statement:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (Stream&lt;String&gt; lines = Files.lines(path)) &#123;</span><br><span class="line">   Do something with lines</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The stream, and the underlying file with it, will be closed when the try block exits normally or through an exception.</p>
<p>The filter, map, and flatMapMethods<br>A stream transformation reads data from a stream and puts the transformed data into another stream. You have already seen the filtertransformation that yields a new stream with all elements that match a certain condition. </p>
<p>2.3. The filter, map, and flatMapMethods<br>A stream transformation reads data from a stream and puts the transformed data into another stream. You have already seen the filtertransformation that yields a new stream with all elements that match a certain condition. Here, we transform a stream of strings into another stream containing only long words:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; wordList = ...;</span><br><span class="line">Stream&lt;String&gt; words = wordList.stream();</span><br><span class="line">Stream&lt;String&gt; longWords = words.filter(w -&gt; w.length() &gt; <span class="number">12</span>);</span><br></pre></td></tr></table></figure>

<p>The argument of filter is a Predicate<t>—that is, a function from T to boolean.</t></p>
<p>Often, you want to transform the values in a stream in some way. Use the map method and pass the function that carries out the transformation. For example, you can transform all words to lowercase like this:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; lowercaseWords = words.map(String::toLowerCase);</span><br></pre></td></tr></table></figure>

<p>Here, we used map with a method reference. Often, you will use a lambda expression instead:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Character&gt; firstChars = words.map(s -&gt; s.charAt(<span class="number">0</span>));</span><br></pre></td></tr></table></figure>

<p>The resulting stream contains the first character of each word.</p>
<p>When you use map, a function is applied to each element, and the return values are collected in a new stream. Now suppose that you have a function that returns not just one value but a stream of values, such as this one:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Stream&lt;Character&gt; <span class="title">characterStream</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">   List&lt;Character&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">char</span> c : s.toCharArray()) result.add(c);</span><br><span class="line">   <span class="keyword">return</span> result.stream();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>For example, characterStream(“boat”)is the stream [‘b’, ‘o’, ‘a’, ‘t’]. Suppose you map this method on a stream of strings:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Stream&lt;Character&gt;&gt; result = words.map(w -&gt; characterStream(w));</span><br></pre></td></tr></table></figure>

<p>You will get a stream of streams, like [… [‘y’, ‘o’, ‘u’, ‘r’], [‘b’, ‘o’, ‘a’, ‘t’], …] To flatten it out to a stream of characters [… ‘y’, ‘o’, ‘u’, ‘r’, ‘b’, ‘o’, ‘a’, ‘t’, …], use the flatMapmethod instead of map:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Character&gt; letters = words.flatMap(w -&gt; characterStream(w))</span><br><span class="line">    <span class="comment">// CallscharacterStream on each word and flattens the results</span></span><br><span class="line"> NOTE</span><br></pre></td></tr></table></figure>

<p>You may find a flatMap method in classes other than streams. It is a general concept in computer science. Suppose you have a generic type G (such as Stream) and functions ffrom some type T to G<u>and g from U to G<v>. Then you can compose them, that is, first apply f and then g, by using flatMap. This is a key idea in the theory of monads. But don’t worry—you can use flatMapwithout knowing anything about monads.</v></u></p>
<p>This method is particularly useful for cutting infinite streams down to size. For example,</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Double&gt; randoms = Stream.generate(Math::random).limit(<span class="number">100</span>);</span><br></pre></td></tr></table></figure>

<p>yields a stream with 100 random numbers.</p>
<p>The peek method yields another stream with the same elements as the original, but a function is invoked every time an element is retrieved. That is handy for debugging:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object[] powers = Stream.iterate(<span class="number">1.0</span>, p -&gt; p * <span class="number">2</span>)</span><br><span class="line">   .peek(e -&gt; System.out.println(<span class="string">"Fetching "</span> + e))</span><br><span class="line">   .limit(<span class="number">20</span>).toArray();</span><br></pre></td></tr></table></figure>

<p>When an element is actually accessed, a message is printed. This way you can verify that the infinite stream returned by iterate is processed lazily.</p>
<p>The stream transformations of the preceding sections were <code>stateless</code>. When an element is retrieved from a filtered or mapped stream, the answer does not depend on the previous elements. There are also a few stateful transformations. For example, the distinct method returns a stream that yields elements from the original stream, in the same order, except that duplicates are suppressed.</p>
<p>The stream must obviously remember the elements that it has already seen.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; uniqueWords</span><br><span class="line">   = Stream.of(<span class="string">"merrily"</span>, <span class="string">"merrily"</span>, <span class="string">"merrily"</span>, <span class="string">"gently"</span>).distinct();</span><br><span class="line">   <span class="comment">// Only one"merrily" is retained</span></span><br></pre></td></tr></table></figure>

<p>The sorted method must see the entire stream and sort it before it can give out any elements—after all, the smallest one might be the last one. Clearly, you can’t sort an infinite stream.</p>
<ul>
<li>There are several sorted methods. One works for streams of Comparableelements, and another accepts a Comparator. Here, we sort strings so that the longest ones come first:</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; longestFirst =</span><br><span class="line">   words.sorted(Comparator.comparing(String::length).reversed());</span><br></pre></td></tr></table></figure>

<p>Of course, you can sort a collection without using streams. The sorted method is useful when the sorting process is a part of a stream pipeline.</p>
<p><code>The Collections.sort method sorts a collection in place, whereas Stream.sorted returns a new sorted stream.</code></p>
<p>The methods that we cover in this section are called reductions. <code>They reduce the stream to a value that can be used in your program</code>. Reductions are terminal operations. After a terminal operation has been applied, the stream ceases to be usable.</p>
<p>In Java 8, <code>the Optional type is the preferred way of indicating a missing return value</code>. We discuss the Optional type in detail in the next section. Here is how you can get the maximum of a stream:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;String&gt; largest = words.max(String::compareToIgnoreCase);</span><br><span class="line"><span class="keyword">if</span> (largest.isPresent())</span><br><span class="line">   System.out.println(<span class="string">"largest: "</span> + largest.get());</span><br></pre></td></tr></table></figure>

<p>reduce. Each segment needs to start out with its own empty hash set, and reduce only lets you supply one identity value. </p>
<h2 id="Instead-use-collect-It-takes-three-arguments"><a href="#Instead-use-collect-It-takes-three-arguments" class="headerlink" title="Instead, use collect. It takes three arguments:"></a>Instead, use collect. It takes three arguments:</h2><ol>
<li>A <code>supplier to make new instances of the target object</code>, for example, a constructor for a hash set</li>
<li>An <code>accumulatorthat adds an element to the target</code>, for example, an addmethod</li>
<li>A <code>combiner that merges two objects into one</code>, such as addAll</li>
</ol>
<p>The target object need not be a collection. It could be a StringBuilder or an object that tracks a count and a sum.</p>
<p>Here is how the collect method works for a hash set:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HashSet&lt;String&gt; result = stream.collect(HashSet::<span class="keyword">new</span>, HashSet::add, HashSet::addAll);</span><br></pre></td></tr></table></figure>

<p>In practice, you don’t have to do that because there is a convenient Collector interface for these three functions, and a Collectors class with factory methods for common collectors. To collect a stream into a list or set, you can simply call</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; result = stream.collect(Collectors.toList());</span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"></span><br><span class="line">Set&lt;String&gt; result = stream.collect(Collectors.toSet());</span><br></pre></td></tr></table></figure>

<p>If you want to control which kind of set you get, use the following call instead:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TreeSet&lt;String&gt; result = stream.collect(Collectors.toCollection(TreeSet::<span class="keyword">new</span>));</span><br></pre></td></tr></table></figure>

<p>Suppose you want to collect all strings in a stream by concatenating them. You can call</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String result = stream.collect(Collectors.joining());</span><br></pre></td></tr></table></figure>

<p>If you want a delimiter between elements, pass it to the joiningmethod:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String result = stream.collect(Collectors.joining(<span class="string">", "</span>));</span><br></pre></td></tr></table></figure>

<p>If your stream contains objects other than strings, you need to first convert them to strings, like this:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String result = stream.map(Object::toString).collect(Collectors.joining(<span class="string">", "</span>));</span><br></pre></td></tr></table></figure>

<p>If you want to reduce the stream results to a sum, average, maximum, or minimum, then use one of the methods summarizing(Int|Long|Double). These methods take a function that maps the stream objects to a number and yield a result of type (Int|Long|Double)SummaryStatistics, with methods for obtaining the sum, average, maximum, and minumum.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">IntSummaryStatistics summary = words.collect(</span><br><span class="line">   Collectors.summarizingInt(String::length));</span><br><span class="line"><span class="keyword">double</span> averageWordLength = summary.getAverage();</span><br><span class="line"><span class="keyword">double</span> maxWordLength = summary.getMax();</span><br></pre></td></tr></table></figure>

<p>So far, you have seen how to reduce or collect stream values. But perhaps you just want to print them or put them in a database. Then you can use the forEach method:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stream.forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<p>The function that you pass is applied to each element. On a parallel stream, it’s your responsibility to ensure that the function can be executed concurrently. We discuss this in Section 2.13, “Parallel Streams,”.</p>
<p>On a parallel stream, the elements can be traversed in arbitrary order. If you want to execute them in stream order, call forEachOrderedinstead. Of course, you might then give up most or all of the benefits of parallelism.</p>
<p><code>The forEach and forEachOrdered methods are terminal operations</code>. You cannot use the stream again after calling them. If you want to continue using the stream, use peek instead—see</p>
<p>In the common case that the values should be the actual elements, use Function.identity() for the second function.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Integer, Person&gt; idToPerson = people.collect(</span><br><span class="line">   Collectors.toMap(Person::getId, Function.identity()));</span><br></pre></td></tr></table></figure>

<p>If there is more than one element with the same key, the collector will throw an IllegalStateException. You can override that behavior by supplying a third function argument that determines the value for the key, given the existing and the new value. Your function could return the existing value, the new value, or a combination of them.</p>
<p>Here, we construct a map that contains, for each language in the available locales, as key its name in your default locale (such as “German”), and as value its localized name (such as “Deutsch”).</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Locale&gt; locales = Stream.of(Locale.getAvailableLocales());</span><br><span class="line">Map&lt;String, String&gt; languageNames = locales.collect(</span><br><span class="line">   Collectors.toMap(</span><br><span class="line">      l -&gt; l.getDisplayLanguage(),</span><br><span class="line">      l -&gt; l.getDisplayLanguage(l),</span><br><span class="line">      (existingValue, newValue) -&gt; existingValue));</span><br></pre></td></tr></table></figure>

<p>We don’t care that the same language might occur twice—for example, German in Germany and in Switzerland, and we just keep the first entry.</p>
<p>However, suppose we want to know all languages in a given country. Then we need a Map&lt;String, Set<string>&gt;. For example, the value for “Switzerland”is the set [French, German, Italian]. At first, we store a singleton set for each language. Whenever a new language is found for a given country, we form the union of the existing and the new set.</string></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Set&lt;String&gt;&gt; countryLanguageSets = locales.collect(</span><br><span class="line">   Collectors.toMap(</span><br><span class="line">      l -&gt; l.getDisplayCountry(),</span><br><span class="line">      l -&gt; Collections.singleton(l.getDisplayLanguage()),</span><br><span class="line">      (a, b) -&gt; &#123; <span class="comment">// Union of a and b</span></span><br><span class="line">         Set&lt;String&gt; r = <span class="keyword">new</span> HashSet&lt;&gt;(a);</span><br><span class="line">         r.addAll(b);</span><br><span class="line">         <span class="keyword">return</span> r; &#125;));</span><br></pre></td></tr></table></figure>

<p>You will see a simpler way of obtaining this map in the next section.</p>
<p>If you want a TreeMap, then you supply the constructor as the fourth argument. You must provide a merge function. Here is one of the examples from the beginning of the section, now yielding a TreeMap:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Integer, Person&gt; idToPerson = people.collect(</span><br><span class="line">   Collectors.toMap(</span><br><span class="line">      Person::getId,</span><br><span class="line">      Function.identity(),</span><br><span class="line">      (existingValue, newValue) -&gt; &#123; <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(); &#125;,</span><br><span class="line">      TreeMap::<span class="keyword">new</span>));</span><br></pre></td></tr></table></figure>

<p>For example, if you want sets instead of lists, you can use the Collectors.toSetcollector that you saw in the preceding section:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Set&lt;Locale&gt;&gt; countryToLocaleSet = locales.collect(</span><br><span class="line">   groupingBy(Locale::getCountry, toSet()));</span><br></pre></td></tr></table></figure>

<p>Several other collectors are provided for downstream processing of grouped elements:</p>
<p>• counting produces a count of the collected elements. For example,</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Long&gt; countryToLocaleCounts = locales.collect(</span><br><span class="line">   groupingBy(Locale::getCountry, counting()));</span><br></pre></td></tr></table></figure>

<p>counts how many locales there are for each country.</p>
<p>• summing(Int|Long|Double) takes a function argument, applies the function to the downstream elements, and produces their sum. For example,</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Integer&gt; stateToCityPopulation = cities.collect(</span><br><span class="line">   groupingBy(City::getState, summingInt(City::getPopulation)));</span><br></pre></td></tr></table></figure>

<p>computes the sum of populations per state in a stream of cities.</p>
<p>• maxBy and minBy take a comparator and produce maximum and minimum of the downstream elements. For example,</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, City&gt; stateToLargestCity = cities.collect(</span><br><span class="line">   groupingBy(City::getState,</span><br><span class="line">      maxBy(Comparator.comparing(City::getPopulation))));</span><br></pre></td></tr></table></figure>

<p>produces the largest city per state.</p>
<p>• mapping applies a function to downstream results, and it requires yet another collector for processing its results. For example,</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Optional&lt;String&gt;&gt; stateToLongestCityName = cities.collect(</span><br><span class="line">   groupingBy(City::getState,</span><br><span class="line">      mapping(City::getName,</span><br><span class="line">         maxBy(Comparator.comparing(String::length)))));</span><br></pre></td></tr></table></figure>

<p>Here, we group cities by state. Within each state, we produce the names of the cities and reduce by maximum length.</p>
<p>The mapping method also yields a nicer solution to a problem from the preceding section, to gather a set of all languages in a country.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Set&lt;String&gt;&gt; countryToLanguages = locales.collect(</span><br><span class="line">   groupingBy(l -&gt; l.getDisplayCountry(),</span><br><span class="line">      mapping(l -&gt; l.getDisplayLanguage(),</span><br><span class="line">         toSet())));</span><br></pre></td></tr></table></figure>

<p>In the preceding section, I used toMap instead of groupingBy. In this form, you don’t need to worry about combining the individual sets.</p>
<p>• If the grouping or mapping function has return type int, long, or double, you can collect elements into a summary statistics object, as discussed in Section 2.9, “Collecting Results,” on page 33. For example,</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, IntSummaryStatistics&gt; stateToCityPopulationSummary = cities.collect(</span><br><span class="line">   groupingBy(City::getState,</span><br><span class="line">      summarizingInt(City::getPopulation)));</span><br></pre></td></tr></table></figure>

<p>Then you can get the sum, count, average, minimum, and maximum of the function values from the summary statistics objects of each group.</p>
<p>• Finally, the reducingmethods apply a general reduction to downstream elements. There are three forms: reducing(binaryOperator), reducing(identity, binaryOperator), and reducing(identity, mapper, binaryOperator). In the first form, the identity is null. (Note that this is different from the forms of Stream::reduce, where the method without an identity parameter yields an Optional result.) In the third form, the mapperfunction is applied and its values are reduced.</p>
<p>Here is an example that gets a comma-separated string of all city names in each state. We map each city to its name and then concatenate them.</p>
<p>Click here to view code image</p>
<p>Map&lt;String, String&gt; stateToCityNames = cities.collect(<br>   groupingBy(City::getState,<br>      reducing(“”, City::getName,<br>         (s, t) -&gt; s.length() == 0 ? t : s + “, “ + t)));<br>As with Stream.reduce, Collectors.reducingis rarely necessary. In this case, you can achieve the same result more naturally as</p>
<p>Click here to view code image</p>
<p>Map&lt;String, String&gt; stateToCityNames = cities.collect(<br>   groupingBy(City::getState,<br>      mapping(City::getName,<br>         joining(“, “))));<br>Frankly, the downstream collectors can yield very convoluted expressions. You should only use them in connection with groupingBy or partitioningBy to process the “downstream” map values. Otherwise, simply apply methods such as map, reduce, count, max, or mindirectly on streams.</p>
<p>2.12. Primitive Type Streams<br>So far, we have collected integers in a Stream<integer>, even though it is clearly inefficient to wrap each integer into a wrapper object. The same is true for the other primitive types double, float, long, short, char, byte, and boolean. The stream library has specialized types IntStream, LongStream, and DoubleStream that store primitive values directly, without using wrappers. If you want to store short, char, byte, and boolean, use an IntStream, and for float, use a DoubleStream. The library designers didn’t think it was worth adding another five stream types.</integer></p>
<p>To create an IntStream, you can call the IntStream.of and Arrays.streammethods:</p>
<p>Click here to view code image</p>
<p>IntStream stream = IntStream.of(1, 1, 2, 3, 5);<br>stream = Arrays.stream(values, from, to); // values is an int[] array<br>As with object streams, you can also use the static generate and iterate methods. In addition, IntStreamand LongStreamhave static methods range and rangeClosed that generate integer ranges with step size one:</p>
<p>Click here to view code image</p>
<p>IntStream zeroToNinetyNine = IntStream.range(0, 100); // Upper bound is excluded<br>IntStream zeroToHundred = IntStream.rangeClosed(0, 100); // Upper bound is included<br>The CharSequenceinterface has methods codePoints and chars that yield an IntStream of the Unicode codes of the characters or of the code units in the UTF-16 encoding. (If you don’t know what code units are, you probably shouldn’t use the chars method. Read up on the sordid details in Core Java, 9th Edition, Volume 1, Section 3.3.3.)</p>
<p>Click here to view code image</p>
<p>String sentence = “\uD835\uDD46 is the set of octonions.”;<br>   // \uD835\uDD46 is the UTF-16 encoding of the letter  , unicode U+1D546</p>
<p>IntStream codes = sentence.codePoints();<br>   // The stream with hex values 1D546 20 69 73 20 …<br>When you have a stream of objects, you can transform it to a primitive type stream with the mapToInt, mapToLong, or mapToDoublemethods. For example, if you have a stream of strings and want to process their lengths as integers, you might as well do it in an IntStream:</p>
<p>Click here to view code image</p>
<p>Stream<string> words = …;<br>IntStream lengths = words.mapToInt(String::length);<br>To convert a primitive type stream to an object stream, use the boxed method:</string></p>
<p>Click here to view code image</p>
<p>Stream<integer> integers = IntStream.range(0, 100).boxed();</integer></p>
<p>Generally, the methods on primitive type streams are analogous to those on object streams. Here are the most notable differences:</p>
<p>• The toArraymethods return primitive type arrays.</p>
<p>• Methods that yield an optional result return an OptionalInt, OptionalLong, or OptionalDouble. These classes are analogous to the Optional class, but they have methods getAsInt, getAsLong, and getAsDoubleinstead of the getmethod.</p>
<p>• There are methods sum, average, max, and min that return the sum, average, maximum, and minimum. These methods are not defined for object streams.</p>
<p>• The summaryStatisticsmethod yields an object of type IntSummaryStatistics, LongSummaryStatistics, or DoubleSummaryStatisticsthat can simultaneously report the sum, average, maximum, and minimum of the stream.</p>
<p> NOTE</p>
<p>The Randomclass has methods ints, longs, and doubles that return primitive type streams of random numbers.</p>
<p>2.13. Parallel Streams<br>Streams make it easy to parallelize bulk operations. The process is mostly automatic, but you need to follow a few rules. First of all, you must have a parallel stream. By default, stream operations create sequential streams, except for Collection.parallelStream(). The parallelmethod converts any sequential stream into a parallel one. For example:</p>
<p>Click here to view code image</p>
<p>Stream<string> parallelWords = Stream.of(wordArray).parallel();</string></p>
<p>As long as the stream is in parallel mode when the terminal method executes, all lazy intermediate stream operations will be parallelized.</p>
<p>When stream operations run in parallel, the intent is that the same result is returned as if they had run serially. It is important that the operations are stateless and can be executed in an arbitrary order.</p>
<p>Here is an example of something you cannot do. Suppose you want to count all short words in a stream of strings:</p>
<p>Click here to view code image</p>
<p>int[] shortWords = new int[12];<br>words.parallel().forEach(<br>   s -&gt; { if (s.length() &lt; 12) shortWords[s.length()]++; });<br>      // Error—race condition!
System.out.println(Arrays.toString(shortWords));<br>This is very, very bad code. The function passed to forEachruns concurrently in multiple threads, updating a shared array. That’s a classic race condition. If you run this program multiple times, you are quite likely to get a different sequence of counts in each run, each of them wrong.</p>
<p>It is your responsibility to ensure that any functions that you pass to parallel stream operations are threadsafe. In our example, you could use an array of AtomicIntegerobjects for the counters (see Exercise 12). Or you could simply use the facilities of the streams library and group strings by length (see Exercise 13).</p>
<p>By default, streams that arise from ordered collections (arrays and lists), from ranges, generators, and iterators, or from calling Stream.sorted, are ordered. Results are accumulated in the order of the original elements, and are entirely predictable. If you run the same operations twice, you will get exactly the same results.</p>
<p>Ordering does not preclude parallelization. For example, when computing stream.map(fun), the stream can be partitioned into nsegments, each of which is concurrently processed. Then the results are reassembled in order.</p>
<p>Some operations can be more effectively parallelized when the ordering requirement is dropped. By calling the Stream.unorderedmethod, you indicate that you are not interested in ordering. One operation that can benefit from this is Stream.distinct. On an ordered stream, distinct retains the first of all equal elements. That impedes parallelization—the thread processing a segment can’t know which elements to discard until the preceding segment has been processed. If it is acceptable to retain any of the unique elements, all segments can be processed concurrently (using a shared set to track duplicates).</p>
<p>You can also speed up the limit method by dropping ordering. If you just want any nelements from a stream and you don’t care which ones you get, call</p>
<p>Click here to view code image</p>
<p>Stream<t> sample = stream.parallel().unordered().limit(n);</t></p>
<p>As discussed in Section 2.10, “Collecting into Maps,” on page 34, merging maps is expensive. For that reason, the Collectors.groupingByConcurrentmethod uses a shared concurrent map. Clearly, to benefit from parallelism, the order of the map values will not be the same as the stream order. Even on an ordered stream, that collector has a “characteristic” of being unordered, so that it can be used efficiently without having to make the stream unordered. You still need to make the stream parallel, though:</p>
<p>Click here to view code image</p>
<p>Map&lt;String, List<string>&gt; result = cities.parallel().collect(<br>   Collectors.groupingByConcurrent(City::getState));<br>   // Values aren’t collected in stream order<br> CAUTION</string></p>
<p>It is very important that you don’t modify the collection that is backing a stream while carrying out a stream operation (even if the modification is threadsafe). Remember that streams don’t collect their own data—the data is always in a separate collection. If you were to modify that collection, the outcome of the stream operations would be undefined. The JDK documentation refers to this requirement as noninterference. It applies both to sequential and parallel streams.</p>
<p>To be exact, since intermediate stream operations are lazy, it is possible to mutate the collection up to the point when the terminal operation executes. For example, the following is correct:</p>
<p>Click here to view code image</p>
<p>List<string> wordList = …;<br>Stream<string> words = wordList.stream();<br>wordList.add(“END”); // Ok<br>long n = words.distinct().count();<br>But this code is not:</string></string></p>
<p>Click here to view code image</p>
<p>Stream<string> words = wordList.stream();<br>words.forEach(s -&gt; if (s.length() &lt; 12) wordList.remove(s));<br>   // Error—interference</string></p>
<p>Exercises</p>
<ol>
<li><p>Write a parallel version of the forloop in Section 2.1, “From Iteration to Stream Operations,” on page 22. Obtain the number of processors. Make that many separate threads, each working on a segment of the list, and total up the results as they come in. (You don’t want the threads to update a single counter. Why?)</p>
</li>
<li><p>Verify that asking for the first five long words does not call the filter method once the fifth long word has been found. Simply log each method call.</p>
</li>
<li><p>Measure the difference when counting long words with a parallelStreaminstead of a stream. Call System.nanoTimebefore and after the call, and print the difference. Switch to a larger document (such as War and Peace) if you have a fast computer.</p>
</li>
<li><p>Suppose you have an array int[] values = { 1, 4, 9, 16 }. What is Stream.of(values)? How do you get a stream of intinstead?</p>
</li>
<li><p>Using Stream.iterate, make an infinite stream of random numbers—not by calling Math.random but by directly implementing a linear congruential generator. In such a generator, you start with x0 = seedand then produce xn + 1 = (a xn + c) %m, for appropriate values of a, c, and m. You should implement a method with parameters a, c, m, and seed that yields a Stream<long>. Try out a = 25214903917, c = 11, and m = 248.</long></p>
</li>
<li><p>The characterStreammethod in Section 2.3, “The filter, map, and flatMapMethods,” on page 25, was a bit clumsy, first filling an array list and then turning it into a stream. Write a stream-based one-liner instead. One approach is to make a stream of integers from 0 to s.length() - 1and map that with the s::charAtmethod reference.</p>
</li>
<li><p>Your manager asks you to write a method public static <t> boolean isFinite(Stream<t> stream). Why isn’t that such a good idea? Go ahead and write it anyway.</t></t></p>
</li>
<li><p>Write a method public static <t> Stream<t> zip(Stream<t> first, Stream<t> second) that alternates elements from the streams first and second, stopping when one of them runs out of elements.</t></t></t></t></p>
</li>
<li><p>Join all elements in a Stream&lt;ArrayList<t>&gt;to one ArrayList<t>. Show how to do this with the three forms of reduce.</t></t></p>
</li>
<li><p>Write a call to reduce that can be used to compute the average of a Stream<double>. Why can’t you simply compute the sum and divide by count()?</double></p>
</li>
<li><p>It should be possible to concurrently collect stream results in a single ArrayList, instead of merging multiple array lists, provided it has been constructed with the stream’s size, since concurrent setoperations at disjoint positions are threadsafe. How can you achieve that?</p>
</li>
<li><p>Count all short words in a parallel Stream<string>, as described in Section 2.13, “Parallel Streams,” on page 40, by updating an array of AtomicInteger. Use the atomic getAndIncrementmethod to safely increment each counter.</string></p>
</li>
<li><p>Repeat the preceding exercise, but filter out the short strings and use the collectmethod with Collectors.groupingByand Collectors.counting.</p>
</li>
</ol>
<p>A function type is alwayscontravariant in its arguments and covariant in its return value. For example, if you have a Function&lt;Person, Employee&gt;, you can safely pass it on to someone who needs a Function&lt;Employee, Person&gt;. They will only call it with employees, whereas your function can handle any person. They will expect the function to return a person, and you give them something even better.</p>
<p>For example, look at the javadoc for Stream<t>:</t></p>
<p>Click here to view code image</p>
<p>void forEach(Consumer&lt;? super T&gt; action)<br>Stream<t> filter(Predicate&lt;? super T&gt; predicate)<br><r> Stream<r> map(Function&lt;? super T, ? extends R&gt; mapper)<br>The general rule is that you use superfor argument types, extends for return types. That way, you can pass a Consumer<object>to forEach on a Stream<string>. If it is willing to consume any object, surely it can consume strings.</string></object></r></r></t></p>
<p>But the wildcards are not always there. Look at</p>
<p>For example, consider the doInOrderAsyncmethod of the preceding section. Instead of</p>
<p>Click here to view code image</p>
<p>public static <t> void doInOrderAsync(Supplier<t> first,<br>   Consumer<t> second, Consumer<throwable> handler)<br>it should be</throwable></t></t></t></p>
<p>Click here to view code image</p>
<p>public static <t> void doInOrderAsync(Supplier&lt;? extends T&gt; first,<br>   Consumer&lt;? super T&gt; second, Consumer&lt;? superThrowable&gt; handler)</t></p>
<p>In our example, we can call</p>
<p>Click here to view code image</p>
<p>largest.updateAndGet(x -&gt; Math.max(x, observed));</p>
<p>or</p>
<p>Click here to view code image</p>
<p>largest.accumulateAndGet(observed, Math::max);</p>
<p>The accumulateAndGetmethod takes a binary operator that is used to combine the atomic value and the supplied argument.</p>
<p>If you anticipate high contention, you should simply use a LongAdder instead of an AtomicLong. The method names are slightly different. Call increment to increment a counter or add to add a quantity, and sum to retrieve the total.</p>
<p>Click here to view code image</p>
<p>final LongAdder adder = new LongAdder();<br>for (…)<br>   pool.submit(() -&gt; {<br>      while (…) {<br>         …<br>         if (…) adder.increment();<br>      }<br>   });<br>…<br>long total = adder.sum());<br> NOTE</p>
<p>The Arrays class now has a number of parallelized operations. The static Arrays.parallelSortmethod can sort an array of primitive values or objects. For example,</p>
<p>Click here to view code image</p>
<p>String contents = new String(Files.readAllBytes(<br>    Paths.get(“alice.txt”)), StandardCharsets.UTF_8); // Read file into string<br>String[] words = contents.split(“[\P{L}]+”); // Split along nonletters<br>Arrays.parallelSort(words);<br>When you sort objects, you can supply a Comparator. With all methods, you can supply the bounds of a range, such as</p>
<p>Click here to view code image</p>
<p>Arrays.parallelSort(values, values.length / 2, values.length); // Sort the upper half</p>
<p>There was no easy way of saying: “When the result becomes available, here is how to process it.” This is the crucial feature that the new CompletableFuture<t>class provides.</t></p>
<p>This composability is the key aspect of the CompletableFutureclass. Composing future actions solves a serious problem in programming asynchronous applications. The traditional approach for dealing with nonblocking calls is to use event handlers. The programmer registers a handler for the next action after completion. Of course, if the next action is also asynchronous, then the next action after that is in a different event handler. Even though the programmer thinks in terms of “first do step 1, then step 2, then step 3,” the program logic becomes dispersed in different places.</p>
<p>For example, here is a two-stage pipeline for reading and processing the web page:</p>
<p>Click here to view code image</p>
<p>CompletableFuture&lt;List<url>&gt; links<br>   = CompletableFuture.supplyAsync(() -&gt; blockingReadPage(url))<br>      .thenApply(Parser::getLinks);<br>You can have additional processing steps. Eventually, you’ll be done, and you will need to save the results somewhere. Here, we just print the result.</url></p>
<p>Click here to view code image</p>
<p>CompletableFuture<void> links<br>   = CompletableFuture.supplyAsync(() -&gt; blockingReadPage(url))<br>      .thenApply(Parser::getLinks)<br>      .thenAccept(System.out::println);<br>The thenAcceptmethod takes a Consumer—that is, a function with return type void.</void></p>
<p>Ideally, you would never call get on a future. The last step in the pipeline simply deposits the result where it belongs.</p>
<p>Files.lineslazily reads a stream of lines.</p>
<p>• Files.listlazily lists the entries of a directory, and Files.walktraverses them recursively.</p>
<p>8.4.2. Comparators<br>The Comparatorinterface has a number of useful new methods, taking advantage of the fact that interfaces can now have concrete methods.</p>
<p>The static comparingmethod takes a “key extractor” function that maps a type T to a comparable type (such as String). The function is applied to the objects to be compared, and the comparison is then made on the returned keys. For example, suppose you have an array of Personobjects. Here is how you can sort them by name:</p>
<p>Click here to view code image</p>
<p>Arrays.sort(people, Comparator.comparing(Person::getName));</p>
<p>You can chain comparators with the thenComparingmethod for breaking ties. For example,</p>
<p>Click here to view code image</p>
<p>Arrays.sort(people,<br>   Comparator.comparing(Person::getLastName)<br>   .thenComparing(Person::getFirstName));<br>If two people have the same last name, then the second comparator is used.</p>
<p>There are a few variations of these methods. You can specify a comparator to be used for the keys that the comparingand thenComparingmethods extract. For example, here we sort people by the length of their names:</p>
<p>Click here to view code image</p>
<p>Arrays.sort(people, Comparator.comparing(Person::getName,<br>   (s, t) -&gt; Integer.compare(s.length(), t.length())));<br>Moreover, both the comparing and thenComparingmethods have variants that avoid boxing of int, long, or doublevalues. An easier way of producing the preceding operation would be</p>
<p>Click here to view code image</p>
<p>Arrays.sort(people, Comparator.comparingInt(p -&gt; p.getName().length()));</p>
<p>If your key function can return null, you will like the nullsFirst and nullsLast adapters. These static methods take an existing comparator and modify it so that it doesn’t throw an exception when encountering nullvalues but ranks them as smaller or larger than regular values. For example, suppose getMiddleNamereturns a null when a person has no middle name. Then you can use Comparator.comparing(Person::getMiddleName(), Comparator.nullsFirst(…)).</p>
<p>The nullsFirstmethod needs a comparator—in this case, one that compares two strings. The naturalOrdermethod makes a comparator for any class implementing Comparable. A Comparator.<string>naturalOrder()is what we need. Here is the complete call for sorting by potentially null middle names. I use a static import of java.util.Comparator.*, to make the expression more legible. Note that the type for naturalOrder is inferred.</string></p>
<p>Click here to view code image</p>
<p>Arrays.sort(people, comparing(Person::getMiddleName,<br>   nullsFirst(naturalOrder())));<br>The static reverseOrdermethod gives the reverse of the natural order. To reverse any comparator, use the reversed instance method. For example, naturalOrder().reversed()is the same as reverseOrder().</p>
<p>To read the lines of a file lazily, use the Files.linesmethod. It yields a stream of strings, one per line of input:</p>
<p>Click here to view code image</p>
<p>Stream<string> lines = Files.lines(path);<br>Optional<string> passwordEntry = lines.filter(s -&gt; s.contains(“password”)).findFirst();<br>As soon as the first line containing password is found, no further lines are read from the underlying file.</string></string></p>
<p>You will want to close the underlying file. Fortunately, the Stream interface extends AutoCloseable. The streams that you have seen in Chapter 2didn’t need to close any resources. But the Files.linesmethod produces a stream whose closemethod closes the file. The easiest way to make sure the file is indeed closed is to use a Java 7 try-with-resources block:</p>
<p>Click here to view code image</p>
<p>try (Stream<string> lines = Files.lines(path)) {<br>   Optional<string> passwordEntry<br>      = lines.filter(s -&gt; s.contains(“password”)).findFirst();<br>   …<br>} // The stream, and hence the file, will be closed here<br>When a stream spawns another, the close methods are chained. Therefore, you can also write</string></string></p>
<p>Click here to view code image</p>
<p>try (Stream<string> filteredLines<br>      = Files.lines(path).filter(s -&gt; s.contains(“password”))) {<br>   Optional<string> passwordEntry = filteredLines.findFirst();<br>   …<br>}
When filteredLines is closed, it closes the underlying stream, which closes the underlying file.</string></string></p>
<p>If you want to be notified when the stream is closed, you can attach an onClosehandler. Here is how you can verify that closing filteredLinesactually closes the underlying stream:</p>
<p>Click here to view code image</p>
<p>try (Stream<string> filteredLines<br>   = Files.lines(path).onClose(() -&gt; System.out.println(“Closing”))<br>      .filter(s -&gt; s.contains(“password”))) { … }<br>If an IOExceptionoccurs as the stream fetches the lines, that exception is wrapped into an UncheckedIOExceptionwhich is thrown out of the stream operation. </string></p>
<p>In Java 8, just use Files.list.</p>
<p>The list method does not enter subdirectories. To process all descendants of a directory, use the Files.walk method instead.</p>
<p>Click here to view code image</p>
<p>try (Stream<path> entries = Files.walk(pathToRoot)) {<br>   // Contains all descendants, visited in depth-first order<br>}</path></p>

          
        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.todzhang.com/2017-04-20-Concurrent-In-Java/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Todd Zhang">
      <meta itemprop="description" content="Contact me via phray.zhang@gmail.com or wechat at helloworld_2000">
      <meta itemprop="image" content="/images/globe.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Clouds & Docker">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
              
              <a href="/2017-04-20-Concurrent-In-Java/" class="post-title-link" itemprop="url">Java Concurrent</a>
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-05-31 23:03:27" itemprop="dateCreated datePublished" datetime="2019-05-31T23:03:27+10:00">2019-05-31</time>
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h1 id="This-blog-is-about-noteworthy-pivot-points-about-Java-Concurrent-Framework"><a href="#This-blog-is-about-noteworthy-pivot-points-about-Java-Concurrent-Framework" class="headerlink" title="This blog is about noteworthy pivot points about Java Concurrent Framework"></a>This blog is about noteworthy pivot points about Java Concurrent Framework</h1><blockquote>
<p>Back to Java old days there were wait()/notify() which is error prone, while from Java 5.0 there was Concurrent framework being introduced, this page list some pivot points.</p>
</blockquote>
<h1 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h1><ul>
<li>CountDownLatch in Java is a kind of synchronizer which allows one Thread  to wait for one or more Threads before starts processing. </li>
<li>You can also implement same functionality using  wait and notify mechanism in Java but it requires lot of code and getting it write in first attempt is tricky,  With CountDownLatch it can  be done in just few lines.</li>
<li>One of the <strong>disadvantage</strong> of CountDownLatch is that its <strong>not reusable once count reaches to zero</strong> you can not use CountDownLatch any more, but don’t worry Java concurrency API has another concurrent utility called CyclicBarrier for such requirements.<h2 id="When-to-use-CountDownLatch"><a href="#When-to-use-CountDownLatch" class="headerlink" title="When to use CountDownLatch"></a>When to use CountDownLatch</h2>Classical example of using CountDownLatch in Java  is any server side core Java application which uses services architecture,  where multiple services is provided by multiple threads and application can not start processing  until all services have started successfully as shown in our CountDownLatch example.</li>
</ul>
<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><ul>
<li>Main Thread wait on Latch by calling CountDownLatch.await() method while other thread calls CountDownLatch.countDown() to inform that they have completed.</li>
</ul>
<h1 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h1><ul>
<li>there is different you can not reuse CountDownLatch once the count reaches zero while you can <strong>reuse CyclicBarrier</strong> by calling <strong>reset()</strong> method which resets Barrier to its initial State. What it implies that <strong>CountDownLatch is a good for one-time</strong> events like <strong>application start-up time</strong> and <strong>CyclicBarrier can be used to in case of the recurrent event</strong> e.g. concurrently calculating a solution of the big problem etc.</li>
<li>a simple example of CyclicBarrier in Java on which we initialize CyclicBarrier with 3 parties, means <strong>in order to cross barrier, 3 thread needs to call await() method</strong>. each <strong>thread calls await method</strong> in short duration but they <strong>don’t proceed until all 3 threads reached the barrier</strong>, once <strong>all thread reach the barrier</strong>, barrier gets broker and <strong>each thread started their execution</strong> from that point. </li>
<li>Sample can be found at <strong>CyclicBarrierDemo.java</strong><h2 id="Use-cases"><a href="#Use-cases" class="headerlink" title="Use cases:"></a>Use cases:</h2></li>
<li>To implement multi player game which can not begin until all player has joined.</li>
<li>Perform lenghty calculation by breaking it into smaller individual tasks. In general, to implement Map-Reduce technique.</li>
<li>CyclicBarrier can perform a completion task once all thread reaches to the barrier, This can be provided while creating CyclicBarrier.</li>
<li>If CyclicBarrier is initialized with 3 parties means 3 thread needs to call await method to break the barrier.</li>
<li>The thread will block on await() until all parties reach to the barrier, another thread interrupt or await timed out.</li>
<li>CyclicBarrier.reset() put Barrier on its initial state, other thread which is waiting or not yet reached barrier will terminate with java.util.concurrent.BrokenBarrierException.</li>
</ul>
<h1 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h1><ul>
<li>ThreadLocal in Java is another way to achieve thread-safety <strong>apart from writing immutable</strong> classes.</li>
<li>ThreadLocal in Java is a different way to achieve thread-safety, it doesn’t address synchronization requirement, instead it eliminates sharing by providing explicitly copy of Object to each thread.</li>
<li>Since Object is no more shared there is no requirement of Synchronization which can improve scalability and performance of application.</li>
<li>One of the classic example of ThreadLocal is sharing SimpleDateForamt. Since SimpleDateFormat is not thread safe, having a global formatter may not work but having per Thread formatter will certainly work. but it can <strong>be source of severe memory leak</strong> and java.lang.OutOfMemoryError if not used carefully. so avoid until you don’t have any other option.</li>
</ul>
<h1 id="Semaphone"><a href="#Semaphone" class="headerlink" title="Semaphone"></a>Semaphone</h1><ul>
<li>Semaphore provides two main method acquire() and release() for getting permits and releasing permits. acquire() method blocks until permit is available.</li>
<li>Semaphore provides both blocking method as well as unblocking method to acquire permits. This Java concurrency tutorial focus on a very simple example of Binary Semaphore and demonstrate how mutual exclusion can be achieved using Semaphore in Java.<h2 id="Binary-Semaphone"><a href="#Binary-Semaphone" class="headerlink" title="Binary Semaphone"></a>Binary Semaphone</h2>a Counting semaphore with <strong>one permit is known as binary semaphore</strong> because it has only two state permit available or permit unavailable. Binary semaphore can be used to implement mutual exclusion or critical section where only one thread is allowed to execute. Thread will wait on acquire() until Thread inside critical section release permit by calling release() on semaphore.</li>
</ul>
<h2 id="Scenarios-usage"><a href="#Scenarios-usage" class="headerlink" title="Scenarios usage"></a>Scenarios usage</h2><p>1) To implement better Database connection pool which will block if no more connection is available instead of failing and handover Connection as soon as its available.<br>2) To put a bound on collection classes. by using semaphore you can implement bounded collection whose bound is specified by counting semaphore.<br>3)  That’s all on Counting semaphore example in Java. Semaphore is real nice concurrent utility which can greatly simply design and implementation of bounded resource pool. Java 5 has added several useful  concurrent utility and deserve a better attention than casual look.</p>
<h1 id="Race-condition"><a href="#Race-condition" class="headerlink" title="Race condition"></a>Race condition</h1><ul>
<li>Race conditions occurs when two thread operate on same object without proper synchronization and there operation interleaves on each other. Classical example of Race condition is incrementing a counter since increment is not an atomic operation and can be further divided into three steps like read, update and write. if two threads tries to increment count at same time and if they read same value because of interleaving of read operation of one thread to update operation of another thread, one count will be lost when one thread overwrite increment done by other thread.</li>
<li>I found that two code patterns namely <strong>“check and act”</strong> and <strong>“read modify write”</strong> can <strong>suffer race condition</strong> if not synchronized properly. <ul>
<li>classical example of “check and act” race condition in Java is getInstance() method of Singleton Class,</li>
<li>put if absent scenario. consider below code</li>
</ul>
</li>
</ul>
<p>if(!hashtable.contains(key)){</p>
<p>hashtable.put(key,value);</p>
<p>}</p>
<h2 id="Fix-race-condition"><a href="#Fix-race-condition" class="headerlink" title="Fix race condition:"></a>Fix race condition:</h2><p>-In order to fix this race condition in Java you need to wrap this code <strong>inside synchronized block</strong> which makes them atomic together because no thread can go inside synchronized block if one thread is already there.</p>
<ul>
<li><strong>IllegalMonitorStateException in Java which will occur</strong> if we don’t call wait (), notify () or notifyAll () method from synchronized context.</li>
<li>Any potential race condition between wait and notify method in Java</li>
</ul>
<h1 id="Thread-in-Java"><a href="#Thread-in-Java" class="headerlink" title="Thread in Java"></a>Thread in Java</h1><h2 id="details"><a href="#details" class="headerlink" title="details:"></a>details:</h2><ul>
<li>A thread is essentialy a subdivision of a process, or LWP: lightweight process.</li>
<li>Crucially, each process has its own memory space. </li>
<li>A thread is a subdivision that shares the memory space of its parent process. </li>
<li>Threads belonging to a process usually share a few other key resources as well, such as their working directory, environment variables, file handles etc.</li>
<li>On the other hand, each thread has its <strong>own private stack and registers, including program counter</strong>.  program counter (PC) register keeps track of the current instruction executing at any moment. That is like a pointer to the current instruction in sequence of instructions in a program. </li>
<li>Method area: In general, method area is a logical part of heap area. But that is left to the JVM implementers to decide.  Method area has per class structures and fields. Nothing but static fields and structures.</li>
<li>Depending on the OS, threads may have some other private resources too, such as <strong>thread-local storage</strong> (effectively, a way of referring to “variable number X”, where each thread has its own private value of X).</li>
</ul>
<h2 id="Wait-amp-Notify"><a href="#Wait-amp-Notify" class="headerlink" title="Wait &amp; Notify"></a>Wait &amp; Notify</h2><ul>
<li>Since wait method is <strong>not defined in Thread</strong> class, you cannot simply call Thread.wait(), that won’t work but since many Java developers are used to calling Thread.sleep() they try the same thing with wait() method and stuck.</li>
<li>You need to call <strong>wait() method on the object</strong> which is <strong>shared between two threads</strong>, in producer-consumer problem its the queue which is shared between producer and consumer threads.<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(lock)&#123;</span><br><span class="line">	<span class="keyword">while</span>(!someCondition)&#123;</span><br><span class="line">		lock.wait();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><ul>
<li><strong>Always call wait(), notify() and notifyAll() methods from synchronized method or synchronized block</strong> otherwise JVM will <strong>throw IllegalMonitorStateException</strong>.</li>
<li>Always call wait and notify method <strong>from a loop</strong> and <strong>never from if()</strong> block, because loop test waiting condition before and after sleeping and handles notification even if waiting for the condition is not changed.</li>
<li>Always <strong>call wait in shared object</strong> e.g. shared queue in this example.</li>
<li>Prefer <strong>notifyAll() over notify()</strong> method due to reasons given in this article. </li>
</ul>
<h2 id="Fork-Join"><a href="#Fork-Join" class="headerlink" title="Fork-Join"></a>Fork-Join</h2><ul>
<li>Fork/join tasks is “pure” in-memory algorithms in which no I/O operations come into picture.it is based on a <strong>work-stealing algorithm</strong>. </li>
<li>Java’s most attractive part is it makes things easier and easier.</li>
<li>its really challenging where several threads are working together to accomplish a large task so again java has tried to make things easy and simplifies this concurrency using Executors and Thread Queue.</li>
<li>it work on <strong>divide and conquer algorithm</strong> and <strong>create sub-tasks and communicate with each other to complete</strong>.</li>
<li>New fork-join executor framework has been created which is responsible for creating one new task object which is again responsible for creating new sub-task object and waiting for sub-task to be completed.internally it maintains a thread pool and executor assign pending task to this thread pool to complete when one task is waiting for another task to complete. whole Idea of fork-join framework is to leverage multiple processors of advanced machine.</li>
</ul>
<h2 id="Thread-yield"><a href="#Thread-yield" class="headerlink" title="Thread.yield()"></a>Thread.yield()</h2><ul>
<li>This static method is essentially used to notify the system that the current thread is willing to “give up the CPU” for a while. The general idea is that: The thread scheduler will select a different thread to run instead of the current one. However, the details of how yielding is implemented by the thread scheduler differ from platform to platform. In general, you shouldn’t rely on it behaving in a particular way. Things that differ include:<ul>
<li>when, after yielding, the thread will get an opportunity to run again;</li>
<li>whether or not the thread foregoes its remaining quantum.</li>
</ul>
</li>
</ul>
<h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><ul>
<li>In the Hotspot implementation, the way that Thread.yield() works has changed between Java 5 and Java 6.</li>
<li>In <strong>Java 5, Thread.yield() calls the Windows API call Sleep(0)</strong>. This has the special effect of clearing the current thread’s quantum and putting it to the end of the queue for its priority level. In other words, all runnable threads of the same priority (and those of greater priority) will get a chance to run before the yielded thread is next given CPU time. When it is eventually re-scheduled, it will come back with a full quantum, but doesn’t “carry over” any of the remaining quantum from the time of yielding. This behaviour is a little different from a non-zero sleep where the sleeping thread generally loses 1 quantum value (in effect, 1/3 of a 10 or 15ms tick).</li>
<li>In <strong>Java 6, this behaviour was changed. The Hotspot VM now implements Thread.yield() using the Windows SwitchToThread() API call</strong>. This call makes the current thread give up its current timeslice, but not its entire quantum. This means that depending on the priorities of other threads, the yielding thread can be scheduled back in one interrupt period later. </li>
</ul>
<h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><ul>
<li>Under Linux, Hotspot simply calls sched_yield(). The consequences of this call are a little different, and possibly more severe than under Windows:<ul>
<li>a yielded thread will not get another slice of CPU until all other threads have had a slice of CPU;</li>
<li>(at least in kernel 2.6.8 onwards), the fact that the thread has yielded is <strong>implicitly taken into account by the scheduler’s heuristics on its recent CPU allocation</strong> — thus, implicitly, a thread that has yielded could be given more CPU when scheduled in the future.</li>
</ul>
</li>
</ul>
<h3 id="When-to-use-yield"><a href="#When-to-use-yield" class="headerlink" title="When to use yield()?"></a>When to use yield()?</h3><ul>
<li>I would say <strong>practically never</strong>. Its behaviour isn’t standardly defined and there are generally better ways to perform the tasks that you might want to perform with yield():</li>
<li>if you’re trying to use only a portion of the CPU, you can do this in a more controllable way by estimating how much CPU the thread has used in its last chunk of processing, then <strong>sleeping for some amount of time to compensate: see the sleep() method</strong>;</li>
<li>if you’re <strong>waiting for a process or resource to complete or become available, there are more efficient ways to accomplish this, such as by using join() to wait</strong> for another thread to complete, using the wait/notify mechanism to allow one thread to signal to another that a task is complete, or ideally by using one of the Java 5 concurrency constructs such as a Semaphore or blocking queue.</li>
</ul>
<h2 id="Thread-Scheduling"><a href="#Thread-Scheduling" class="headerlink" title="Thread Scheduling"></a>Thread Scheduling</h2><ul>
<li><strong>thread scheduler</strong>, part of the OS (usually) that is responsible for sharing the available CPUs out between the various threads. How exactly the scheduler works depends on the individual platform, but various modern operating systems (notably Windows and Linux) use largely similar techniques that we’ll describe here.</li>
<li>Note that we’ll continue to talk about a single thread scheduler. On multiprocessor systems, there is generally some kind of scheduler per processor, which then need to be coordinated in some way. </li>
<li>Across platforms, thread scheduling tends to be based on at least the following criteria:<ul>
<li>a <strong>priority</strong>, or in fact usually multiple “priority” settings that we’ll discuss below;</li>
<li>a <strong>quantum, or number of allocated timeslices of CPU</strong>, which essentially determines the amount of CPU time a thread is allotted before it is forced to yield the CPU to another thread of the same or lower priority (the system will keep track of the remaining quantum at any given time, plus its default quantum, which could depend on thread type and/or system configuration);</li>
<li>a <strong>state</strong>, notably “runnable” vs “waiting”;</li>
<li><strong>metrics</strong> about the behaviour of threads, such as recent CPU usage or the time since it last ran (i.e. had a share of CPU), or the fact that it has “just received an event it was waiting for”.</li>
</ul>
</li>
<li>Most systems use what we might dub <strong>priority-based round-robin scheduling</strong> to some extent. The general principles are:<ul>
<li>a thread of <strong>higher priority</strong> (which is a function of base and local priorities) will <strong>preempt</strong> a thread of lower priority;</li>
<li>otherwise, threads of equal priority will essentially <strong>take turns</strong> at getting an allocated slice or quantum of CPU;</li>
<li>there are a few extra “tweaks” to make things work.</li>
</ul>
</li>
</ul>
<h3 id="States"><a href="#States" class="headerlink" title="States"></a>States</h3><p>Depending on the system, there are various states that a thread can be in. Probably the two most interesting are:</p>
<ul>
<li><strong>runnable</strong>, which essentially means “ready to consume CPU”; being runnable is generally the minimum requirement for a thread to actually be scheduled on to a CPU;</li>
<li><strong>waiting</strong>, meaning that the thread currently cannot continue as it is waiting for a resource such as a lock or I/O, for memory to be paged in, for a signal from another thread, or simply for a period of time to elapse (sleep).</li>
</ul>
<p>Other states include <strong>terminated</strong>, which means the thread’s code has finished running but not all of the thread’s resources have been cleared up, and a <strong>new</strong> state, in which the thread has been created, but not all resources necessary for it to be runnable have been created. </p>
<h3 id="Quanta-and-clock-ticks"><a href="#Quanta-and-clock-ticks" class="headerlink" title="Quanta and clock ticks"></a>Quanta and clock ticks</h3><ul>
<li>Each thread has a quantum, which is effectively how long it is allowed to keep hold of the CPU if:<ul>
<li>it remains runnable;</li>
<li>the scheduler determines that no other thread needs to run on that CPU instead.</li>
</ul>
</li>
<li>Thread quanta are generally defined in terms of some number of <strong>clock ticks</strong>. If it doesn’t otherwise cease to be runnable, the scheduler decides whether to preempt the currently running thread every clock tick. As a rough guide:<ul>
<li>a clock tick is typically 10-15 ms under Windows; under Linux, it is 1ms (kernel 2.6.8 onwards);</li>
<li>a quantum is usually a small number of clock ticks, depending on the OS:<br>either 2, 6 or 12 clock ticks on Windows, depending on whether Windows is running in “server” mode:</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>Windows mode</th>
<th>Foreground process</th>
<th>Non-foreground process</th>
</tr>
</thead>
<tbody><tr>
<td>Normal</td>
<td>6 ticks</td>
<td>2 ticks</td>
</tr>
<tr>
<td>Server</td>
<td>12 ticks</td>
<td>12 ticks</td>
</tr>
</tbody></table>
<p>between 10-200 clock ticks (i.e. 10-200 ms) under Linux, though some granularity is introduced in the calculation— see below.<br>a thread is usually allowed to “save up” unused quantum, up to some limit and granularity.</p>
<ul>
<li>In Windows, a thread’s quantum allocation is fairly stable. In Linux, on the other hand, a thread’s quantum is dynamically adjusted when it is scheduled, depending partly on heuristics about its recent resource usage and partly on a nice value</li>
</ul>
<h4 id="Switching-and-scheduling-algorithms"><a href="#Switching-and-scheduling-algorithms" class="headerlink" title="Switching and scheduling algorithms"></a>Switching and scheduling algorithms</h4><ul>
<li>At key moments, the thread scheduler considers whether to switch the thread that is currently running on a CPU. These key moments are usually:<ul>
<li><strong>periodically</strong>, via an interrupt routine, the scheduler will consider whether the currently running thread on each CPU has reached the end of its allotted <strong>quantum</strong>;</li>
<li>at any time, a currently running thread could <strong>cease to be runnable</strong> (e.g. by needing to wait, reaching the end of its execution or being forcibly killed);</li>
<li>when some other attribute of the thread changes (e.g. its priority or processor affinity4) which means that which threads are running needs to be re-assessed.</li>
</ul>
</li>
<li>At these decision points, the scheduler’s job is essentially to decide, of all the <strong>runnable</strong> threads, <strong>which are the most appropriate to actually be running on the available CPUs</strong>. Potentially, this is quite a complex task. But we don’t want the scheduler to waste too much time deciding “what to do next”. So in practice, a few simple heuristics are used each time the scheduler needs to decide which thread to let run next:<ul>
<li>there’s usually <strong>a fast path</strong> for determining that the currently running thread is still the most appropriate one to continue running (e.g. storing a bitmask of which priorities have runnable threads, so the scheduler can quickly determine that there’s none of a higher priority than that currently running);</li>
<li>if there is a runnable <strong>thread of higher priority</strong> than the currently running one, then the higher priority one will be scheduled in3;</li>
<li>if a thread is “preempted” in this way, it is generally allowed to keep its remaining quantum and continue running when the higher-priority thread is scheduled out again;</li>
<li>when a thread’s <strong>quantum runs out</strong>, the thread is <strong>“put to the back of the queue”</strong> of runnable threads with the given priority and if there’s no queued (runnable) thread of higher priority, then next thread of the same priority will be scheduled in;</li>
<li>at the end of its quantum, if there’s “nothing better to run”, then a <strong>thread could immediately get a new quantum and continue running</strong>;</li>
<li>a thread typically gets a temporary boost to its quantum and/or priority at strategic points.</li>
</ul>
</li>
<li>Quantum and priority boosting<br>Both Windows and Linux (kernel 2.6.8 onwards) implement temporary boosting. Strategic points at which a thread may be given a “boost” include:<ul>
<li>when it has just finished waiting for a lock/signal or I/O5;</li>
<li>when it has not run for a long time (in Windows, this appears to be a simple priority boost after a certain time; in Linux, there is an ongoing calculation based on the thread’s nice value and its recent resource usage);</li>
<li>when a GUI event occurs;</li>
<li>while it owns the focussed window (recent versions of Windows give threads of the owning process a larger quantum; earlier versions give them a priority boost).</li>
</ul>
</li>
</ul>
<h4 id="Context-switching"><a href="#Context-switching" class="headerlink" title="Context switching"></a>Context switching</h4><ul>
<li>context switching. Roughly speaking, this is the procedure that takes place when the system switches between threads running on the available CPUs.</li>
<li>the thread scheduler must actually manage the various thread structures and make decisions about which thread to schedule next where, and every time the thread running on a CPU actually changes— often referred to as a context switch</li>
<li>switching between <strong>threads of different processes</strong> (that is, switching to a thread that belongs to a different process from the one last running on that CPU) <strong>will carry a higher cost</strong>, since the address-to-memory mappings must be changed, and the contents of the cache almost certainly will be irrelevant to the next process.</li>
<li>Context switches appear to typically have a cost somewhere between 1 and 10 microseconds (i.e. between a thousandth and a hundredth of a millisecond) between the fastest and slowest cases (same-process threads with little memory contention vs different processes). So the following are acceptable:<br>1 nanoseconds is billionth of one second,<br>1 microsecond is millionth of one second,<br>1 millisecond is thousandth of one second</li>
</ul>
<h5 id="What-causes-too-many-slow-context-switches-in-Java"><a href="#What-causes-too-many-slow-context-switches-in-Java" class="headerlink" title="What causes too many slow context switches in Java?"></a>What causes too many slow context switches in Java?</h5><ul>
<li>Every time we <strong>deliberately</strong> change a thread’s status or attributes (e.g. by sleeping, waiting on an object, changing the thread’s priority etc), we will cause a context switch. But usually we don’t do those things so many times in a second to matter. Typically, the cause of excessive context switching comes from contention on shared resources, <strong>particularly synchronized locks</strong>:<ul>
<li>rarely, a single object very frequently synchronized on could become a bottleneck;</li>
<li>more frequently, a complex application has several different objects that are each synchronized on with moderate frequency, but overall, threads find it difficult to make progress because they <strong>keep hitting different contended locks</strong> at regular intervals.</li>
</ul>
</li>
</ul>
<h5 id="Avoiding-contention-and-context-switches-in-Java"><a href="#Avoiding-contention-and-context-switches-in-Java" class="headerlink" title="Avoiding contention and context switches in Java"></a>Avoiding contention and context switches in Java</h5><ul>
<li>Firstly, before hacking with your code, a first course of action is upgrading your JVM, particularly if you are not yet using Java 6. Most new Java JVM releases have come with improved synchronization optimisation.</li>
<li>Then, a high-level solution to avoiding synchronized lock contention is generally to use the various classes from the Java 5 concurrency framework (see the java.util.concurrent package). For example, instead of using a HashMap with appropriate synchronization, a ConcurrentHashMap can easily double the throughput with 4 threads and treble it with 8 threads (see the aforementioned link for some ConcurrentHashMap performance measurements). A replacement to synchronized with often better concurrency is offered with various explicit lock classes (such as ReentrantLock).</li>
</ul>
<h6 id="Java-thread-priority"><a href="#Java-thread-priority" class="headerlink" title="Java thread priority"></a>Java thread priority</h6><ul>
<li>Lower-priority threads are given CPU when all higher priority threads are waiting (or otherwise unable to run) at that given moment.</li>
<li>Thread priority <strong>isn’t very meaningful when all threads are competing for CPU</strong>.</li>
<li>The number should lie in the range of two constants <strong>MIN_PRIORITY and MAX_PRIORITY defined on Thread</strong>, and will typically reference <strong>NORM_PRIORITY</strong>, the default priority of a thread if we don’t set it to anything else.</li>
<li>For example, to give a thread a priority that is “half way between normal and maximum”, we could call:<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thr.setPriority((Thread.MAX_PRIORITY - Thread.NORM_PRIORITY) / <span class="number">2</span>);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>####### Some points about thread property</p>
<ul>
<li>depending on your OS and VM version, Thread.setPriority() may actually <strong>do nothing at all</strong> (see below for details);</li>
<li>what thread priorities <strong>mean to the thread scheduler differs from scheduler to scheduler</strong>, and may not be what you intuitively presume; in particular: <strong>Priority may not indicate “share of the CPU”</strong>. As we’ll see below, it turns out that “priority” is more or less an indication of CPU distribution on UNIX systems, but not under Windows.</li>
<li>thread priorities are usually a <strong>combination of “global” and “local” priority settings</strong>, and Java’s setPriority() method typically works only on the local priority— in other words, you can’t set priorities across the entire range possible (this is actually a form of protection— you generally don’t want, say, the mouse pointer thread or a thread handling audio data to be preempted by some random user thread);</li>
<li>the number of distinct priorities available differs from system to system, but Java defines 10 (numbered 1-10 inclusive), so you could end up with threads that have different priorities under one OS, but the same priority (and hence unexpected behaviour) on another;</li>
<li>most operating systems’ thread schedulers actually perform <strong>temporary manipulations</strong> to thread priorities at strategic points (e.g. when a thread receives an event or I/O it was waiting for), and often “the OS knows best”; trying to manually manipulate priorities could just interfere with this system;</li>
<li>your application <strong>doesn’t generally know what threads are running in other processes</strong>, so the effect on the overall system of changing the priority of a thread may be hard to predict. So you might find, for example, that your low-priority thread designed to “run sporadically in the background” hardly runs at all due to a virus dection program running at a slightly higher (but still ‘lower-than-normal’) priority, and that the performance unpredictably varies depending on which antivirus program your customer is using. Of course, effects like these will always happen to some extent or other on modern systems.</li>
</ul>
<h2 id="Thread-scheduling-implications-in-Java"><a href="#Thread-scheduling-implications-in-Java" class="headerlink" title="Thread scheduling implications in Java"></a>Thread scheduling implications in Java</h2><h3 id="Thread-Control"><a href="#Thread-Control" class="headerlink" title="Thread Control"></a>Thread Control</h3><ul>
<li>the granularity and responsiveness of the Thread.sleep() method is largely determined by <strong>the scheduler’s interrupt</strong> period and by how quickly the slept thread becomes the “chosen” thread again;</li>
<li>the precise function of the setPriority() method depends on the specific OS’s interpretation of priority (and which underlying API call Java actually uses when several are available): for more information, see the more detailed section on thread priority;</li>
<li>the behaviour of the Thread.yield() method is similarly determined by what particuar underlying API calls do, and which is actually chosen by the VM implementation.</li>
</ul>
<h3 id="“Granularity”-of-threads"><a href="#“Granularity”-of-threads" class="headerlink" title="“Granularity” of threads"></a>“Granularity” of threads</h3><ul>
<li>Although our introduction to threading focussed on how to create a thread, it turns out that <strong>it isn’t appropriate to create a brand new thread just for a very small task</strong>. Threads are actually quite a “coarse-grained” unit of execution, for reasons that are hopefully becoming clear from the previous sections.</li>
</ul>
<h3 id="Overhead-and-limits-of-creating-and-destroying-threads"><a href="#Overhead-and-limits-of-creating-and-destroying-threads" class="headerlink" title="Overhead and limits of creating and destroying threads"></a>Overhead and limits of creating and destroying threads</h3><ul>
<li>creating and tearing down threads isn’t free: there’ll be some CPU overhead each time we do so;</li>
<li>there may be some moderate limit on the number of threads that can be created, determined by the resources that a thread needs to have allocated (if a process has 2GB of address space, and each thread as 512K of stack, that means a maximum of a few thousands threads per process).</li>
</ul>
<h3 id="Avoiding-thread-overhead-in-Java"><a href="#Avoiding-thread-overhead-in-Java" class="headerlink" title="Avoiding thread overhead in Java"></a>Avoiding thread overhead in Java</h3><ul>
<li>In applications such as servers that need to continually execute short, multithreaded tasks, the usual way to avoid the overhead of repeated thread creation is to create a thread pool. </li>
</ul>
<h1 id="Dinnig-Philosophers-problem"><a href="#Dinnig-Philosophers-problem" class="headerlink" title="Dinnig Philosophers problem"></a>Dinnig Philosophers problem</h1><ul>
<li>The problem was designed to <strong>illustrate the challenges of avoiding deadlock</strong>, a system state in which no progress is possible. To see that a proper solution to this problem is not obvious, consider a proposal in which each philosopher is instructed to behave as follows:</li>
</ul>
<ol>
<li>think until the left fork is available; when it is, pick it up;</li>
<li>think until the right fork is available; when it is, pick it up;</li>
<li>when both forks are held, eat for a fixed amount of time;</li>
<li>then, put the right fork down;</li>
<li>then, put the left fork down;</li>
<li>repeat from the beginning.</li>
</ol>
<ul>
<li>This attempted solution fails because it allows the system to reach a deadlock state, in which no progress is possible. This is a state in which each philosopher has picked up the fork to the left, and is waiting for the fork to the right to become available, vice versa. With the given instructions, this state can be reached, and when it is reached, the philosophers will eternally wait for each other to release a fork</li>
<li><strong>Resource starvation</strong> might also occur independently of deadlock if a particular philosopher is unable to acquire both forks because of a timing problem. For example, there might be a rule that the philosophers put down a fork after waiting ten minutes for the other fork to become available and wait a further ten minutes before making their next attempt.</li>
<li>This scheme eliminates the possibility of deadlock (the system can always advance to a different state) but still <strong>suffers from the problem of livelock</strong>. If all five philosophers appear in the dining room <strong>at exactly the same time</strong> and each picks up the left fork at the same time the philosophers will wait ten minutes until they all put their forks down and then wait a further ten minutes before they all pick them up again.<h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions"></a>Solutions</h2><h3 id="Arbitrator-solution"><a href="#Arbitrator-solution" class="headerlink" title="Arbitrator solution"></a>Arbitrator solution</h3>Another approach is to guarantee that a philosopher can only pick up both forks or none by introducing an arbitrator, e.g., a waiter. In order to pick up the forks, a philosopher must ask permission of the waiter. The waiter gives permission to only one philosopher at a time until the philosopher has picked up both of their forks. Putting down a fork is always allowed. The waiter can be implemented as a mutex. In addition to introducing a new central entity (the waiter), this approach can result in reduced parallelism. if a philosopher is eating and one of their neighbors is requesting the forks, all other philosophers must wait until this request has been fulfilled even if forks for them are still available.</li>
</ul>
<h1 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h1><h2 id="What-is-the-difference-between-poll-and-remove-method-of-Queue-interface-answer"><a href="#What-is-the-difference-between-poll-and-remove-method-of-Queue-interface-answer" class="headerlink" title="What is the difference between poll() and remove() method of Queue interface? (answer)"></a>What is the difference between poll() and remove() method of Queue interface? (answer)</h2><ul>
<li>Though both poll() and remove() method from Queue is used to remove the object and returns the head of the queue, there is a subtle difference between them. If Queue is empty() then a call to <strong>remove() method will throw Exception</strong>, while a call to <strong>poll() method returns null</strong>.</li>
</ul>
<h2 id="What-is-the-difference-between-fail-fast-and-fail-safe-Iterators"><a href="#What-is-the-difference-between-fail-fast-and-fail-safe-Iterators" class="headerlink" title="What is the difference between fail-fast and fail-safe Iterators?"></a>What is the difference between fail-fast and fail-safe Iterators?</h2><ul>
<li>Fail-fast Iterators <strong>throws ConcurrentModificationException</strong> when one Thread is iterating over collection object and <strong>other</strong> thread <strong>structurally modify</strong> Collection either by adding, removing or modifying objects on underlying collection. They are called fail-fast because they try to immediately throw Exception when they encounter failure. On the other hand <strong>fail-safe Iterators</strong> works on <strong>copy of collection instead of original collection</strong></li>
</ul>
<h2 id="To-remove-entry-from-collection"><a href="#To-remove-entry-from-collection" class="headerlink" title="To remove entry from collection"></a>To remove entry from collection</h2><ul>
<li>you need to use Iterator’s remove() method. This method removes current element from Iterator’s perspective. If you use Collection’s or List’s remove() method during iteration then your code will throw <strong>ConcurrentModificationException</strong>. That’s why it’s advised <strong>to use Iterator remove() method to remove objects from Collection</strong>.</li>
</ul>
<h2 id="What-is-the-difference-between-Synchronized-Collection-and-Concurrent-Collection"><a href="#What-is-the-difference-between-Synchronized-Collection-and-Concurrent-Collection" class="headerlink" title="What is the difference between Synchronized Collection and Concurrent Collection?"></a>What is the difference between Synchronized Collection and Concurrent Collection?</h2><ul>
<li>One Significant difference is that <strong>Concurrent Collections has better performance than synchronized Collection ** because they **lock only a portion of Map</strong> to achieve concurrency and Synchronization.</li>
</ul>
<h2 id="When-do-you-use-ConcurrentHashMap-in-Java"><a href="#When-do-you-use-ConcurrentHashMap-in-Java" class="headerlink" title="When do you use ConcurrentHashMap in Java"></a>When do you use ConcurrentHashMap in Java</h2><ul>
<li>ConcurrentHashMap is better suited for situation where you have <strong>multiple readers</strong> and <strong>one<br>Writer or fewer writers</strong> since Map gets locked only during the write operation. <strong>If you have an equal number of reader and writer</strong> than ConcurrentHashMap will perform in the line of <strong>Hashtable or synchronized HashMap</strong>.</li>
</ul>
<h2 id="Sorting-collections"><a href="#Sorting-collections" class="headerlink" title="Sorting collections"></a>Sorting collections</h2><ul>
<li>Sorting is implemented using Comparable and Comparator in Java and when you call Collections.sort() it gets sorted based on the <strong>natural order specified in compareTo()</strong> method while Collections.sort(Comparator) will sort objects based on <strong>compare() method of Comparator</strong>. </li>
</ul>
<h2 id="Hashmap-vs-Hasset"><a href="#Hashmap-vs-Hasset" class="headerlink" title="Hashmap vs Hasset"></a>Hashmap vs Hasset</h2><ul>
<li>HashSet implements java.util.Set interface and that’s why <strong>only contains unique elements</strong>, while <strong>HashMap allows duplicate values</strong>.  In fact, HashSet is actually implemented on top of java.util.HashMap.</li>
</ul>
<h2 id="What-is-NavigableMap-in-Java"><a href="#What-is-NavigableMap-in-Java" class="headerlink" title="What is NavigableMap in Java"></a>What is NavigableMap in Java</h2><ul>
<li>NavigableMap Map was added in Java 1.6, it adds navigation capability to Map data structure. It provides methods like lowerKey() to get keys which is less than specified key, floorKey() to return keys which is less than or equal to specified key, ceilingKey() to get keys which is greater than or equal to specified key and higherKey() to return keys which is greater specified key from a Map. It also provide similar methods to get entries e.g. lowerEntry(), floorEntry(), ceilingEntry() and higherEntry(). Apart from navigation methods, it also provides utilities to create sub-Map e.g. creating a Map from entries of an exsiting Map like tailMap, headMap and subMap. headMap() method returns a NavigableMap whose keys are less than specified, tailMap() returns a NavigableMap whose keys are greater than the specified and subMap() gives a NavigableMap between a range, specified by toKey to fromKey</li>
</ul>
<h2 id="Array-vs-ArrayList"><a href="#Array-vs-ArrayList" class="headerlink" title="Array vs ArrayList"></a>Array vs ArrayList</h2><ul>
<li>Array is fixed length data structure, once created you can not change it’s length. On the other hand, <strong>ArrayList is dynamic</strong>, it automatically allocate a new array and copies content of old array, when it resize.</li>
<li>Another reason of using ArrayList over Array is <strong>support of Generics</strong>.</li>
</ul>
<h2 id="Can-we-replace-Hashtable-with-ConcurrentHashMap"><a href="#Can-we-replace-Hashtable-with-ConcurrentHashMap" class="headerlink" title="Can we replace Hashtable with ConcurrentHashMap?"></a>Can we replace Hashtable with ConcurrentHashMap?</h2><ul>
<li>Since <strong>Hashtable locks whole Map instead of a portion of Map</strong>, <strong>compound operations like if(Hashtable.get(key) == null) put(key, value) works in Hashtable</strong> but <strong>not in concurrentHashMap</strong>. instead of this <strong>use putIfAbsent() method of ConcurrentHashMap</strong></li>
</ul>
<h2 id="What-is-CopyOnWriteArrayList-how-it-is-different-than-ArrayList-and-Vector"><a href="#What-is-CopyOnWriteArrayList-how-it-is-different-than-ArrayList-and-Vector" class="headerlink" title="What is CopyOnWriteArrayList, how it is different than ArrayList and Vector"></a>What is CopyOnWriteArrayList, how it is different than ArrayList and Vector</h2><ul>
<li>CopyOnWriteArrayList is new List implementation introduced in Java 1.5 which provides better concurrent access than Synchronized List. better concurrency is achieved by Copying ArrayList over each write and replace with original instead of locking. Also CopyOnWriteArrayList doesn’t throw any ConcurrentModification Exception. Its different than ArrayList because its thread-safe and ArrayList is not thread-safe and it’s different than Vector in terms of Concurrency. CopyOnWriteArrayList provides better Concurrency by reducing contention among readers and writers.</li>
</ul>
<h2 id="Why-ListIterator-has-added-method-but-Iterator-doesn’t-or-Why-to-add-method-is-declared-in-ListIterator-and-not-on-Iterator-answer"><a href="#Why-ListIterator-has-added-method-but-Iterator-doesn’t-or-Why-to-add-method-is-declared-in-ListIterator-and-not-on-Iterator-answer" class="headerlink" title="Why ListIterator has added() method but Iterator doesn’t or Why to add() method is declared in ListIterator and not on Iterator. (answer)"></a>Why ListIterator has added() method but Iterator doesn’t or Why to add() method is declared in ListIterator and not on Iterator. (answer)</h2><ul>
<li>ListIterator has added() method because of its ability to traverse or iterate in both direction of the collection. it maintains two pointers in terms of previous and next call and in a position to add a new element without affecting current iteration.</li>
</ul>
<h2 id="What-is-BlockingQueue-how-it-is-different-than-other-collection-classes-answer"><a href="#What-is-BlockingQueue-how-it-is-different-than-other-collection-classes-answer" class="headerlink" title="What is BlockingQueue, how it is different than other collection classes? (answer)"></a>What is BlockingQueue, how it is different than other collection classes? (answer)</h2><ul>
<li>BlockingQueue is a Queue implementation available in java.util.concurrent package. It’s one of the concurrent Collection class added on Java 1.5, main difference between BlockingQueue and other collection classes is that apart from storage, <strong>it also provides flow control</strong>. It can be used in inter-thread communication and also provides <strong>built-in thread-safety by using happens-before guarantee</strong>. You can use BlockingQueue to solve Producer Consumer problem, which is what is needed in most of concurrent applications.</li>
</ul>
<h2 id="You-have-thread-T1-T2-and-T3-how-will-you-ensure-that-thread-T2-run-after-T1-and-thread-T3-run-after-T2"><a href="#You-have-thread-T1-T2-and-T3-how-will-you-ensure-that-thread-T2-run-after-T1-and-thread-T3-run-after-T2" class="headerlink" title="You have thread T1, T2 and T3, how will you ensure that thread T2 run after T1 and thread T3 run after T2"></a>You have thread T1, T2 and T3, how will you ensure that thread T2 run after T1 and thread T3 run after T2</h2><ul>
<li>To use <strong>join</strong> method.</li>
</ul>
<h1 id="Happen-before"><a href="#Happen-before" class="headerlink" title="Happen before"></a>Happen before</h1><ul>
<li>In computer science, the happened-before relation (denoted: → {\displaystyle \to ;} \to ;) is a relation between the result of two events, such that if one event should happen before another event, the result must reflect that, even if those events are in reality executed out of order (usually to optimize program flow). </li>
<li>In Java specifically, a happens-before relationship is a guarantee that <strong>memory written to by statement A is visible to statement B</strong>, that is, that statement <strong>A completes its write before</strong> statement B <strong>starts its read</strong></li>
</ul>
<h1 id="Concurrent-framework"><a href="#Concurrent-framework" class="headerlink" title="Concurrent framework"></a>Concurrent framework</h1><ul>
<li>The advantage of using Callable over Runnable is that <strong>Callable</strong> can explicitly <strong>return a value</strong>.</li>
<li>Executors are a big step forward compared to plain old threads because <strong>executors ease the management of concurrent tasks</strong>. </li>
<li>Some types of algorithms exist that require tasks to create subtasks and communicate with each other to complete. Those are the <strong>“divide and conquer” algorithms</strong>, which are also referred to as <strong>“map and reduce,”</strong> in reference to the eponymous functions in functional languages.</li>
<li>The fork/join framework added to the java.util.concurrent package in Java SE 7 through Doug Lea’s efforts fills that gap. The Java SE 5 and Java SE 6 versions of java.util.concurrent helped in <strong>dealing with concurrency</strong>, and the additions in Java SE 7 help with <strong>parallelism</strong>.</li>
<li>First and foremost, fork/join tasks should operate as <strong>“pure” in-memory algorithms in which no I/O operations</strong> come into play. Also, communication between tasks through shared state should be avoided as much as possible, because that implies that locking might have to be performed.</li>
<li>The core addition is a new <strong>ForkJoinPool executor</strong> that is dedicated to running instances implementing ForkJoinTask. ForkJoinTask objects <strong>support the creation of subtasks plus waiting for the subtasks to complete</strong>. With those clear semantics, the <strong>executor is able to dispatch tasks</strong> among its <strong>internal threads pool</strong> by <strong>“stealing” jobs when a task is waiting</strong> for another task to complete and <strong>there are pending tasks to be run</strong>.</li>
<li>ForkJoinTask objects feature two specific methods:<ul>
<li>The fork() method allows a ForkJoinTask to be planned for asynchronous execution. This allows a new ForkJoinTask to be launched from an existing one.</li>
<li>In turn, the join() method allows a ForkJoinTask to wait for the completion of another one.</li>
</ul>
</li>
<li>There are two types of ForkJoinTask specializations:<ul>
<li>Instances of <strong>RecursiveAction</strong> represent executions that <strong>do not yield a return value</strong>.</li>
<li>In contrast, instances of <strong>RecursiveTask yield return values</strong>.
In general, RecursiveTask is preferred because most divide-and-conquer algorithms return a value from a computation over a data set. </li>
</ul>
</li>
<li>The fork and join principle consists of two steps which are performed recursively. These two steps are the fork step and the join step. </li>
<li>A task that uses the fork and join principle can fork (split) itself into smaller subtasks which can be executed concurrently. This is illustrated in the diagram below: </li>
<li>By splitting itself up into subtasks, each <strong>subtask can be executed in parallel by different CPUs</strong>, or <strong>different threads on the same CPU</strong>. </li>
<li><strong>The limit for when</strong> it makes sense to fork a task into subtasks <strong>is also called a threshold</strong>. It is up to each task to decide on a sensible threshold. It depends very much on the kind of work being done.</li>
<li>Once the subtasks have finished executing, the task may <strong>join (merge) all the results into one result</strong>.</li>
<li>Of course, not all types of tasks may return a result. If the tasks do not return a result then a task just waits for its subtasks to complete. No result merging takes place then. </li>
<li>The <strong>ForkJoinPool is a special thread pool</strong> which is designed to work well with fork-and-join task splitting. The ForkJoinPool located in the java.util.concurrent package, so the full class name is java.util.concurrent.ForkJoinPool. </li>
<li>You create a ForkJoinPool using its constructor. As a parameter to the ForkJoinPool constructor you <strong>pass the indicated level of parallelism</strong> you desire. </li>
<li>The parallelism level <strong>indicates how many threads or CPUs</strong> you want to work concurrently on on tasks passed to the ForkJoinPool.</li>
<li>You submit tasks to a ForkJoinPool <strong>similarly to how you submit tasks to an ExecutorService</strong>. You can submit two types of tasks. A task that <strong>does not return any result (an “action”</strong>), and a <strong>task which does return</strong> a result (a “task”).</li>
</ul>
<h2 id="Fork-Join-framework-details"><a href="#Fork-Join-framework-details" class="headerlink" title="Fork/Join framework details"></a>Fork/Join framework details</h2><ul>
<li><p>ForkJoinPool is consists of ForkJoinTask array and ForkJoinWorkerThread array.  </p>
<ul>
<li><p>ForkJoinTask array contains tasks submitted to ForkJoinPool</p>
</li>
<li><p>ForkJoinWorkerThread array in charge of executing those tasks</p>
</li>
<li><p>When you call fork method on ForkJoinTask, program will call “pushTask” asynchronously of ForkJoinWorkerThread, and then return result right away.</p>
</li>
<li><p>“pushTask” will put current task into ForkJoinTask array queue, then execute “signalWork()” of ForkJoinPool to create a new thread to execute task.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">pushTask</span><span class="params">(ForkJoinTask t)</span> </span>&#123;</span><br><span class="line">       ForkJoinTask[] q; <span class="keyword">int</span> s, m;</span><br><span class="line">       <span class="keyword">if</span> ((q = queue) != <span class="keyword">null</span>) &#123;    <span class="comment">// ignore if queue removed</span></span><br><span class="line">           <span class="keyword">long</span> u = (((s = queueTop) &amp; (m = q.length - <span class="number">1</span>)) &lt;&lt; ASHIFT) + ABASE;</span><br><span class="line">           UNSAFE.putOrderedObject(q, u, t);</span><br><span class="line">           queueTop = s + <span class="number">1</span>;         <span class="comment">// or use putOrderedInt</span></span><br><span class="line">           <span class="keyword">if</span> ((s -= queueBase) &lt;= <span class="number">2</span>)</span><br><span class="line">               pool.signalWork();</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (s == m)</span><br><span class="line">               growQueue();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>“join” method main functionality is blocking current thread and wait for resutls.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">join</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (doJoin() != NORMAL)</span><br><span class="line">          <span class="keyword">return</span> reportResult();</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">          <span class="keyword">return</span> getRawResult();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> V <span class="title">reportResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> s; Throwable ex;</span><br><span class="line">		<span class="keyword">if</span> ((s = status) == CANCELLED)</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> CancellationException();</span><br><span class="line"><span class="keyword">if</span> (s == EXCEPTIONAL &amp;&amp; (ex = getThrowableException()) != <span class="keyword">null</span>)</span><br><span class="line">			UNSAFE.throwException(ex);</span><br><span class="line">		<span class="keyword">return</span> getRawResult();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>When do call doJoin(), you can get status of curent thread. There are 4 status:<ul>
<li>NORMAL: completed</li>
<li>CANCELLED</li>
<li>SIGNAL</li>
<li>EXCEPTIONAL</li>
</ul>
</li>
<li>The method of doJoin()<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">doJoin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       Thread t; ForkJoinWorkerThread w; <span class="keyword">int</span> s; <span class="keyword">boolean</span> completed;</span><br><span class="line">       <span class="keyword">if</span> ((t = Thread.currentThread()) <span class="keyword">instanceof</span> ForkJoinWorkerThread) &#123;</span><br><span class="line">           <span class="keyword">if</span> ((s = status) &lt; <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> s;</span><br><span class="line">           <span class="keyword">if</span> ((w = (ForkJoinWorkerThread)t).unpushTask(<span class="keyword">this</span>)) &#123;</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   completed = exec();</span><br><span class="line">               &#125; <span class="keyword">catch</span> (Throwable rex) &#123;</span><br><span class="line">                   <span class="keyword">return</span> setExceptionalCompletion(rex);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (completed)</span><br><span class="line">                   <span class="keyword">return</span> setCompletion(NORMAL);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> w.joinTask(<span class="keyword">this</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">           <span class="keyword">return</span> externalAwaitDone();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="newTaskFor"><a href="#newTaskFor" class="headerlink" title="newTaskFor"></a>newTaskFor</h2><p>If a SocketUsingTask is cancelled through its Future, the socket is closed and the</p>
<p>As of <strong>Java 6, ExecutorService implementations can override newTaskFor</strong> in AbstractExecutorService <strong>to control instantiation of the Future corresponding to a submitted Callable or Runnable</strong>. The default implementation just creates a new FutureTask, as shown in Listing 6.12. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">RunnableFuture&lt;T&gt; <span class="title">newTaskFor</span><span class="params">(Callable&lt;T&gt; task)</span> </span>&#123; </span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> FutureTask&lt;T&gt;(task); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Listing 6.12. Default implementation of newTaskFor in ThreadPoolExecutor.</p>
<h2 id="Thread-shutdown"><a href="#Thread-shutdown" class="headerlink" title="Thread shutdown"></a>Thread shutdown</h2><ul>
<li>Sensible encapsulation practices dictate that you should not manipulate a thread—interrupt it, modify its priority, etc.—unless you own it. The thread API has no formal concept of thread ownership: a thread is represented with a Thread object that can be freely shared like any other object. However, it makes sense <strong>to think of a thread as having an owner</strong>, and this <strong>is usually the class that created the thread</strong>. So <strong>a thread pool owns its worker threads</strong>, and if those threads need to be interrupted, the thread pool should take care of it.</li>
<li>As with any other encapsulated object, <strong>thread ownership is not transitive</strong>: the application may own the service and the service may own the worker threads, but <strong>the application doesn’t own the worker threads and therefore should not attempt to stop them directly</strong>. Instead, the service should provide lifecycle methods for shutting itself down that also shut down the owned threads; then the application can shut down the service, and the service can shut down the threads. Executor- Service provides the shutdown and shutdownNow methods; other thread-owning services should provide a similar shutdown mechanism.</li>
</ul>
<h2 id="Log-service-implemented-by-blocking-queue"><a href="#Log-service-implemented-by-blocking-queue" class="headerlink" title="Log service implemented by blocking queue"></a>Log service implemented by blocking queue</h2><ul>
<li>If you are logging multiple lines as part of a single log message, you may need to use additional client-side locking to prevent undesirable interleaving of output from multiple threads. If two threads logged multiline stack traces to the same stream with one println call per line, the results would be interleaved unpredictably, and could easily look like one large but meaningless stack trace.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogWriter</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;String&gt; queue; <span class="keyword">private</span> <span class="keyword">final</span> LoggerThread logger;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LogWriter</span><span class="params">(Writer writer)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.queue = <span class="keyword">new</span> LinkedBlockingQueue&lt;String&gt;(CAPACITY); <span class="keyword">this</span>.logger = <span class="keyword">new</span> LoggerThread(writer);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123; logger.start(); &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">(String msg)</span> <span class="keyword">throws</span> InterruptedException </span>&#123; queue.put(msg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">LoggerThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123; <span class="keyword">private</span> <span class="keyword">final</span> PrintWriter writer;</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>)</span><br><span class="line">writer.println(queue.take());</span><br><span class="line">&#125; <span class="keyword">catch</span>(InterruptedException ignored) &#123; &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    writer.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Stop-logging"><a href="#Stop-logging" class="headerlink" title="Stop logging"></a>Stop logging</h3><ul>
<li>However, this approach has race conditions that make it unreliable. The implementation of log is a check-then-act sequence: producers could observe that the service has not yet been shut down but still queue messages after the shutdown, again with the risk that the producer might get blocked in log and never become unblocked. There are tricks that reduce the likelihood of this (like having the consumer wait several seconds before declaring the queue drained), but these do not change the fundamental problem, merely the likelihood that it will cause a failure.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">(String msg)</span> <span class="keyword">throws</span> InterruptedException </span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (!shutdownRequested)</span><br><span class="line">        queue.put(msg);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"logger is shut down"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>The way to provide reliable shutdown for LogWriter is to fix the race con- dition, which means making the submission of a new log message atomic. But we don’t want to hold a lock while trying to enqueue the message, since put could block. Instead, we can atomically check for shutdown and conditionally increment a counter to “reserve” the right to submit a message, as shown in Log- Service in Listing 7.15.</li>
</ul>
<h3 id="Delegate-shutdown-to-high-level-service"><a href="#Delegate-shutdown-to-high-level-service" class="headerlink" title="Delegate shutdown to high level service"></a>Delegate shutdown to high level service</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogService</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ExecutorService exec = newSingleThreadExecutor(); ...</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123; <span class="keyword">try</span> &#123;</span><br><span class="line">exec.shutdown();</span><br><span class="line">exec.awaitTermination(TIMEOUT, UNIT);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            writer.close();</span><br><span class="line">&#125; &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">(String msg)</span> </span>&#123; <span class="keyword">try</span> &#123;</span><br><span class="line"> &#125; &#125;</span><br><span class="line">exec.execute(<span class="keyword">new</span> WriteTask(msg));</span><br><span class="line">&#125; <span class="keyword">catch</span> (RejectedExecutionException ignored) &#123; &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>It can even delegate to one shot Executor, OneShotExecutionService.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicBoolean;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by todzhang on 2017/1/30.</span></span><br><span class="line"><span class="comment"> * If a method needs to process a batch of tasks and does not return</span></span><br><span class="line"><span class="comment"> * until all the tasks are finished, it can simplify service lifecycle management</span></span><br><span class="line"><span class="comment"> * by using a private Executor whose lifetime is bounded by that method.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The checkMail method in Listing checks for new mail in parallel</span></span><br><span class="line"><span class="comment"> * on a number of hosts. It creates a private executor and submits</span></span><br><span class="line"><span class="comment"> * a task for each host: it then shuts down the executor and waits</span></span><br><span class="line"><span class="comment"> * for termination, which occurs when all</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OneShotExecutionService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">checkMail</span><span class="params">(Set&lt;String&gt; hosts, <span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        ExecutorService exec= Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">final</span> AtomicBoolean hasNewMail=<span class="keyword">new</span> AtomicBoolean(<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">final</span> String host : hosts</span><br><span class="line">                    ) &#123;</span><br><span class="line">                exec.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">if</span> (checkMail(host)) &#123;</span><br><span class="line">                            hasNewMail.set(<span class="keyword">true</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span>&#123;</span><br><span class="line">            exec.shutdown();</span><br><span class="line">            exec.awaitTermination(timeout,unit);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hasNewMail.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">checkMail</span><span class="params">(String host)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>When an ExecutorService is shut down abruptly with shutdownNow, it attempts to cancel the tasks currently in progress and returns a list of tasks that were sub- mitted but never started so that they can be logged or saved for later processing. Detailed logic can be found at <a href="https://github.com/CloudsDocker/algo/blob/master/algoWS/src/main/java/com/todzhang/CancelledTaskTrackingExecutor.java" target="_blank" rel="noopener">CancelledTaskTrackingExecutor.java</a></p>
</li>
<li><p>The leading cause of premature thread death is RuntimeException.</p>
</li>
</ul>
<h1 id="JVM-shutdown"><a href="#JVM-shutdown" class="headerlink" title="JVM shutdown"></a>JVM shutdown</h1><ul>
<li>The JVM can shut down in either an <em>orderly</em> or <em>abrupt</em> manner. An orderly shut- down is initiated when the last “normal” (nondaemon) thread terminates, some- one calls System.exit, or by other platform-specific means (such as sending a SIGINT or hitting Ctrl-C). While this is the standard and preferred way for the JVM to shut down, it can also be shut down abruptly by calling <strong>Runtime.halt or by killing the JVM process</strong> through the operating system (such as sending a SIGKILL).</li>
</ul>
<h2 id="Shutdown-hooks"><a href="#Shutdown-hooks" class="headerlink" title="Shutdown hooks"></a>Shutdown hooks</h2><ul>
<li>In an orderly shutdown, the JVM first starts all registered shutdown hooks. Shutdown hooks are unstarted threads that are registered with <strong>Runtime.addShutdownHook</strong>. The JVM makes no guarantees on the order in which shutdown hooks are started. If any application threads (daemon or nondaemon) are still running at shutdown time, they continue to run concurrently with the shutdown process. </li>
<li>When all shutdown hooks have completed, the JVM may choose <strong>to run finalizers if runFinalizersOnExit is true</strong>, </li>
<li>and then halts. </li>
<li>The JVM makes no attempt to stop or interrupt any application threads that are still running at shutdown time; they are abruptly terminated when the JVM eventually halts. If the shutdown hooks or finalizers don’t complete, then the orderly shutdown process “hangs” and the JVM must be shut down abruptly. In an abrupt shutdown, the JVM is not required to do anything other than halt the JVM; shutdown hooks will not run.</li>
<li>Shutdown <strong>hooks should be thread-safe</strong>: they must <strong>use synchronization when accessing shared data</strong> and should be careful to avoid deadlock, just like any other concurrent code. Further, they should not make assumptions about the state of the application (such as whether other services have shut down already or all normal threads have completed) or about why the JVM is shutting down, and <strong>must therefore be coded extremely defensively</strong>. </li>
<li>Finally, they <strong>should exit as quickly as possible</strong>, since their existence delays JVM termination at a time when the user may be expecting the JVM to terminate quickly.</li>
<li>Shutdown hooks can be used for service or <strong>application cleanu</strong>p, such as deleting temporary files or cleaning up resources that are not automatically cleaned up by the OS. Listing 7.26 shows how LogService in Listing 7.16 could register a shutdown hook from its start method to ensure the log file is closed on exit.</li>
<li>Because shutdown hooks all run concurrently, closing the log file could cause trouble for other shutdown hooks who want to use the logger. To avoid this problem, shutdown hooks should not rely on services that can be shut down by the application or other shutdown hooks. <strong>One way to accomplish this is to use a single shutdown hook for all services</strong>, rather than one for each service, and have it call a series of shutdown actions. This ensures that shutdown actions execute sequentially in a single thread, thus avoiding the possibility of race conditions or deadlock between shutdown actions. This technique can be used whether or not you use shutdown hooks; <strong>executing shutdown actions sequentially rather than concurrently</strong> eliminates many potential sources of failure. <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123; </span><br><span class="line">  Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> Thread() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">try</span> &#123; LogService.<span class="keyword">this</span>.stop(); &#125;</span><br><span class="line">          <span class="keyword">catch</span> (InterruptedException ignored) &#123;&#125;</span><br><span class="line">&#125; &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="Daemon-thread"><a href="#Daemon-thread" class="headerlink" title="Daemon thread"></a>Daemon thread</h3><ul>
<li>Threads are divided into two types: <strong>normal threads and daemon threads</strong>. When the <strong>JVM starts up</strong>, all the threads it creates (such as garbage collector and other housekeeping threads) <strong>are daemon threads</strong>, except the main thread. When a new thread is created, it inherits the daemon status of the thread that created it, so by default any threads created by the main thread are also normal threads. </li>
<li>Normal threads and daemon threads <strong>differ only in what happens when they exit</strong>. When a thread exits, the JVM performs an inventory of running threads, and <strong>if the only threads that are left are daemon threads, it initiates an orderly shutdown</strong>. When the JVM halts, <strong>any remaining daemon threads are abandoned— finally blocks are not executed</strong>, stacks are not unwound—the JVM just exits.</li>
<li><strong>Daemon threads should be used sparingly</strong>—few processing activities can be safely abandoned at any time with no cleanup. In particular, it is <strong>dangerous to use daemon threads for tasks that might perform any sort of I/O</strong>. Daemon threads are best saved for “housekeeping” tasks, such as a background thread that periodically removes expired entries from an in-memory cache.<br>Daemon threads are not a good substitute for properly managing the life- cycle of services within an application.</li>
</ul>
<h3 id="Finalizer"><a href="#Finalizer" class="headerlink" title="Finalizer"></a>Finalizer</h3><ul>
<li>Finalizers offer <strong>no guarantees</strong> on <strong>when or even if they run</strong>, and they impose a significant performance cost on objects with nontrivial finalizers. They are also extremely difficult to write correctly.9 In most cases, the combination of finally blocks and explicit close methods does a better job of resource management than finalizers; the sole exception is when you need to manage objects that hold resources acquired by native methods.</li>
<li><strong>Java does not provide a preemptive mechanism</strong> for cancelling activities or terminating threads. Instead, <strong>it provides a cooperative interruption mechanism</strong> that can be used to facilitate cancellation, but it is up to you to construct protocols for cancellation and use them consistently. Using <strong>FutureTask and the Executor framework simplifies building cancellable tasks and services</strong>.</li>
</ul>
<h1 id="Thread-Pool"><a href="#Thread-Pool" class="headerlink" title="Thread Pool"></a>Thread Pool</h1><ul>
<li>Thread pools work best when tasks are homogeneous and independent. Mix- ing long-running and short-running tasks risks “clogging” the pool unless it is very large; submitting tasks that depend on other tasks risks deadlock unless the pool is unbounded. Fortunately, requests in typical network-based server applications—web servers, mail servers, file servers—usually meet these guide- lines.</li>
<li>Some tasks have characteristics that require or preclude a specific exe- cution policy. Tasks that depend on other tasks require that the thread pool be large enough that tasks are never queued or rejected; tasks that exploit thread confinement require sequential execution. Document these requirements so that future maintainers do not undermine safety or live- ness by substituting an incompatible execution policy.</li>
<li>In a single-threaded executor, a task that submits another task to the same executor and waits for its result <strong>will always deadlock</strong>.</li>
<li>The same thing can happen in larger thread pools if all threads are executing tasks that are blocked waiting for other tasks still on the work queue. This is called <strong>thread starvation deadlock</strong>, and can occur whenever a pool task initiates an unbounded blocking wait for some resource or condition that can succeed only through the action of another pool task, such as waiting for the return value or side effect of another task, unless you can guarantee that the pool is large enough.</li>
</ul>
<blockquote>
<p>Whenever you submit to an Executor tasks that are not independent, be aware of the possibility of thread starvation deadlock, and document any pool sizing or configuration constraints in the code or configuration file where the Executor is configured.</p>
</blockquote>
<ul>
<li>Task that deadlocks in a single-threaded Executor. Don’t do this.<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;String&gt; header,footer;</span><br><span class="line">            header=exec.submit(<span class="keyword">new</span> LoadFileTask(<span class="string">"header.html"</span>));</span><br><span class="line">            footer=exec.submit(<span class="keyword">new</span> LoadFileTask(<span class="string">"footer.html"</span>));</span><br><span class="line">            String body=renderBody();</span><br><span class="line">            <span class="keyword">return</span> header.get()+body+footer.get();</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="Long-running-tasks"><a href="#Long-running-tasks" class="headerlink" title="Long running tasks"></a>Long running tasks</h1><ul>
<li>Thread pools can have responsiveness problems if tasks can block for extended periods of time, even if deadlock is not a possibility. A thread pool can become clogged with long-running tasks, increasing the service time even for short tasks. If the pool size is too small relative to the expected steady-state number of long- running tasks, eventually all the pool threads will be running long-running tasks and responsiveness will suffer.</li>
<li><strong>One technique that can mitigate the ill effects</strong> of long-running tasks is for tasks <strong>to use timed resource waits instead of unbounded waits</strong>. Most blocking methods in the plaform libraries come in both untimed and timed versions, such as Thread.join, BlockingQueue.put, CountDownLatch.await, and Selector.sel- ect. If the wait times out, you can mark the task as failed and abort it or requeue it for execution later. This guarantees that each task eventually makes progress towards either successful or failed completion, freeing up threads for tasks that might complete more quickly. If a thread pool is frequently full of blocked tasks, this may also be a sign that the pool is too small.</li>
</ul>
<h1 id="size-the-thread-pool"><a href="#size-the-thread-pool" class="headerlink" title="size the thread pool"></a>size the thread pool</h1><ul>
<li>The ideal size for a thread pool depends on the types of tasks that will be submitted and the characteristics of the deployment system. <strong>Thread pool sizes should rarely be hard-coded</strong>; instead pool sizes should be provided by a <strong>configuration</strong> mechanism or computed dynamically by consulting <strong>Runtime.availableProcessors</strong>.</li>
<li>If you have different categories of tasks with very different behaviors, consider using multiple thread pools so each can be tuned according to its workload.</li>
<li>The optimal pool size for keeping the processors at the desired utilization is:<br>Nthreads=Ncpu∗Ucpu∗ (1+((W/C)<br>Ncpu: Number of CPU<br>Ucpu: target CPU utilization , 0&lt;Ucpu&lt;1<br>W/C: ratio of wait time to compute time</li>
</ul>
<h1 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h1><ul>
<li>ThreadPoolExecutor provides the base implementation for the executors re- turned by the newCachedThreadPool, newFixedThreadPool, and newScheduled- ThreadExecutor factories in Executors. </li>
<li>Implementation of ThreadPoolExecutor<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,<span class="keyword">int</span> maximumPoolSize, <span class="keyword">long</span> keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue,ThreadFactory threadFactory,RejectedExecutionHandler handler)</span></span>&#123;...&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ol>
<li>corePoolSize is the target size, the implementation attempts to maintain the pool at this size when there are no tasks to execute. and will not create more threads than this unless the work queue is full. When a ThreadPoolExecutor is initially created, the core threads are <strong>not started immediately</strong>, but instead as tasks are submitted. Unless you call <strong>prestartAllCoreThreads</strong></li>
<li>The maximum pool size is the upper bound on how many threads can be active at once.</li>
<li>A thread that has been idel for longer than the <strong>keep-alive time</strong> becomes a candidate for reaping and can be terminated if the current <strong>pool size exceed the core size</strong>.</li>
</ol>
<ul>
<li>By tuning the core pool size and keep-alive times, you can encourage the pool to reclaim resources used by otherwise idle threads, making them available for more useful work. (Like everything else, this is a tradeoff: reaping idle threads incurs additional latency due to thread creation if threads must later be created when demand increases.)</li>
<li>The <strong>newFixedThreadPool</strong> factory sets <strong>both the core pool size and the maxi- mum pool size</strong> to the <strong>requested pool size</strong>, creating the effect of <strong>infinite timeout</strong>; </li>
<li>the <strong>newCachedThreadPool</strong> factory sets the <strong>maximum pool size to Integer.MAX_VALUE</strong> and the <strong>core pool size to zero</strong> with a <strong>timeout of one minute</strong>, creating the effect of an <strong>infinitely expandable thread pool</strong> that will contract again when demand decreases. </li>
<li>Other combinations are possible using the explicit ThreadPool- Executor constructor.</li>
<li>ThreadPoolExecutor allows you to supply a BlockingQueue to hold tasks awaiting execution. There are <strong>three basic approaches to task queueing</strong>: <strong>un- bounded queue, bounded queue, and synchronous handoff</strong>. The choice of queue interacts with other configuration parameters such as pool size.</li>
<li>The default for <strong>newFixedThreadPool and newSingleThreadExecutor</strong> is to use an <strong>unbounded LinkedBlockingQueue</strong>. Tasks will queue up if all worker threads are busy, but the queue could grow without bound if the tasks keep arriving faster than they can be executed.</li>
<li>A more stable resource management strategy is to use a bounded queue, such as an ArrayBlockingQueue or a bounded LinkedBlockingQueue or Priority- BlockingQueue. Bounded queues help prevent resource exhaustion but introduce the question of what to do with new tasks when the queue is full. (There are a number of possible <strong>saturation policies</strong> for addressing this problem;</li>
<li>For very large or unbounded pools, you can also bypass queueing entirely and instead hand off tasks directly from producers to worker threads using a SynchronousQueue. <strong>A SynchronousQueue is not really a queue at all, but a mechanism for managing handoffs between threads</strong>. In order to put an element on a SynchronousQueue, another thread must already be waiting to accept the handoff. If no thread is waiting but the current pool size is less than the maximum, ThreadPoolExecutor creates a new thread; otherwise the task is rejected according to the saturation policy. <strong>Using a direct handoff is more efficient because the task can be handed right to the thread that will execute it, rather than first placing it on a queue and then having the worker thread fetch it from the queue</strong>. Synchron- ousQueue is a practical choice only if the pool is unbounded or if rejecting excess tasks is acceptable. The newCachedThreadPool factory uses a SynchronousQueue.</li>
<li>Using a FIFO queue like LinkedBlockingQueue or ArrayBlockingQueue causes tasks to be started in the order in which they arrived. For more con- trol over task execution order, you can use a PriorityBlockingQueue, which orders tasks according to priority. Priority can be defined by natural order (if<br>tasks implement Comparable) or by a Comparator.</li>
<li>The newCachedThreadPool factory is a good default choice for an Executor, providing better queuing performance than a fixed thread pool.5 A fixed size thread pool is a good choice when you need to limit the number of concurrent tasks for resource-management purposes, as in a server application that accepts requests from network clients and would otherwise be vulnerable to overload.</li>
<li>ith tasks that depend on other tasks, bounded thread pools or queues can cause thread starvation deadlock; instead, use an unbounded pool configuration like newCachedThreadPool.</li>
</ul>
<h1 id="Saturation-policies"><a href="#Saturation-policies" class="headerlink" title="Saturation policies"></a>Saturation policies</h1><ul>
<li>When a bounded work queue fills up, the <strong>saturation policy</strong> comes into play. The saturation policy for a ThreadPoolExecutor can be modified by calling setRejectedExecutionHandler. </li>
<li>Several implementations of RejectedExecutionHandler are provided, each implementing a different saturation policy: <strong>AbortPolicy, CallerRunsPolicy, DiscardPolicy, and DiscardOldestPolicy</strong>.</li>
<li>The default policy, <strong>abort</strong>, causes execute to throw the unchecked Rejected- ExecutionException; the caller can catch this exception and implement its own overflow handling as it sees fit. The <strong>discard</strong> policy silently discards the newly submitted task if it cannot be queued for execution; the <strong>discard-oldest</strong> policy discards the task that would otherwise be executed next and tries to resubmit the new task. (If the work queue is a priority queue, this discards the highest-priority element, so the combination of a discard-oldest saturation policy and a priority queue is not a good one.)</li>
<li>The <strong>caller-runs policy</strong> implements a form of throttling that neither discards tasks nor throws an exception, but instead tries to slow down the flow of new tasks by pushing some of the work back to the caller. It executes the newly submitted task not in a pool thread, but in the thread that calls execute. If we modified our WebServer example to use a bounded queue and the caller-runs policy, after all the pool threads were occupied and the work queue filled up the next task would be executed in the main thread during the call to execute. </li>
</ul>
<h1 id="Thread-Factory"><a href="#Thread-Factory" class="headerlink" title="Thread Factory"></a>Thread Factory</h1><ul>
<li><p>Whenever a thread pool needs to create a thread, it does so through a thread factory (see Listing 8.5). The default thread factory creates a new, nondaemon thread with no special configuration. Specifying a thread factory allows you to customize the configuration of pool threads. <strong>ThreadFactory has a single method, newThread, that is called whenever a thread pool needs to create a new thread</strong>.</p>
</li>
<li><p>There are a number of reasons to use a custom thread factory. You might want to specify an UncaughtExceptionHandler for pool threads, or instantiate an instance of a custom Thread class, such as one that performs debug logging.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ThreadFactory</span></span>&#123;</span><br><span class="line">    <span class="function">Thread <span class="title">newThread</span><span class="params">(Runnable r)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>BoundedExecutor.java is using semaphore and Executor for bounded executor service.</p>
</li>
<li><p>MyThreadFactory.java and MyAppThread.java are used to customize ThreadFactory, a customized Thread.</p>
</li>
<li><p>MyExtendedThreadPool.java implemented beforeExecute, afterExecute, etc method to add statistics, such as log and timing for each operations in the thread pool</p>
</li>
</ul>
<h2 id="Process-sequential-processing-to-parallel"><a href="#Process-sequential-processing-to-parallel" class="headerlink" title="Process sequential processing to parallel"></a>Process sequential processing to parallel</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processSequentially</span><span class="params">(List&lt;Element&gt; elements)</span> </span>&#123; <span class="keyword">for</span> (Element e : elements)</span><br><span class="line">process(e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processInParallel</span><span class="params">(Executor exec, List&lt;Element&gt; elements)</span> </span>&#123; <span class="keyword">for</span> (<span class="keyword">final</span> Element e : elements)</span><br><span class="line">exec.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; process(e); &#125;</span><br><span class="line">&#125;); &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>If you want to submit a set of tasks and wait for them all to complete, you can use <strong>ExecutorService.invokeAll</strong>; to retrieve the results as they become available, you can use a <strong>CompletionService</strong>.</li>
</ul>
<h1 id="Deadlocks"><a href="#Deadlocks" class="headerlink" title="Deadlocks"></a>Deadlocks</h1><ul>
<li>There is often a tension between safety and liveness. We use locking to ensure thread safety, but indiscriminate use of locking can cause <strong>lock-ordering deadlocks</strong>. Similarly, we <strong>use thread pools and semaphores to bound resource consumption</strong>, but failure to understand the activities being bounded can cause <strong>resource deadlocks</strong>. Java applications do not recover from deadlock, so it is worthwhile to ensure that your design precludes the conditions that could cause it. </li>
<li>When a thread holds a lock forever, other threads attempting to acquire that lock will block forever waiting. When thread A holds lock L and tries to acquire lock M, but at the same time thread B holds M and tries to acquire L, both threads will wait forever. This situation is the simplest case of deadlock (or deadly embrace),</li>
<li>Database systems are designed to detect and recover from deadlock. A trans- action may acquire many locks, and locks are held until the transaction commits. So it is quite possible, and in fact not uncommon, for two transactions to deadlock. Without intervention, they would wait forever (holding locks that are probably re- quired by other transactions as well). But the database server is not going to let this happen. When it detects that a set of transactions is deadlocked (which it does by searching the is-waiting-for graph for cycles), it picks a victim and aborts that transaction. This releases the locks held by the victim, allowing the other transactions to proceed. The application can then retry the aborted transaction, which may be able to complete now that any competing transactions have com- pleted.</li>
<li>A program will be free of lock-ordering deadlocks if all threads acquire the locks they need in a fixed global order.</li>
</ul>
<h2 id="To-break-deadlock-by-ensuring-lock-order"><a href="#To-break-deadlock-by-ensuring-lock-order" class="headerlink" title="To break deadlock by ensuring lock order"></a>To break deadlock by ensuring lock order</h2><ul>
<li><p>uses System.identityHashCode to induce a lock ordering. It involves a few extra lines of code, but eliminates the possibility of deadlock.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">identityHashCode</span><span class="params">(Object x)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>In the rare case that two objects have the same hash code, we must use an arbitrary means of ordering the lock acquisitions, and this reintroduces the pos- sibility of deadlock. To prevent inconsistent lock ordering in this case, a third “tie breaking” lock is used. By acquiring the tie-breaking lock before acquiring either Account lock, we ensure that only one thread at a time performs the risky task of acquiring two locks in an arbitrary order, eliminating the possibility of deadlock (so long as this mechanism is used consistently). If hash collisions were common, this technique might become a concurrency bottleneck (just as having a single, program-wide lock would), but because hash collisions with System.identity- HashCode are vanishingly infrequent, this technique provides that last bit of safety at little cost.</p>
</li>
<li><p>two locks are acquired by two threads in different orders, risking deadlock.</p>
</li>
<li><p>Calling a method <strong>with no locks held is called an open call</strong> [CPJ 2.4.1.3], and classes that rely on open calls are more well-behaved and composable than classes that make calls with locks held. Using open calls to avoid deadlock is analogous to using encapsulation to provide thread safety: while one can certainly construct a thread-safe program without any encapsulation, the thread safety analysis of a program that makes effective use of encapsulation is far easier than that of one that does not.</p>
</li>
</ul>
<h2 id="Avoiding-and-diagnosing-deadlocks"><a href="#Avoiding-and-diagnosing-deadlocks" class="headerlink" title="Avoiding and diagnosing deadlocks"></a>Avoiding and diagnosing deadlocks</h2><ul>
<li>A program that <strong>never acquires more than one lock at a time cannot experience lock-ordering deadlock</strong>. Of course, this is not always practical, but if you can get away with it, it’s a lot less work. If you must <strong>acquire multiple locks, lock ordering must be a part of your design</strong>: try to <strong>minimize the number of potential locking interactions</strong>, and follow and document a lock-ordering protocol for locks that may be acquired together.</li>
<li>In programs that use fine-grained locking, audit your code for deadlock free- dom using a two-part strategy: first, identify where multiple locks could be ac- quired (try to make this a small set), and then perform a global analysis of all such instances to ensure that lock ordering is consistent across your entire pro- gram. Using open calls wherever possible simplifies this analysis substantially. With no non-open calls, finding instances where multiple locks are acquired is fairly easy, either by code review or by automated bytecode or source code anal- ysis.</li>
</ul>
<h2 id="Timed-lock-attempts"><a href="#Timed-lock-attempts" class="headerlink" title="Timed lock attempts"></a>Timed lock attempts</h2><ul>
<li>Another technique for detecting and recovering from deadlocks is to use the timed tryLock feature of the explicit Lock classes (see Chapter 13) instead of intrinsic locking. Where intrinsic locks wait forever if they cannot acquire the lock, explicit locks let you specify a timeout after which tryLock returns failure.</li>
</ul>
<h2 id="JVM-Thread-dump-including-dead-lock"><a href="#JVM-Thread-dump-including-dead-lock" class="headerlink" title="JVM Thread dump including dead lock"></a>JVM Thread dump including dead lock</h2><ul>
<li>There are two threads trying to accquire two locks in different orders</li>
<li><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Java stack information <span class="keyword">for</span> the threads listed above: <span class="string">"ApplicationServerThread "</span>:</span><br><span class="line">at MumbleDBConnection.remove_statement</span><br><span class="line">- waiting to lock &lt;0x650f7f30&gt; (a MumbleDBConnection) at MumbleDBStatement.close</span><br><span class="line">- locked &lt;0x6024ffb0&gt; (a MumbleDBCallableStatement)</span><br><span class="line">...</span><br><span class="line"><span class="string">"ApplicationServerThread "</span>:</span><br><span class="line">at MumbleDBCallableStatement.sendBatch</span><br><span class="line">- waiting to lock &lt;0x6024ffb0&gt; (a MumbleDBCallableStatement) at MumbleDBConnection.commit</span><br><span class="line">- locked &lt;0x650f7f30&gt; (a MumbleDBConnection)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="Other-liveness-hazards"><a href="#Other-liveness-hazards" class="headerlink" title="Other liveness hazards"></a>Other liveness hazards</h1><ul>
<li>While deadlock is the most widely encountered liveness hazard, there are sev- eral other liveness hazards you may encounter in concurrent programs including starvation, missed signals, and livelock.</li>
</ul>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul>
<li><a href="http://www.javamex.com/tutorials/threads/thread_scheduling.shtml" target="_blank" rel="noopener">http://www.javamex.com/tutorials/threads/thread_scheduling.shtml</a></li>
<li><a href="http://www.javamex.com/tutorials/threads/priority.shtml" target="_blank" rel="noopener">http://www.javamex.com/tutorials/threads/priority.shtml</a></li>
<li><a href="http://www.javamex.com/tutorials/threads/how_threads_work.shtml" target="_blank" rel="noopener">http://www.javamex.com/tutorials/threads/how_threads_work.shtml</a></li>
<li><a href="http://www.javamex.com/tutorials/threads/thread_scheduling_2.shtml" target="_blank" rel="noopener">http://www.javamex.com/tutorials/threads/thread_scheduling_2.shtml</a></li>
<li><a href="http://www.javamex.com/tutorials/threads/yield.shtml" target="_blank" rel="noopener">http://www.javamex.com/tutorials/threads/yield.shtml</a></li>
<li><a href="http://javarevisited.blogspot.in/2012/07/countdownlatch-example-in-java.html" target="_blank" rel="noopener">http://javarevisited.blogspot.in/2012/07/countdownlatch-example-in-java.html</a></li>
<li><a href="http://javarevisited.blogspot.sg/2012/05/how-to-use-threadlocal-in-java-benefits.html" target="_blank" rel="noopener">http://javarevisited.blogspot.sg/2012/05/how-to-use-threadlocal-in-java-benefits.html</a></li>
<li><a href="http://javarevisited.blogspot.com/2012/03/simpledateformat-in-java-is-not-thread.html" target="_blank" rel="noopener">http://javarevisited.blogspot.com/2012/03/simpledateformat-in-java-is-not-thread.html</a></li>
<li><a href="http://javarevisited.blogspot.com/2012/05/counting-semaphore-example-in-java-5.html#ixzz4WRuTQFDF" target="_blank" rel="noopener">http://javarevisited.blogspot.com/2012/05/counting-semaphore-example-in-java-5.html#ixzz4WRuTQFDF</a></li>
<li><a href="http://javarevisited.blogspot.in/2012/02/what-is-race-condition-in.html" target="_blank" rel="noopener">http://javarevisited.blogspot.in/2012/02/what-is-race-condition-in.html</a>          </li>
<li><a href="http://javarevisited.blogspot.in/2011/05/wait-notify-and-notifyall-in-java.html" target="_blank" rel="noopener">http://javarevisited.blogspot.in/2011/05/wait-notify-and-notifyall-in-java.html</a></li>
<li><a href="http://javarevisited.blogspot.in/2015/07/how-to-use-wait-notify-and-notifyall-in.html" target="_blank" rel="noopener">http://javarevisited.blogspot.in/2015/07/how-to-use-wait-notify-and-notifyall-in.html</a></li>
<li><a href="http://javarevisited.blogspot.in/2012/07/cyclicbarrier-example-java-5-concurrency-tutorial.html" target="_blank" rel="noopener">http://javarevisited.blogspot.in/2012/07/cyclicbarrier-example-java-5-concurrency-tutorial.html</a></li>
<li><a href="http://javarevisited.blogspot.in/2011/09/fork-join-task-java7-tutorial.html" target="_blank" rel="noopener">http://javarevisited.blogspot.in/2011/09/fork-join-task-java7-tutorial.html</a></li>
<li><a href="https://en.wikipedia.org/wiki/Dining_philosophers_problem" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Dining_philosophers_problem</a></li>
<li><a href="http://javarevisited.blogspot.com/2011/11/collection-interview-questions-answers.html#ixzz4WTN72QPa" target="_blank" rel="noopener">http://javarevisited.blogspot.com/2011/11/collection-interview-questions-answers.html#ixzz4WTN72QPa</a></li>
<li><a href="http://javarevisited.blogspot.in/2011/11/collection-interview-questions-answers.html" target="_blank" rel="noopener">http://javarevisited.blogspot.in/2011/11/collection-interview-questions-answers.html</a></li>
<li><a href="http://www.oracle.com/technetwork/articles/java/fork-join-422606.html" target="_blank" rel="noopener">http://www.oracle.com/technetwork/articles/java/fork-join-422606.html</a></li>
<li><a href="http://tutorials.jenkov.com/java-util-concurrent/java-fork-and-join-forkjoinpool.html" target="_blank" rel="noopener">http://tutorials.jenkov.com/java-util-concurrent/java-fork-and-join-forkjoinpool.html</a></li>
<li><a href="http://coopsoft.com/ar/CalamityArticle.html" target="_blank" rel="noopener">http://coopsoft.com/ar/CalamityArticle.html</a></li>
<li><a href="http://www.infoq.com/cn/articles/fork-join-introduction" target="_blank" rel="noopener">http://www.infoq.com/cn/articles/fork-join-introduction</a></li>
</ul>

          
        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.todzhang.com/2018-06-01-DevOps-Philosophy/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Todd Zhang">
      <meta itemprop="description" content="Contact me via phray.zhang@gmail.com or wechat at helloworld_2000">
      <meta itemprop="image" content="/images/globe.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Clouds & Docker">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
              
              <a href="/2018-06-01-DevOps-Philosophy/" class="post-title-link" itemprop="url">DevOps-Philosophy</a>
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2018-06-02 01:21:13" itemprop="dateCreated datePublished" datetime="2018-06-02T01:21:13+10:00">2018-06-02</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-05-31 23:03:27" itemprop="dateModified" datetime="2019-05-31T23:03:27+10:00">2019-05-31</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h2 id="DevOps-Model-Defined"><a href="#DevOps-Model-Defined" class="headerlink" title="DevOps Model Defined"></a>DevOps Model Defined</h2><p>DevOps is the combination of cultural philosophies, practices, and tools that increases an organization’s ability to deliver applications and services at high velocity: evolving and improving products at a faster pace than organizations using traditional software development and infrastructure management processes. This speed enables organizations to better serve their customers and compete more effectively in the market.</p>
<p><img src="http://cloudsdocker.github.io/images/DevOps.png" alt></p>
<h2 id="What’s-means-to-team"><a href="#What’s-means-to-team" class="headerlink" title="What’s means to team"></a>What’s means to team</h2><p> These two teams are merged into a single team where the engineers work across the entire application lifecycle, from development and test to deployment to operations, and develop a range of skills not limited to a single function.</p>
<h2 id="DevSecOps"><a href="#DevSecOps" class="headerlink" title="DevSecOps"></a>DevSecOps</h2><p> In some DevOps models, quality assurance and security teams may also become more tightly integrated with development and operations and throughout the application lifecycle. When security is the focus of everyone on a DevOps team, this is sometimes referred to as DevSecOps.</p>
<h1 id="Benefits"><a href="#Benefits" class="headerlink" title="Benefits"></a>Benefits</h1><ul>
<li>Velocity: microservices and continuous delivery let teams take ownership of services and then release updates to them quicker.</li>
<li>Reliablity: CI, CD, automated testing</li>
<li>Governmence:  using infrastructure as code and policy as code, you can define and then track compliance at scale.</li>
</ul>
<h2 id="mindset"><a href="#mindset" class="headerlink" title="mindset"></a>mindset</h2><p>DevOps Cultural Philosophy<br>Transitioning to DevOps requires a change in culture and mindset. At its simplest, DevOps is about removing the barriers between two traditionally siloed teams, development and operations. In some organizations, there may not even be separate development and operations teams; engineers may do both. </p>
<h1 id="Practice"><a href="#Practice" class="headerlink" title="Practice"></a>Practice</h1><h2 id="very-frequent-but-small-release"><a href="#very-frequent-but-small-release" class="headerlink" title="very frequent but small release"></a>very frequent but small release</h2><p>One fundamental practice is to perform very frequent but small updates. This is how organizations innovate faster for their customers. These updates are usually more incremental in nature than the occasional updates performed under traditional release practices. Frequent but small updates make each deployment less risky. They help teams address bugs faster because teams can identify the last deployment that caused the error. </p>
<h2 id="microservices"><a href="#microservices" class="headerlink" title="microservices"></a>microservices</h2><p>use a microservices architecture to make their applications more flexible and enable quicker innovation.This architecture reduces the coordination overhead of updating applications, and when each service is paired with small, agile teams who take ownership of each service, organizations can move more quickly.</p>
<h1 id="Tech-Concepts"><a href="#Tech-Concepts" class="headerlink" title="Tech Concepts"></a>Tech Concepts</h1><h2 id="Continuous-Integration"><a href="#Continuous-Integration" class="headerlink" title="Continuous Integration"></a>Continuous Integration</h2><p>Continuous integration is a software development practice where developers regularly merge their code changes into a central repository, after which automated builds and tests are run. The key goals of continuous integration are to find and address bugs quicker, improve software quality, and reduce the time it takes to validate and release new software updates.</p>
<h2 id="Continuous-Delivery"><a href="#Continuous-Delivery" class="headerlink" title="Continuous Delivery"></a>Continuous Delivery</h2><p>Continuous delivery is a software development practice where code changes are automatically built, tested, and prepared for a release to production. <code>It expands upon continuous integration by deploying all code changes to a testing environment and/or a production environment after the build stage</code>. When continuous delivery is implemented properly, developers will always have a deployment-ready build artifact that has passed through a standardized test process.</p>
<h2 id="Monitoring-and-Logging"><a href="#Monitoring-and-Logging" class="headerlink" title="Monitoring and Logging"></a>Monitoring and Logging</h2><p>Organizations monitor metrics and logs to see how application and infrastructure performance impacts the experience of their product’s end user. By capturing, categorizing, and then analyzing data and logs generated by applications and infrastructure, organizations understand how changes or updates impact users, shedding insights into the root causes of problems or unexpected changes. Active monitoring becomes increasingly important as services must be available 24/7 and as application and infrastructure update frequency increases. Creating alerts or performing real-time analysis of this data also helps organizations more proactively monitor their services.</p>
<h2 id="Communication-and-Collaboration"><a href="#Communication-and-Collaboration" class="headerlink" title="Communication and Collaboration"></a>Communication and Collaboration</h2><p>Increased communication and collaboration in an organization is one of the key cultural aspects of DevOps. The use of DevOps tooling and automation of the software delivery process establishes collaboration by physically bringing together the workflows and responsibilities of development and operations.</p>

          
        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.todzhang.com/2017-04-28-Facial-Recognition_en/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Todd Zhang">
      <meta itemprop="description" content="Contact me via phray.zhang@gmail.com or wechat at helloworld_2000">
      <meta itemprop="image" content="/images/globe.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Clouds & Docker">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
              
              <a href="/2017-04-28-Facial-Recognition_en/" class="post-title-link" itemprop="url">A Facial Recognition utility in a dozen of LOC</a>
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2017-04-28 06:40:12" itemprop="dateCreated datePublished" datetime="2017-04-28T06:40:12+10:00">2017-04-28</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-05-31 23:03:27" itemprop="dateModified" datetime="2019-05-31T23:03:27+10:00">2019-05-31</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h1 id="A-Facial-Recognition-utility-in-a-dozen-of-python-LOC-Lines-Of-Code"><a href="#A-Facial-Recognition-utility-in-a-dozen-of-python-LOC-Lines-Of-Code" class="headerlink" title="A Facial Recognition utility in a dozen of python LOC (Lines Of Code)"></a>A Facial Recognition utility in a dozen of python LOC (Lines Of Code)</h1><h2 id="CV-Computer-Vision"><a href="#CV-Computer-Vision" class="headerlink" title="CV (Computer Vision)"></a>CV (Computer Vision)</h2><p>I have been soak myself in open sourced libraries, such as OpenCV. I gradually came to discern concepts such as <em>Machine Learning</em> , <em>Deep Learning</em> are not academic standing water. As a matter of fact, those elusive topics and certain pragmatic use cases could coalesce in a amount of interesting products. For instance, in past couple of months, there were a hype of <em>guess-ages-by-photo</em>, below screenshot depicts such.</p>
<p><img src="http://cloudsdocker.github.io/images/facial_howold.jpg" alt></p>
<p>What a seductive one! Initially been attracted by such funky features, after second thoughts, I found at the heart of it is two cohesive parts, the first one is how to locate <em>human faces</em> from background and whole picture, consequently to have a ballpark <em>age</em> guess for the recognized the faces. You may guess how difficult to codify a program to implement the 1st feature. Actually no need chunks of code, at here purely a dozen of lines of code are necessitated (actually only 10 lines of code, excluding space line and comments). I’d like to piggyback on such tiny utility to elaborate advanced topics of Computer Visions.</p>
<h3 id="Faces-recognition"><a href="#Faces-recognition" class="headerlink" title="Faces recognition"></a>Faces recognition</h3><p>Actually <em>face recognition</em> is not new to us, this feature prevailing in so-called <em>auto focus</em> in DC (Digital Camera) and many main stream smart phone built-in cameras. Just like below photo. You can get a sense of how <em>commonplace</em> of face recognition , which is becoming a widely used technology around us.</p>
<p><img src="http://cloudsdocker.github.io/images/iPhone-camera-face-recognition.jpg" alt></p>
<p>Theoretically speaking, face recognition is also called <em>face detection</em>, it’s a type of technology/program to electronically identify human frontal faces in digital images, such as photos, camera or surveillance. Further more, face detection is kind of objects detection in computer vision area. Which will locate object (e.g. human face) and get the size.</p>
<h2 id="My-‘10-LOC-program’"><a href="#My-‘10-LOC-program’" class="headerlink" title="My ‘10 LOC program’"></a>My ‘10 LOC program’</h2><p>First of all, let’s have some visual and concrete feeling of this program, below screenshot is the source code.</p>
<p><img src="http://cloudsdocker.github.io/images/facial_code_preview.png" alt></p>
<p>The whole program source code can be found at  <a href="https://github.com/CloudsDocker/pyFacialRecognition" target="_blank" rel="noopener">this github repository</a> <a href="https://github.com/CloudsDocker/pyFacialRecognition" target="_blank" rel="noopener">https://github.com/CloudsDocker/pyFacialRecognition</a> . Please feel free to <em>fork</em> , check it out and have a try. I’ll walk through this program one line by one line at this blog.</p>
<p>“You serious? This is all the problem, just aforementioned 10 lines?” Let’s first take a look at the actual run output.</p>
<h3 id="Here-is-the-origional-image"><a href="#Here-is-the-origional-image" class="headerlink" title="Here is the origional image"></a>Here is the origional image</h3><p><img src="http://cloudsdocker.github.io/images/facial_oriImage.jpg" alt></p>
<h3 id="Below-is-the-result-of-execution-of-this-tiny-utility"><a href="#Below-is-the-result-of-execution-of-this-tiny-utility" class="headerlink" title="Below is the result of execution of this tiny utility"></a>Below is the result of execution of this tiny utility</h3><p>Please be advised the red rectangle around faces.<br><img src="http://cloudsdocker.github.io/images/facial_postProcessImage_en.png" alt></p>
<h2 id="Souce-Code"><a href="#Souce-Code" class="headerlink" title="Souce Code"></a>Souce Code</h2><h3 id="Prerequite"><a href="#Prerequite" class="headerlink" title="Prerequite"></a>Prerequite</h3><p>First of first, as you know, this program is composed by <strong>python</strong>,therefore, make sure you work station or laptop equiped with python, vesrion is irrelavant for this program.</p>
<p>In addition, this utility is built upon <a href="http://opencv.org/downloads.html" target="_blank" rel="noopener">OpenCV</a> (<a href="http://opencv.org/downloads.html" target="_blank" rel="noopener">http://opencv.org/downloads.html</a>), therefore please install this component as well. Just as its name suggested, it is an open source framework focus on computer vision related deep learning, surfaced decades ago. This is one Intel lab built by Rusian, which is a very active community.</p>
<p>Particulary, if you are Mac users, it’s recommended to use <em>brew</em> to setup OpenCV. Below is sample commands(The 1st line of following command may raise some errors, in that case please contact me via the link at the rear of this blog):</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">brew tap homebrew/science</span><br><span class="line">brew install opencv</span><br></pre></td></tr></table></figure>

<p>Upon completion of preceding scripts, you can execute following scripts to verify whether it’s installed success or not, e.g. it means all fine if no exception/errors raised</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import cv2</span><br></pre></td></tr></table></figure>

<h3 id="Souce-Code-Dissection"><a href="#Souce-Code-Dissection" class="headerlink" title="Souce Code Dissection"></a>Souce Code Dissection</h3><p>Let’s dissect file <strong>recognizeFace_loose_en.py</strong> as one example</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2,sys</span><br></pre></td></tr></table></figure>

<ul>
<li>To import library of OpenCV and python built-in system library, which is used to parse input arguments.</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inputImageFile=sys.argv[<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<ul>
<li>To read the <strong>1st</strong> argument, which to be the file name of the image to be parsed, e.g. <em>test.jpg</em></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">faceClassifier=cv2.CascadeClassifier(<span class="string">'haarcascade_frontalface_default.xml'</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>To load HAAR Casscade Classifier, the human face recognition cascade categorizer which shipped with OpenCV. Which will do the <em>actual</em> computation, logic to recognize and size human faces from any given images.</li>
</ul>
<h3 id="Expansion-of-computer-vision-knowledge"><a href="#Expansion-of-computer-vision-knowledge" class="headerlink" title="Expansion of computer vision knowledge"></a>Expansion of computer vision knowledge</h3><p>We stop here not reading further code, avoiding perplex you, I’ll walk through certain CV topics pertaining to this blog. As for more deep concepts, please feel free to contact me or goole by yourself.</p>
<h4 id="Classifier"><a href="#Classifier" class="headerlink" title="Classifier"></a>Classifier</h4><p>In arena of computer vision and machine learning, a variaty of classifiers been and being built, to assemle special <em>domain</em> knowledge to recognize corresponding objects. For example, there are particular <strong>classifier</strong> to recognize cars, there are <em>plane</em> classifier, and classifiers to recognize smile, eyes, etc. For our case, we need a specific classifier help us to detect and locate human faces.</p>
<h4 id="Conceps-of-objects-recognize"><a href="#Conceps-of-objects-recognize" class="headerlink" title="Conceps of objects recognize"></a>Conceps of objects recognize</h4><p>Generally speaking，, to recognize one object (such as human faces) means finding and identifying objects in an image or video sequence. However, it’s neccessitate tons of sample/specimen to <strong>train</strong> machine to learn, for instance, it’s likely thousands of hundreds of digital images/video will be prepared as learning material, while all of specimen should be categorized to two mutax type,  <em>positive</em> or <em>negative</em>. e.g. phots containss <em>human face</em> and ones <strong>without</strong> <em>human face</em>. When machine read one photo, it was told this is either a positive one or negative one, then machine could gradually analysys and induce some <strong>common facets</strong> and persist to files for future usages, e.g. when given a new photo, the machine can <strong>classify</strong> it whether it’s a positive or negative. That’s why it’s called <strong><em>classifier</em></strong>.</p>
<h4 id="Cascade"><a href="#Cascade" class="headerlink" title="Cascade"></a>Cascade</h4><p>Your feeling is right, just as it’s name suggrested, cascade implies propagating something. In this case, it’s specifically means <strong>Cascade classifier</strong>. Intuitively the next question is <em>why</em> cascade is required? Let me try to articulate the underlying logic, as you know, at the heart of digital images, which is the raw material of computer vision, are pixel。For one CV process, it need to scan each pixel per pixel, while in contemporary world, size of image tend to incresing more than we expected, e.g. normall one photo taken by smart phone tend to contains millions of pixels. At the meanwhile, to fine tune and get a more accuate result of one object recognition, it tend to lots of <em>classifiers</em> to work from different point of views of the underlying photo. Therefore these two factors interwhirled together, the final number would be astronomical. Therefore, one innovative solution is <em>cascade</em>, in a nutshell, all classifiers will be splited to multiple layers, one photo will be examined by classifiers on 1st layer at the very begining, if failed, the whole CV can retain <strong><em>negative</em></strong> immediately, with fewest efforts and time cost, while majority of other classifiers won’t be executed in actual. This should significantely accelerate the whole process of CV. This is similar to <strong><em>FF(Fail Fast)</em></strong> in other areas,severed for sake of running efficiency.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objImage=cv2.imread(inputImageFile)</span><br></pre></td></tr></table></figure>

<ul>
<li>To create one OpenCV image object by loading the input digital file via OpenCV</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cvtImage=cv2.cvtColor(objImage,cv2.COLOR_BGR2GRAY)</span><br></pre></td></tr></table></figure>

<ul>
<li>Firstly, convert the digital colorful image to grayscale one, which easy the task to scan and analyse the image. Actually this is quite common in image analys area. e.g. this could eliminate those <em>noisy</em> pixel from the picture.</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">foundFaces=faceClassifier.detectMultiScale(cvtImage,scaleFactor=<span class="number">1.3</span>,minNeighbors=<span class="number">9</span>,minSize=(<span class="number">50</span>,<span class="number">50</span>),flags = cv2.cv.CV_HAAR_SCALE_IMAGE)</span><br></pre></td></tr></table></figure>

<ul>
<li>Call method <strong>detectMultiScale</strong> to recongnize object, i.e. human face in this case. The parameters overview as below:<ul>
<li>scaleFactor: For a photo, particualy from selpie, some faces are shows bigger than rest of others, due to the distance between each faces and lens. Therefore this parameter is used to config the factor, please be advised this <em>double</em> should greater than 1.0</li>
<li>minNeighbors: Because it need to gradually scan the photo by a certain <em>window</em>, i.e. a rectangle. So this parameter is telling how many other object in the vacinity to be detected, before making final decision that it’s positive or negative.</li>
<li>minSize：For aforementioend <em>window</em>, this parameter is setting the size of this rectangle.</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">" Found &#123;&#125; human faces in this image"</span>.format(len(foundFaces)))</span><br></pre></td></tr></table></figure>

<ul>
<li>To print how many faces detected, be reminded returned value is a list, each item is the actual position of every faces. Therefore, using  <em>len</em>  to print total number of ojects found.</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (x,y,w,h) <span class="keyword">in</span> foundFaces:</span><br><span class="line">    cv2.rectangle(objImage,(x,y),(x+w,y+h),(<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>),<span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>Traverese all faces detected, please be noted returning object is consist of 4 parts, i.e. the horizontal and vertial position, width and height.</li>
<li>Consequently to draw a rectangle by an off-the-shelf method from <em>OpenCV</em>. Be advised <em>(0,0,255)</em> represents color of the rectangel. It use R/G/B mode, e.g. black is (0,0,0)，white is (255,255,255)，etc. Well versed web programmer should be familiar with it.</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cv2.imshow(<span class="string">'Detected human faces highlighted. Press any key to exit. '</span>, objImage)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>To display this image via <em>opencv</em> provided method imshow, together with the rectangles we draw previously</li>
<li>The last one is one user hint, remind you can quit the applicaiton by press any key on the image display window</li>
</ul>
<h1 id="In-summary"><a href="#In-summary" class="headerlink" title="In summary"></a>In summary</h1><p>We’ve skimmed source codes and pertaining knowledge. This is just scratched the surface of this framework, hope this can open the door to more advanced topics and insights, such as hack of CAPTCHA, newly open sourced project form Yahoo, <a href="https://github.com/yahoo/open_nsfw" target="_blank" rel="noopener">NSFW</a>, Not Suitable for Work (NSFW)，to detect images with pornagraphy, etc.</p>
<p>Finally，please be reminded all related source are open sourced at github repository <a href="https://github.com/CloudsDocker/pyFacialRecognition" target="_blank" rel="noopener">https://github.com/CloudsDocker/pyFacialRecognition</a> ，please fork and sync to your local disk, check it out and paly it.</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/CloudsDocker/pyFacialRecognition.git</span><br><span class="line"><span class="built_in">cd</span> pyFacialRecognition</span><br><span class="line">./run.sh</span><br></pre></td></tr></table></figure>

<p>You can access <a href="http://cloudsdocker.github.io/2016/12/11/2016-11-22-Facial-Recognition_en/" target="_blank" rel="noopener">my blog</a>. Any comments/suggestions, feel free to contact me.</p>
<h2 id="Contact-me："><a href="#Contact-me：" class="headerlink" title="Contact me："></a>Contact me：</h2><ul>
<li><a href="mailto:phray.zhang@gmail.com" target="_blank" rel="noopener">phray.zhang@gmail.com</a> (email，whatsapp, linkedin)</li>
<li>helloworld_2000 (wechat)</li>
<li>weibo: cloudsdocker</li>
<li><a href="https://github.com/CloudsDocker/" target="_blank" rel="noopener">github</a></li>
<li><a href="http://www.jianshu.com/users/a9e7b971aafc" target="_blank" rel="noopener">jianshu</a></li>
<li>wechat：vibex</li>
</ul>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><a href="https://www.mathworks.com/discovery/object-recognition.html" target="_blank" rel="noopener">Object recognition</a></li>
<li><a href="http://docs.opencv.org/trunk/index.html" target="_blank" rel="noopener">OpenCV</a></li>
<li><a href="https://en.wikipedia.org/wiki/Haar-like_features" target="_blank" rel="noopener">HAAR features</a></li>
<li><a href="http://docs.opencv.org/trunk/d7/d8b/tutorial_py_face_detection.html" target="_blank" rel="noopener">Face Detection using Haar Cascades</a></li>
<li><a href="https://github.com/yahoo/open_nsfw" target="_blank" rel="noopener">NSFW</a></li>
</ul>

          
        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.todzhang.com/2018-05-24-GIT-scripts-bible-errors/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Todd Zhang">
      <meta itemprop="description" content="Contact me via phray.zhang@gmail.com or wechat at helloworld_2000">
      <meta itemprop="image" content="/images/globe.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Clouds & Docker">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
              
              <a href="/2018-05-24-GIT-scripts-bible-errors/" class="post-title-link" itemprop="url">GIT useful scripts or error solutions</a>
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2007-04-28 06:40:12" itemprop="dateCreated datePublished" datetime="2007-04-28T06:40:12+10:00">2007-04-28</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-05-31 23:03:27" itemprop="dateModified" datetime="2019-05-31T23:03:27+10:00">2019-05-31</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h1 id="Script-bible"><a href="#Script-bible" class="headerlink" title="Script bible"></a>Script bible</h1><h2 id="to-list-merge-conflicts-files-in-command-line"><a href="#to-list-merge-conflicts-files-in-command-line" class="headerlink" title="to list merge conflicts files in command line"></a>to list merge conflicts files in command line</h2><p>You can use either one of below three commands</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git diff --name-only --diff-filter=U</span><br><span class="line">git status --short | grep <span class="string">"^UU "</span></span><br><span class="line">git ls-files -u</span><br></pre></td></tr></table></figure>

<h2 id="One-line-command-to-add-commit-and-push-one-changed-file"><a href="#One-line-command-to-add-commit-and-push-one-changed-file" class="headerlink" title="One line command to add, commit and push one changed file"></a>One line command to add, commit and push one changed file</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status --short | awk <span class="string">'&#123;split($0, a);print a[2]&#125;'</span> | xargs git add &amp;&amp; git commit -m <span class="string">'commit changes'</span> &amp;&amp; git push origin BRANCH_NAME</span><br></pre></td></tr></table></figure>

<h2 id="to-show-files-commited-but-not-pushed"><a href="#to-show-files-commited-but-not-pushed" class="headerlink" title="to show files commited but not pushed"></a>to show files commited but not pushed</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff --<span class="built_in">stat</span> --cached origin/feature/BRANCH_NAME</span><br></pre></td></tr></table></figure>

<h2 id="to-view-file-content-changed"><a href="#to-view-file-content-changed" class="headerlink" title="to view file content changed"></a>to view file content changed</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git show PATH/abc.sql</span><br></pre></td></tr></table></figure>

<h2 id="show-file-change-logs"><a href="#show-file-change-logs" class="headerlink" title="show file change logs"></a>show file change logs</h2><p><code>git log</code> is the powerful command for this kind of tasks, as below sample commands</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> --pretty=format:<span class="string">"%h [%an] %s"</span> --graph</span><br><span class="line"></span><br><span class="line">git <span class="built_in">log</span> --pretty=format:<span class="string">"%h [%an] %s"</span> --graph --since=7.days</span><br></pre></td></tr></table></figure>

<ul>
<li>%h means short hash</li>
<li>%s is subject</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> --pretty=format:<span class="string">"%h [%an] %s"</span> --graph --since=7.days -S bower.json </span><br><span class="line">git <span class="built_in">log</span> --pretty=format:<span class="string">"%h [%an] %s"</span> --graph --since=7.days --grep Npm</span><br><span class="line">git <span class="built_in">log</span> --pretty=format:<span class="string">"%h [%an] %s"</span> --graph --since=7.days --committer todd</span><br></pre></td></tr></table></figure>

<ul>
<li>-S keyword_of_filter_files</li>
</ul>
<h2 id="Get-correct-branch-name"><a href="#Get-correct-branch-name" class="headerlink" title="Get correct branch name"></a>Get <code>correct</code> branch name</h2><p>Sometimes, if you checkout new branch with incorrect case. It still can check it out to local but you’ll get errors when you try to push it to remote.</p>
<p>To solve this issue, please use following command to get <code>correct</code> branch to checkout</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git fetch &amp;&amp; git <span class="keyword">for</span>-each-ref | grep -i <span class="string">'THE KEY WORD'</span>  | awk <span class="string">'&#123;split($0,a);print a[3]&#125;'</span></span><br><span class="line">git checkout -b BRANCH_NAME_FROM_ABOVE</span><br></pre></td></tr></table></figure>

<h1 id="Errors"><a href="#Errors" class="headerlink" title="Errors"></a>Errors</h1><h2 id="failed-to-push-change"><a href="#failed-to-push-change" class="headerlink" title="failed to push change"></a>failed to push change</h2><p>Errors as below</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fatal: unable to access <span class="string">'https://tzhang@stash.xxx.com/scm/abc.git/'</span>: SSL certificate prob</span><br><span class="line">lem: self signed certificate <span class="keyword">in</span> certificate chain</span><br></pre></td></tr></table></figure>

<h3 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions:"></a>Solutions:</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global http.sslVerify <span class="literal">false</span></span><br></pre></td></tr></table></figure>


          
        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/14/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/14/">14</a><span class="page-number current">15</span>
  </nav>


          </div>
          

        </div>
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      <div class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">

          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" src="/images/globe.gif" alt="Todd Zhang">
  <p class="site-author-name" itemprop="name">Todd Zhang</p>
  <div class="site-description motion-element" itemprop="description">Contact me via phray.zhang@gmail.com or wechat at helloworld_2000</div>
</div>
  <nav class="site-state motion-element">
      <div class="site-state-item site-state-posts">
        
          <a href="/archives/">
        
          <span class="site-state-item-count">148</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-tags">
        
          
            <a href="/tags/">
          
        
        
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
        <span class="site-state-item-count">127</span>
        <span class="site-state-item-name">tags</span>
        </a>
      </div>
    
  </nav>



        </div>
      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Todd Zhang</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v3.8.0</div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.3.0</div>

        








        
      </div>
    </footer>
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
      </div>

    

  </div>

  
  <script src="/lib/jquery/index.js?v=3.4.1"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

<script src="/js/utils.js?v=7.3.0"></script>
  <script src="/js/motion.js?v=7.3.0"></script>

<script src="/js/schemes/pisces.js?v=7.3.0"></script>


<script src="/js/next-boot.js?v=7.3.0"></script>




  




























  

  

  


  
</body>
</html>
