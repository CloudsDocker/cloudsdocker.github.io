<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Angular on My New Hugo Site</title>
    <link>http://example.org/tags/angular/</link>
    <description>Recent content in Angular on My New Hugo Site</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    
	<atom:link href="http://example.org/tags/angular/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Angulary Misc</title>
      <link>http://example.org/posts/2016-12-12-angular/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://example.org/posts/2016-12-12-angular/</guid>
      <description>Dependency Injection Angular doesn&amp;rsquo;t automatically know how you want to create instances of your services or the injector to create your service. You must configure it by specifying providers for every service.
Providers tell the injector how to create the service. Without a provider, the injector would not know that it is responsible for injecting the service nor be able to create the service.
What is difference between declarations, providers and import in NgModule  imports: is used to import supporting modules likes FormsModule, RouterModule, CommonModule, or any other custom-made feature module.</description>
    </item>
    
    <item>
      <title>How to setup nodejs to install package from intranet</title>
      <link>http://example.org/posts/2018-05-15-how-to-setup-node-config-in-intranet/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://example.org/posts/2018-05-15-how-to-setup-node-config-in-intranet/</guid>
      <description>Error of &amp;lsquo;ECONNRESET&amp;rsquo; You may face error ECONNRESET from intranet, even appropriate proxy tools (e.g. cntlm) is running. The errors may looks like
$ npm install -g @angular/cli@latest npm WARN registry Unexpected warning for http://registry.npmjs.org/: Miscellaneous Warning ECONNRESET: request to http://registry.npmjs.org/@angular%2fcli failed, reason: read ECONNRESET npm WARN registry Using stale package data from http://registry.npmjs.org/ due to a request error during revalidation. npm ERR! code ECONNRESET npm ERR! errno ECONNRESET npm ERR!</description>
    </item>
    
    <item>
      <title>ngrx</title>
      <link>http://example.org/posts/2018-01-08-ngrx/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://example.org/posts/2018-01-08-ngrx/</guid>
      <description>Why @Effects? In a simple ngrx/store project without ngrx/effects there is really no good place to put your async calls. Suppose a user clicks on a button or types into an input box and then we need to make an asynchronous call. The dumb component will be the first to know about this action from the user, and it’s handler will be called when the button is actually clicked. However, we don’t want to put the logic to do our async call right in the dumb component since we want to keep it dumb!</description>
    </item>
    
    <item>
      <title>Node errors troubleshooting</title>
      <link>http://example.org/posts/2018-05-11-node-errors-db/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://example.org/posts/2018-05-11-node-errors-db/</guid>
      <description>Here is the typical erros log:
node_modules/@types/node/index.d.ts(6202,55): error TS2304: Cannot find name &amp;#39;Map&amp;#39;. node_modules/@types/node/index.d.ts(6209,55): error TS2304: Cannot find name &amp;#39;Set&amp;#39;. node_modules/@types/node/index.d.ts(6213,64): error TS2304: Cannot find name &amp;#39;Symbol&amp;#39;. node_modules/@types/node/index.d.ts(6219,59): error TS2304: Cannot find name &amp;#39;WeakMap&amp;#39;. node_modules/@types/node/index.d.ts(6220,59): error TS2304: Cannot find name &amp;#39;WeakSet&amp;#39;. The main reason is above stuff are new to ES6, which are unavaiable in ES5. Hold no, you don&amp;rsquo;t need to change your typescript target to ES6, which may break projects and leads to tons of new regression testing.</description>
    </item>
    
    <item>
      <title>NodeJs Notes</title>
      <link>http://example.org/posts/2018-03-18-nodejs-notes/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://example.org/posts/2018-03-18-nodejs-notes/</guid>
      <description>commands to read files var lineReader = require(&amp;lsquo;readline&amp;rsquo;).createInterface({ input: require(&amp;lsquo;fs&amp;rsquo;).createReadStream(&amp;lsquo;C:\dev\node\input\git_reset_files.txt&amp;rsquo;) });
lineReader.on(&amp;lsquo;line&amp;rsquo;, function(line){ console.log(&amp;lsquo;git checkout &amp;lsquo;+line); });</description>
    </item>
    
    <item>
      <title>promise vs observiable</title>
      <link>http://example.org/posts/2017-12-01-promise-vs-observable/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://example.org/posts/2017-12-01-promise-vs-observable/</guid>
      <description>The drawback of using Promises is that they’re unable to handle data sources that produce more than one value, like mouse movements or sequences of bytes in a file stream. Also, they lack the ability to retry from failure—all present in RxJS.
The most important downside, moreover, is that because Promises are immutable, they can’t be cancelled. So, for instance, if you use a Promise to wrap the value of a remote HTTP call, there’s no hook or mechanism for you to cancel that work.</description>
    </item>
    
    <item>
      <title>Redux</title>
      <link>http://example.org/posts/2017-12-12-redux/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://example.org/posts/2017-12-12-redux/</guid>
      <description>whats @Effects You can almost think of your Effects as special kinds of reducer functions that are meant to be a place for you to put your async calls in such a way that the returned data can then be easily inserted into the store’s internal state for the application.
rule of a thumb for actions As a good rule of thumb, try not to make one reducer that handles all the actions, but also do not make a separate reducer for each action.</description>
    </item>
    
    <item>
      <title>Router in angular</title>
      <link>http://example.org/posts/2017-12-10-rxjs/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://example.org/posts/2017-12-10-rxjs/</guid>
      <description>Lettable operators RxJS 5.5, piping all the things
So now we want a way to use those operators, how could we do that?
Well, we said those operators are “lettable” that means we can use them by calling the let method on an observable:
And if we want to chain multiple lettable operators we can keep dot chaining:
import { Observable } from &amp;lsquo;rxjs/Rx&amp;rsquo;; import { filter, map, reduce } from &amp;lsquo;rxjs/operators&amp;rsquo;;</description>
    </item>
    
    <item>
      <title>rxjs pipe in depth</title>
      <link>http://example.org/posts/2018-05-15-rxjs-pipe-in-depth/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://example.org/posts/2018-05-15-rxjs-pipe-in-depth/</guid>
      <description>https://stormforger.com/blog/2016/07/08/types-of-performance-testing/
Learn more about load testing, scalability testing, stress, spike and soak testing, configuration testing as well as availability and resilience testing.
&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;15/05/2018 notes &amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash; https://blog.hackages.io/rxjs-5-5-piping-all-the-things-9d469d1b3f44 RxJS 5.5, piping all the things
So now we want a way to use those operators, how could we do that?
Well, we said those operators are “lettable” that means we can use them by calling the let method on an observable:
And if we want to chain multiple lettable operators we can keep dot chaining:</description>
    </item>
    
    <item>
      <title>RxJS reactive extension javascript</title>
      <link>http://example.org/posts/2017-12-08-router-in-angular/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://example.org/posts/2017-12-08-router-in-angular/</guid>
      <description>Streams Traditionally, the term stream was used in programming languages as an abstract object related to I/O operations such as reading a file, reading a socket, or requesting data from an HTTP server. For instance, Node.js implements readable, writable, and duplex streams for doing just this. In the RP world, we expand the definition of a stream to mean any data source that can be consumed.
A$ = [20]; 1 B$ = [22]; 2 C$ = A$.</description>
    </item>
    
    <item>
      <title>TypeScript noteworthy notes</title>
      <link>http://example.org/posts/2017-11-27-typescript/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://example.org/posts/2017-11-27-typescript/</guid>
      <description>Async Await keywords Async Await Support in TypeScript Async - Await has been supported by TypeScript since version 1.7. Asynchronous functions are prefixed with the async keyword; await suspends the execution until an asynchronous function return promise is fulfilled and unwraps the value from the Promise returned. It was only supported for target es6 transpiling directly to ES6 generators.
Troubleshotting Unexpected token &amp;hellip; That&amp;rsquo;s because your node version is lower (e.</description>
    </item>
    
    <item>
      <title>What is difference between declarations, providers and import in NgModule</title>
      <link>http://example.org/posts/2018-01-11-angular-module-declaration-import/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://example.org/posts/2018-01-11-angular-module-declaration-import/</guid>
      <description>What is difference between declarations, providers and import in NgModule  imports: is used to import supporting modules likes FormsModule, RouterModule, CommonModule, or any other custom-made feature module. makes the exported declarations of other modules available in the current module declarations are to make directives (including components and pipes) from the current module available to other directives in the current module. Selectors of directives, components or pipes are only matched against the HTML if they are declared or imported.</description>
    </item>
    
  </channel>
</rss>