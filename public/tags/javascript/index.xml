<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>JavaScript on My New Hugo Site</title>
    <link>http://example.org/tags/javascript/</link>
    <description>Recent content in JavaScript on My New Hugo Site</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    
	<atom:link href="http://example.org/tags/javascript/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Angulary Misc</title>
      <link>http://example.org/posts/2016-12-12-angular/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://example.org/posts/2016-12-12-angular/</guid>
      <description>Dependency Injection Angular doesn&amp;rsquo;t automatically know how you want to create instances of your services or the injector to create your service. You must configure it by specifying providers for every service.
Providers tell the injector how to create the service. Without a provider, the injector would not know that it is responsible for injecting the service nor be able to create the service.
What is difference between declarations, providers and import in NgModule  imports: is used to import supporting modules likes FormsModule, RouterModule, CommonModule, or any other custom-made feature module.</description>
    </item>
    
    <item>
      <title>common errors in NPM or node</title>
      <link>http://example.org/posts/2017-12-07-errors-in-npm/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://example.org/posts/2017-12-07-errors-in-npm/</guid>
      <description>code E503 code E503 when run npm install packages, e.g.
npm install pretty-data Get following error: ` npm ERR! code E503 npm ERR! 503 Service Unavailable: pretty-data@latest
npm ERR! A complete log of this run can be found in: npm ERR! xxxx\nodejs\npm-cache_logs\2017-12-07T04_16_53_679Z-debug.log
Solution: You maybe behind corporate proxy, so try execute following command
npm config set proxy http://127.0.0.1:53128 </description>
    </item>
    
    <item>
      <title>How to setup nodejs to install package from intranet</title>
      <link>http://example.org/posts/2018-05-15-how-to-setup-node-config-in-intranet/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://example.org/posts/2018-05-15-how-to-setup-node-config-in-intranet/</guid>
      <description>Error of &amp;lsquo;ECONNRESET&amp;rsquo; You may face error ECONNRESET from intranet, even appropriate proxy tools (e.g. cntlm) is running. The errors may looks like
$ npm install -g @angular/cli@latest npm WARN registry Unexpected warning for http://registry.npmjs.org/: Miscellaneous Warning ECONNRESET: request to http://registry.npmjs.org/@angular%2fcli failed, reason: read ECONNRESET npm WARN registry Using stale package data from http://registry.npmjs.org/ due to a request error during revalidation. npm ERR! code ECONNRESET npm ERR! errno ECONNRESET npm ERR!</description>
    </item>
    
    <item>
      <title>ngrx</title>
      <link>http://example.org/posts/2018-01-08-ngrx/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://example.org/posts/2018-01-08-ngrx/</guid>
      <description>Why @Effects? In a simple ngrx/store project without ngrx/effects there is really no good place to put your async calls. Suppose a user clicks on a button or types into an input box and then we need to make an asynchronous call. The dumb component will be the first to know about this action from the user, and it’s handler will be called when the button is actually clicked. However, we don’t want to put the logic to do our async call right in the dumb component since we want to keep it dumb!</description>
    </item>
    
    <item>
      <title>promise vs observiable</title>
      <link>http://example.org/posts/2017-12-01-promise-vs-observable/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://example.org/posts/2017-12-01-promise-vs-observable/</guid>
      <description>The drawback of using Promises is that they’re unable to handle data sources that produce more than one value, like mouse movements or sequences of bytes in a file stream. Also, they lack the ability to retry from failure—all present in RxJS.
The most important downside, moreover, is that because Promises are immutable, they can’t be cancelled. So, for instance, if you use a Promise to wrap the value of a remote HTTP call, there’s no hook or mechanism for you to cancel that work.</description>
    </item>
    
    <item>
      <title>reactive programing</title>
      <link>http://example.org/posts/2017-12-11-why-reactive-programming-is-outpermant/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://example.org/posts/2017-12-11-why-reactive-programming-is-outpermant/</guid>
      <description>The second advantage to a lazy subscription is that the observable doesn’t hold onto data by default. In the previous example, each event generated by the interval will be processed and then dropped. This is what we mean when we say that the observable is streaming in nature rather than pooled. This discard-by-default semantic means that you never have to worry about unbounded memory growth sneaking up on you, causing memory leaks.</description>
    </item>
    
    <item>
      <title>Redux</title>
      <link>http://example.org/posts/2017-12-12-redux/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://example.org/posts/2017-12-12-redux/</guid>
      <description>whats @Effects You can almost think of your Effects as special kinds of reducer functions that are meant to be a place for you to put your async calls in such a way that the returned data can then be easily inserted into the store’s internal state for the application.
rule of a thumb for actions As a good rule of thumb, try not to make one reducer that handles all the actions, but also do not make a separate reducer for each action.</description>
    </item>
    
    <item>
      <title>Router in angular</title>
      <link>http://example.org/posts/2017-12-10-rxjs/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://example.org/posts/2017-12-10-rxjs/</guid>
      <description>Lettable operators RxJS 5.5, piping all the things
So now we want a way to use those operators, how could we do that?
Well, we said those operators are “lettable” that means we can use them by calling the let method on an observable:
And if we want to chain multiple lettable operators we can keep dot chaining:
import { Observable } from &amp;lsquo;rxjs/Rx&amp;rsquo;; import { filter, map, reduce } from &amp;lsquo;rxjs/operators&amp;rsquo;;</description>
    </item>
    
    <item>
      <title>RxJS reactive extension javascript</title>
      <link>http://example.org/posts/2017-12-08-router-in-angular/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://example.org/posts/2017-12-08-router-in-angular/</guid>
      <description>Streams Traditionally, the term stream was used in programming languages as an abstract object related to I/O operations such as reading a file, reading a socket, or requesting data from an HTTP server. For instance, Node.js implements readable, writable, and duplex streams for doing just this. In the RP world, we expand the definition of a stream to mean any data source that can be consumed.
A$ = [20]; 1 B$ = [22]; 2 C$ = A$.</description>
    </item>
    
    <item>
      <title>TypeScript noteworthy notes</title>
      <link>http://example.org/posts/2017-11-27-typescript/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://example.org/posts/2017-11-27-typescript/</guid>
      <description>Async Await keywords Async Await Support in TypeScript Async - Await has been supported by TypeScript since version 1.7. Asynchronous functions are prefixed with the async keyword; await suspends the execution until an asynchronous function return promise is fulfilled and unwraps the value from the Promise returned. It was only supported for target es6 transpiling directly to ES6 generators.
Troubleshotting Unexpected token &amp;hellip; That&amp;rsquo;s because your node version is lower (e.</description>
    </item>
    
    <item>
      <title>What is difference between declarations, providers and import in NgModule</title>
      <link>http://example.org/posts/2018-01-11-angular-module-declaration-import/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://example.org/posts/2018-01-11-angular-module-declaration-import/</guid>
      <description>What is difference between declarations, providers and import in NgModule  imports: is used to import supporting modules likes FormsModule, RouterModule, CommonModule, or any other custom-made feature module. makes the exported declarations of other modules available in the current module declarations are to make directives (including components and pipes) from the current module available to other directives in the current module. Selectors of directives, components or pipes are only matched against the HTML if they are declared or imported.</description>
    </item>
    
  </channel>
</rss>