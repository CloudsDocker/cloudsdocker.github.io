<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>Java GC notes | Clouds &amp; Docker</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="verbose:gcverbose:gc prints right after each gc collection and prints details about each generation memory details. Here is blog on how to read verbose gc If you are trying to look for memory leak, ve">
<meta name="keywords" content="java,GC">
<meta property="og:type" content="article">
<meta property="og:title" content="Java GC notes">
<meta property="og:url" content="http://www.todzhang.com/2016-12-30-Java-GC/index.html">
<meta property="og:site_name" content="Clouds &amp; Docker">
<meta property="og:description" content="verbose:gcverbose:gc prints right after each gc collection and prints details about each generation memory details. Here is blog on how to read verbose gc If you are trying to look for memory leak, ve">
<meta property="og:locale" content="en">
<meta property="og:updated_time" content="2019-05-31T13:03:27.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java GC notes">
<meta name="twitter:description" content="verbose:gcverbose:gc prints right after each gc collection and prints details about each generation memory details. Here is blog on how to read verbose gc If you are trying to look for memory leak, ve">
  
    <link rel="alternate" href="/atom.xml" title="Clouds &amp; Docker" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Clouds &amp; Docker</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://www.todzhang.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="page-2016-12-30-Java-GC" class="article article-type-page" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016-12-30-Java-GC/" class="article-date">
  <time datetime="2019-05-31T13:03:27.000Z" itemprop="datePublished">2019-05-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Java GC notes
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="verbose-gc"><a href="#verbose-gc" class="headerlink" title="verbose:gc"></a>verbose:gc</h1><p><code>verbose:gc</code> prints right after each gc collection and prints details about each generation memory details. Here is blog on how to read verbose gc</p>
<p>If you are trying to look for memory leak, verbose:gc may not be enough. Use some visualization tools like jhat (or) visualvm etc.,</p>
<p> 4416K-&gt;512K(4928K), 0.0081170 secs</p>
<p>Before GC used memory is 4416K<br>After GC used memory is 512K<br>Total allocated memory is 4928K</p>
<p>-verbose:gc -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -Xloggc:C:/Users/tzhang17/temp/gc/gc.log</p>
<p>a typical ratio of YoungGen vs. OldGen is 1:3 or 33%.</p>
<p>Minimizing the frequency of major GC collections is a key aspect for optimal performance so it is very important that you understand and estimate how much memory you need during your peak volume.</p>
<p>Again, your type of application and data will dictate how much memory you need. Shopping cart type of applications (long lived objects) involving large and non-serialized session data typically need large Java Heap and lot of OldGen space. Stateless and XML processing heavy applications (lot of short lived objects) require proper YoungGen space in order to minimize frequency of major collections.</p>
<h2 id="Generational-collection"><a href="#Generational-collection" class="headerlink" title="Generational collection"></a>Generational collection</h2><p>According to the generational hypothesis [21], most objects die young and consequently older objects tend to live longer. Generational collection capitalises on the generational hypothesis by dividing the available memory space into multiple regions called generations. Garbage collector passes are less frequent as the generations grow older and objects are always allocated into the newest generation. If the object survives a garbage collection, it is promoted to an older generation. Each generation can have a<br>separate garbage collection strategy.</p>
<h2 id="Reference-counting"><a href="#Reference-counting" class="headerlink" title="Reference counting"></a>Reference counting</h2><p> Reference counting uses a counter per object to record the number of<br>references to the object. The pointer is incremented each time a reference towards the<br>object is created. The object is reclaimed when its reference count drops to zero. Reference<br>counting is being extensively used by scripting languages such as Perl.</p>
<h2 id="GC-strategy"><a href="#GC-strategy" class="headerlink" title="GC strategy"></a>GC strategy</h2><p>Mark-Sweep garbage collection is most times followed by a compaction phase in order to avoid memory fragmentation. The compaction phase requires moving the objects to adjacent memory locations, thus making Mark-Sweep quite an expensive algorithm for large memory multiprocessor environments, unless a multithreaded heap compactor is employed.<br>Simple reference counting is also unsuitable for high throughput environments because it requires objects to be reclaimed on pointer updates; if a pointer is removed and the reference count of the pointed object drops to zero, the runtime system is required to collect both that object and the objects it references. Furthermore, a major drawback of reference counting is its inability to collect circular data structures, such as doubly linked lists. Despite its drawbacks, the simplicity in the implementation of reference counting made it the preferred garbage collection strategy in runtime environments with a limited lifetime, such as scripting languages.</p>
<h2 id="mutable-memory"><a href="#mutable-memory" class="headerlink" title="mutable memory"></a>mutable memory</h2><p>Memory in a typical JVM is organised in a series of mutable (garbage collected) and immutable zones. Class code is usually loaded in immutable space1 and remains there until the JVM is stopped. Also, the code emitted from the JIT compiler is temporarily stored in immutable space. The actual allocations take place in the heap, which is a contiguous memory area.</p>
<p>Apart from the class member values, each object also contains<br>additional data such as a pointer to the respective class methods and flags related to locking and<br>garbage collection. In most virtual machines, object headers take up to 8–12 bytes of additional<br>storage space for each object, and can therefore sadle a program with significant performance<br>and space overhead. A lot of work has been put into compacting the object header [6], which,<br>in some cases, resulted in space savings of up to 20%.</p>
<p>A failure to allocate space for an object triggers a garbage collection cycle. The root set<br>is determined by conservatively scanning the stacks of running or suspended threads and the<br>current values of the processor registers for potential pointers to the heap. Root set acquisition<br>can also be a performance bottleneck in the case when a large number of threads is executed<br>concurrently, though these costs can be amortised using clever co-operation of the garbage<br>collector with the JIT.</p>
<h2 id="JDK-1-5"><a href="#JDK-1-5" class="headerlink" title="JDK 1.5"></a>JDK 1.5</h2><p>Sun’s JVM is an implementation of the 1.5 version of the Java language specification. It features an adaptive optimising JIT compiler, the well-known Hotspot engine, and a choice of three garbage collectors [2, 12]. Sun’s JVM is based upon a generational copying garbage collector that utilises two generations  Figure 1 presents the heap organisation, which is shared among all collectors. Allocations initially occur in the eden space and survivors are promoted to one of the survivor spaces in a copying fashion. Optionally, portions of the heap space can be allocated to individual threads (Thread-Local Heaps (TLHs)), in order to speed up allocations on large-heap multithreaded environments. Objects that reach a certain age threshold, usually measured in minor garbage collection cycles, are copied to the tenured generation where they are left untouched until a major collection occurs. A mark-compact garbage collector is used for the tenured generation.</p>
<h1 id="Tuning-advise"><a href="#Tuning-advise" class="headerlink" title="Tuning advise"></a>Tuning advise</h1><ul>
<li>Unless you have specific hardware constraints, devote as much memory as you can to the virtual machine. A big heap size offers the opportunity for less frequent, albeit more time consuming, full heap collections. In a throughput-oriented environment sacrificing pause times to allow more CPU time for the executed application is often a good compromise. Do not allow the virtual machine to be swapped out to disk, as this is catastrophic for performance. In an application server that only runs a single virtual machine, you could devote about 90% of its available RAM to it and turn off paging, without risking the failure of either the virtual machine or the operating system.</li>
<li>Calculate the memory allocation rate for your application. It is a significant measurement that you should perform by exposing the application to full workload. Its impact varies depending on the underlying hardware. As a rule of thumb, on a multiprocessor machine, each processor could easily generate more than 150MB of garbage per second. High allocation rates can be efficiently dealt with by using parallel collectors or large eden heap sizes.</li>
</ul>
<h2 id="Committed-heap"><a href="#Committed-heap" class="headerlink" title="Committed heap"></a>Committed heap</h2><p>A MemoryUsage object represents a snapshot of memory usage. Instances of the MemoryUsage class are usually constructed by methods that are used to obtain memory usage information about individual memory pool of the Java virtual machine or the heap or non-heap memory of the Java virtual machine as a whole.<br>A MemoryUsage object contains four values:</p>
<p>init    represents the initial amount of memory (in bytes) that the Java virtual machine requests from the operating system for memory management during startup. The Java virtual machine may request additional memory from the operating system and may also release memory to the system over time. The value of init may be undefined.<br>used    represents the amount of memory currently used (in bytes).<br>committed    represents the amount of memory (in bytes) that is guaranteed to be available for use by the Java virtual machine. The amount of committed memory may change over time (increase or decrease). The Java virtual machine may release memory to the system and committed could be less than init. committed will always be greater than or equal to used.<br>max    represents the maximum amount of memory (in bytes) that can be used for memory management. Its value may be undefined. The maximum amount of memory may change over time if defined. The amount of used and committed memory will always be less than or equal to max if max is defined. A memory allocation may fail if it attempts to increase the used memory such that used &gt; committed even if used &lt;= max would still be true (for example, when the system is low on virtual memory).<br>Below is a picture showing an example of a memory pool:<br>        +———————————————-+<br>        +////////////////           |                  +<br>        +////////////////           |                  +<br>        +———————————————-+</p>
<pre><code>|--------|
   init
|---------------|
       used
|---------------------------|
          committed
|----------------------------------------------|</code></pre><h1 id="Garbage-Collection-for-JVM"><a href="#Garbage-Collection-for-JVM" class="headerlink" title="Garbage Collection for JVM"></a>Garbage Collection for JVM</h1><h2 id="Interpreting-vs-compile"><a href="#Interpreting-vs-compile" class="headerlink" title="Interpreting vs compile"></a>Interpreting vs compile</h2><ul>
<li>The HotSpot JVM (and other modern JVMs) uses a combination of bytecode interpretation and dynamic compilation. When a class is first loaded, the JVM executes it by interpreting the bytecode. At some point, if a method is run often enough, the dynamic compiler kicks in and converts it to machine code; when compilation completes, it switches from interpretation to direct execution.</li>
<li>Code may also be decompiled (reverting to interpreted execution) and recompiled for various reasons, such as loading a class that invalidates assumptions made by prior compilations, or gathering sufficient profiling data to decide that a code path should be recompiled with different optimizations.</li>
<li>One of the challenges of writing good benchmarks (in any language) is that optimizing compilers are adept at spotting and eliminating dead code—code that has no effect on the outcome. Since benchmarks often don’t compute anything, they are an easy target for the optimizer. Most of the time, it is a good thing when the optimizer prunes dead code from a program, but for a benchmark this is a big problem because then you are measuring less execution than you think.</li>
<li>Many microbenchmarks perform much “better” when run with HotSpot’s -server compiler than with -client, not just because the server compiler can produce more efficient code, but also because it is more adept at optimizing dead code.</li>
<li>Writing effective performance tests requires tricking the optimizer into not optimizing away your benchmark as dead code. This requires every computed result to be used somehow by your program—in a way that does not require synchronization or substantial computation.</li>
<li>We happen to need it to verify the correctness of the algorithm, but <strong>you can ensure that a value is used by printing it out</strong>. However, you should avoid doing I/O while the test is actually running, so as not to distort the run time measurement.</li>
<li>A cheap trick for preventing a calculation from being optimized away without introducing too much overhead is to compute the hashCode of the field of some derived object, compare it to an arbitrary value such as the current value of System. nanoTime, and print a useless and ignorable message if they happen to match:<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(foo.x.hashCode()==System.nanoTime())</span><br><span class="line">	System.out.println(<span class="string">" "</span>);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>The comparison will rarely succeed, and if it does, its only effect will be to insert a harmless space character into the output. (The print method buffers output until println is called, so in the rare case that hashCode and System.nanoTime are equal no I/O is actually performed.)</p>
<ul>
<li>Not only should every computed result be used, but <strong>results should also be unguessable</strong>. Otherwise, a smart dynamic optimizing compiler is allowed to replace actions with precomputed results. </li>
</ul>
<h1 id="Java-GC"><a href="#Java-GC" class="headerlink" title="Java GC"></a>Java GC</h1><p>Java’s GC considers objects “garbage” <strong>if they aren’t reachable through a chain starting at a garbage collection root</strong>, so these objects will be collected. Even though objects may point to each other to form a cycle, they’re <strong>still garbage if they’re cut off from the root</strong>.</p>
<p>See the section on unreachable objects in Appendix A: The Truth About Garbage Collection in Java Platform Performance: Strategies and Tactics (free ebook, also available on Safari) for the gory details.</p>
<h3 id="Java-Garbage-collector-handles-circular-reference"><a href="#Java-Garbage-collector-handles-circular-reference" class="headerlink" title="Java Garbage collector handles circular-reference!"></a>Java Garbage collector handles circular-reference!</h3><p>How?</p>
<p>There are special objects called called <strong>garbage-collection roots (GC roots)</strong>. These are always reachable and so is any object that has them at its own root.</p>
<p>A simple Java application has the following GC roots:</p>
<pre><code>Local variables in the main method
The main thread
Static variables of the main class</code></pre><p>To determine which objects are no longer in use, the JVM intermittently runs what is very aptly called a <strong>mark-and-sweep algorithm</strong>. It works as follows</p>
<pre><code>The algorithm traverses all object references, starting with the GC roots, and marks every object found as alive.
All of the heap memory that is not occupied by marked objects is reclaimed. It is simply marked as free, essentially swept free of unused objects.</code></pre><p>So if any object is not reachable from the GC roots(even if it is self-referenced or cyclic-referenced) it will be subjected to garbage collection.<br>Ofcourse sometimes this may led to memory leak if programmer forgets to dereference an object.</p>
<hr>
<p>The actual answer to this is implementation dependent. The Sun JVM keeps track of some set of root objects (threads and the like), and when it needs to do a garbage collection, traces out which objects are reachable from those and saves them, discarding the rest. It’s actually more complicated than that to allow for some optimizations, but that is the basic principle. This version does not care about circular references: as long as no live object holds a reference to a dead one, it can be GCed.</p>
<p>Other JVMs can use a method known as reference counting. When a reference is created to the object, some counter is incremented, and when the reference goes out of scope, the counter is decremented. If the counter reaches zero, the object is finalized and garbage collected. This version, however, does allow for the possibility of circular references that would never be garbage collected. As a safeguard, many such JVMs include a backup method to determine which objects actually are dead which it runs periodically to resolve self-references and defrag the heap.</p>
<hr>
<p>A garbage collector starts from some “root” set of places that are always considered “reachable”, such as the <strong>CPU registers, stack, and global variables</strong>. It works by finding any pointers in those areas, and <strong>recursively finding everything they point at</strong>. Once it’s found all that, everything else is garbage.</p>
<p>There are, of course, quite a few variations, mostly for the sake of speed. For example, most modern garbage collectors are “generational”, meaning that they divide objects into generations, and as an object gets older, the garbage collector goes longer and longer between times that it tries to figure out whether that object is still valid or not – it just starts to assume that if it has lived a long time, chances are pretty good that it’ll continue to live even longer.</p>
<p>Nonetheless, the basic idea remains the same: it’s all based on starting from some root set of things that it takes for granted could still be used, and then chasing all the pointers to find what else could be in use.</p>
<p>Interesting aside: may people are often surprised by the degree of similarity between this part of a garbage collector and code for marshaling objects for things like remote procedure calls. In each case, you’re starting from some root set of objects, and chasing pointers to find all the other objects those refer to…</p>
<hr>
<h3 id="How-Garbage-Collection-Really-Works"><a href="#How-Garbage-Collection-Really-Works" class="headerlink" title="How Garbage Collection Really Works"></a>How Garbage Collection Really Works</h3><p>Many people think garbage collection collects and discards <strong>dead</strong> objects. In reality, Java garbage collection is <strong>doing the opposite</strong>! <strong>Live</strong> objects are <strong>tracked</strong> and everything else designated garbage. As you’ll see, this fundamental misunderstanding can lead to many performance problems.</p>
<h4 id="Garbage-Collection-Roots—The-Source-of-All-Object-Trees"><a href="#Garbage-Collection-Roots—The-Source-of-All-Object-Trees" class="headerlink" title="Garbage-Collection Roots—The Source of All Object Trees"></a>Garbage-Collection Roots—The Source of All Object Trees</h4><p>Every object tree must have one or more root objects. As long as the application can reach those roots, the whole tree is reachable. But when are those root objects considered reachable? Special objects called <strong>garbage-collection roots (GC roots; see Figure 2.2) are always reachable</strong> and so is any object that has a garbage-collection root at its own root.</p>
<p>There are <strong>four</strong> kinds of GC roots in Java:</p>
<ol>
<li><strong>Local variables</strong> are kept alive by the stack of a thread. This is not a real object virtual reference and thus is not visible. For all intents and purposes, local variables are GC roots.</li>
<li><strong>Active Java threads</strong> are always considered live objects and are therefore GC roots. This is especially important for thread local variables.</li>
<li><strong>Static variables</strong> are referenced by their classes. This fact makes them de facto GC roots. Classes themselves can be garbage-collected, which would remove all referenced static variables. This is of special importance when we use application servers, OSGi containers or class loaders in general. We will discuss the related problems in the Problem Patterns section.</li>
<li><strong>JNI References</strong> are Java objects that the native code has created as part of a JNI call. Objects thus created are treated specially because the JVM does not know if it is being referenced by the native code or not. Such objects represent a very special form of GC root, which we will examine in more detail in the Problem Patterns section below.</li>
</ol>
<p>Therefore, a simple Java application has the following GC roots:</p>
<ul>
<li>Local variables in the main method</li>
<li>The main thread</li>
<li>Static variables of the main class</li>
</ul>
<h4 id="Marking-and-Sweeping-Away-Garbage"><a href="#Marking-and-Sweeping-Away-Garbage" class="headerlink" title="Marking and Sweeping Away Garbage"></a>Marking and Sweeping Away Garbage</h4><p>To determine which objects are no longer in use, the JVM intermittently runs what is very aptly called a <strong>mark-and-sweep algorithm</strong>. As you might intuit, it’s a straightforward, two-step process:</p>
<ol>
<li>The algorithm traverses all object references, <strong>starting with the GC roots</strong>, and <strong>marks every object found as alive</strong>.</li>
<li>All of the heap memory that is <strong>not occupied by marked objects is <em>reclaimed</em></strong>. It is simply marked as free, essentially swept free of unused objects.</li>
</ol>
<hr>
<p>Garbage collectors which rely solely on <strong>reference counting</strong> are generally <strong>vulnerable to failing to collection self-referential structures</strong> such as this. These GCs rely on a count of the number of references to the object in order to calculate whether a given object is reachable.</p>
<p>Non-reference counting approaches apply a more comprehensive reachability test to determine whether an object is eligible to be collected. These systems define an object (or set of objects) which are always assumed to be reachable. Any object for which references are available from this object graph is considered ineligible for collection. Any object not directly accessible from this object is not. Thus, cycles do not end up affecting reachability, and can be collected.</p>
<hr>
<h3 id="Tracing-collector-vs-countering-collector"><a href="#Tracing-collector-vs-countering-collector" class="headerlink" title="Tracing collector vs. countering collector"></a>Tracing collector vs. countering collector</h3><p>There are two primary types of garbage collectors, although often a hybrid approach is found between these to suit particular needs. The first type, the one which might be the most intuitive, is a reference counting collector. The second one, which is most similar to what we described above, is a tracing collector.</p>
<h4 id="Reference-Counting-Collector"><a href="#Reference-Counting-Collector" class="headerlink" title="Reference Counting Collector"></a>Reference Counting Collector</h4><p>When a new memory object is allocated by the GC, it is given an integer count field. Every time a pointer is made to that object, a reference, the count is increased. So long as the count is a positive non-zero integer, the object is actively being referenced and is still alive.<br>When a reference to the object is removed, the count is decremented. When the count reaches zero, the object is dead and can be immediately reclaimed.<br>There are a number of points to remember about Reference Counting collectors:</p>
<ol>
<li><strong>Circular references will never be reclaimed</strong>, even if the entire set of objects is dead.</li>
<li><strong>Reference counting is pervasive</strong>: The entire program must be made aware of the system, and every pointer reference or dereference must be accompanied by an appropriate increment or decrement. Failing to maintain the count, even once in a large program, will create memory problems for your program.</li>
<li>Reference counting can be <strong>costly</strong>, because counts must be manipulated for every pointer operation, and the count must be tested against zero on ever decrement. These operations can, if used often enough, create a performance penalty for your program.</li>
</ol>
<p>These types of collectors are often called <strong>cooperative collectors</strong> because they require cooperation from the rest of the system to maintain the counts.</p>
<h4 id="Tracing-Collector"><a href="#Tracing-Collector" class="headerlink" title="Tracing Collector"></a>Tracing Collector</h4><p>Tracing collectors are entirely dissimilar from reference counting collectors, and have opposite strengths and weaknesses.<br>When the Tracing GC allocates a new memory chunk, the GC does not create a counter, but it does create a flag to determine when the item has been marked, and a pointer to the object that the GC keeps. The flags are not manipulated by the program itself, but are only manipulated by the GC when it performs a run.</p>
<p>During a GC run, the program execution typically halts. This can cause intermittent pauses in the program, pauses which can be quite long if there are many memory objects to trace.</p>
<p>The GC selects a set of root objects which are available to the current program scope and parent scopes. Starting from these objects, the GC identifies all pointers within the objects, called children. The object itself is marked as being alive, and then the collector moves to each child and marks it in the same way. The memory objects form a sort of tree structure, and the GC traverses this tree using recursive or stack-based methods.</p>
<p>At the end of the GC run, when there are no more children to be marked, all unmarked objects are considered unreachable and therefore dead. All dead objects are collected.</p>
<p>A few points to remember about Tracing GCs:</p>
<ol>
<li>Tracing GCs can be used <strong>to find cycles</strong>, memory objects whose pointers form circular structures. Reference Counting schemes cannot do this.</li>
<li>Tracing GCs <strong>cause pauses</strong> in the program, and these pauses can become unbearably long in some complex programs that use many small memory objects.</li>
<li><strong>Dead objects are not reclaimed immediately</strong>. Reclamation only occurs after a GC run. This causes a certain inefficiency in memory usage.</li>
<li>Tracing collectors do not require the program to account explicitly for memory counts or memory status updates. All memory tracking logic is stored inside the GC itself. This makes it easier to write extensions for these systems, and also makes it easier to install a Tracing GC in an existing system then to install a Reference Counting one.</li>
</ol>
<p>Tracing GCs are often called <strong>uncooperative</strong> collectors because they do not require cooperation from the rest of the system to function properly.<br>Hybrid Collectors</p>
<p>Sometimes, reference counting schemes will utilize Tracing systems to find cyclical garbage. Tracing systems may employ reference counts on very large objects to ensure they are reclaimed quickly. These are just two examples of hybridized garbage collectors that are more common then either of the two “pure” types described above.</p>
<p>In later chapters, we will discuss garbage collectors and their algorithms in more detail.</p>
<h1 id="Java-runtime-data-area"><a href="#Java-runtime-data-area" class="headerlink" title="Java runtime data area"></a>Java runtime data area</h1><p>There are 5 areas</p>
<ol>
<li>Heap</li>
<li>Java Stack</li>
<li>Method Area</li>
<li>Native method area</li>
<li>PC/Register</li>
</ol>
<h1 id="Java-GC-1"><a href="#Java-GC-1" class="headerlink" title="Java GC"></a>Java GC</h1><p>Java’s GC considers objects “garbage” <strong>if they aren’t reachable through a chain starting at a garbage collection root</strong>, so these objects will be collected. Even though objects may point to each other to form a cycle, they’re <strong>still garbage if they’re cut off from the root</strong>.</p>
<p>See the section on unreachable objects in Appendix A: The Truth About Garbage Collection in Java Platform Performance: Strategies and Tactics (free ebook, also available on Safari) for the gory details.</p>
<h3 id="Java-Garbage-collector-handles-circular-reference-1"><a href="#Java-Garbage-collector-handles-circular-reference-1" class="headerlink" title="Java Garbage collector handles circular-reference!"></a>Java Garbage collector handles circular-reference!</h3><p>How?</p>
<p>There are special objects called called <strong>garbage-collection roots (GC roots)</strong>. These are always reachable and so is any object that has them at its own root.</p>
<p>A simple Java application has the following GC roots:</p>
<pre><code>Local variables in the main method
The main thread
Static variables of the main class</code></pre><p>To determine which objects are no longer in use, the JVM intermittently runs what is very aptly called a <strong>mark-and-sweep algorithm</strong>. It works as follows</p>
<pre><code>The algorithm traverses all object references, starting with the GC roots, and marks every object found as alive.
All of the heap memory that is not occupied by marked objects is reclaimed. It is simply marked as free, essentially swept free of unused objects.</code></pre><p>So if any object is not reachable from the GC roots(even if it is self-referenced or cyclic-referenced) it will be subjected to garbage collection.<br>Ofcourse sometimes this may led to memory leak if programmer forgets to dereference an object.</p>
<hr>
<p>The actual answer to this is implementation dependent. The Sun JVM keeps track of some set of root objects (threads and the like), and when it needs to do a garbage collection, traces out which objects are reachable from those and saves them, discarding the rest. It’s actually more complicated than that to allow for some optimizations, but that is the basic principle. This version does not care about circular references: as long as no live object holds a reference to a dead one, it can be GCed.</p>
<p>Other JVMs can use a method known as reference counting. When a reference is created to the object, some counter is incremented, and when the reference goes out of scope, the counter is decremented. If the counter reaches zero, the object is finalized and garbage collected. This version, however, does allow for the possibility of circular references that would never be garbage collected. As a safeguard, many such JVMs include a backup method to determine which objects actually are dead which it runs periodically to resolve self-references and defrag the heap.</p>
<hr>
<p>A garbage collector starts from some “root” set of places that are always considered “reachable”, such as the <strong>CPU registers, stack, and global variables</strong>. It works by finding any pointers in those areas, and <strong>recursively finding everything they point at</strong>. Once it’s found all that, everything else is garbage.</p>
<p>There are, of course, quite a few variations, mostly for the sake of speed. For example, most modern garbage collectors are “generational”, meaning that they divide objects into generations, and as an object gets older, the garbage collector goes longer and longer between times that it tries to figure out whether that object is still valid or not – it just starts to assume that if it has lived a long time, chances are pretty good that it’ll continue to live even longer.</p>
<p>Nonetheless, the basic idea remains the same: it’s all based on starting from some root set of things that it takes for granted could still be used, and then chasing all the pointers to find what else could be in use.</p>
<p>Interesting aside: may people are often surprised by the degree of similarity between this part of a garbage collector and code for marshaling objects for things like remote procedure calls. In each case, you’re starting from some root set of objects, and chasing pointers to find all the other objects those refer to…</p>
<hr>
<h3 id="How-Garbage-Collection-Really-Works-1"><a href="#How-Garbage-Collection-Really-Works-1" class="headerlink" title="How Garbage Collection Really Works"></a>How Garbage Collection Really Works</h3><p>Many people think garbage collection collects and discards <strong>dead</strong> objects. In reality, Java garbage collection is <strong>doing the opposite</strong>! <strong>Live</strong> objects are <strong>tracked</strong> and everything else designated garbage. As you’ll see, this fundamental misunderstanding can lead to many performance problems.</p>
<h4 id="Garbage-Collection-Roots—The-Source-of-All-Object-Trees-1"><a href="#Garbage-Collection-Roots—The-Source-of-All-Object-Trees-1" class="headerlink" title="Garbage-Collection Roots—The Source of All Object Trees"></a>Garbage-Collection Roots—The Source of All Object Trees</h4><p>Every object tree must have one or more root objects. As long as the application can reach those roots, the whole tree is reachable. But when are those root objects considered reachable? Special objects called <strong>garbage-collection roots (GC roots; see Figure 2.2) are always reachable</strong> and so is any object that has a garbage-collection root at its own root.</p>
<p>There are <strong>four</strong> kinds of GC roots in Java:</p>
<ol>
<li><strong>Local variables</strong> are kept alive by the stack of a thread. This is not a real object virtual reference and thus is not visible. For all intents and purposes, local variables are GC roots.</li>
<li><strong>Active Java threads</strong> are always considered live objects and are therefore GC roots. This is especially important for thread local variables.</li>
<li><strong>Static variables</strong> are referenced by their classes. This fact makes them de facto GC roots. Classes themselves can be garbage-collected, which would remove all referenced static variables. This is of special importance when we use application servers, OSGi containers or class loaders in general. We will discuss the related problems in the Problem Patterns section.</li>
<li><strong>JNI References</strong> are Java objects that the native code has created as part of a JNI call. Objects thus created are treated specially because the JVM does not know if it is being referenced by the native code or not. Such objects represent a very special form of GC root, which we will examine in more detail in the Problem Patterns section below.</li>
</ol>
<p>Therefore, a simple Java application has the following GC roots:</p>
<ul>
<li>Local variables in the main method</li>
<li>The main thread</li>
<li>Static variables of the main class</li>
</ul>
<h4 id="Marking-and-Sweeping-Away-Garbage-1"><a href="#Marking-and-Sweeping-Away-Garbage-1" class="headerlink" title="Marking and Sweeping Away Garbage"></a>Marking and Sweeping Away Garbage</h4><p>To determine which objects are no longer in use, the JVM intermittently runs what is very aptly called a <strong>mark-and-sweep algorithm</strong>. As you might intuit, it’s a straightforward, two-step process:</p>
<ol>
<li>The algorithm traverses all object references, <strong>starting with the GC roots</strong>, and <strong>marks every object found as alive</strong>.</li>
<li>All of the heap memory that is <strong>not occupied by marked objects is <em>reclaimed</em></strong>. It is simply marked as free, essentially swept free of unused objects.</li>
</ol>
<hr>
<p>Garbage collectors which rely solely on <strong>reference counting</strong> are generally <strong>vulnerable to failing to collection self-referential structures</strong> such as this. These GCs rely on a count of the number of references to the object in order to calculate whether a given object is reachable.</p>
<p>Non-reference counting approaches apply a more comprehensive reachability test to determine whether an object is eligible to be collected. These systems define an object (or set of objects) which are always assumed to be reachable. Any object for which references are available from this object graph is considered ineligible for collection. Any object not directly accessible from this object is not. Thus, cycles do not end up affecting reachability, and can be collected.</p>
<hr>
<h3 id="Tracing-collector-vs-countering-collector-1"><a href="#Tracing-collector-vs-countering-collector-1" class="headerlink" title="Tracing collector vs. countering collector"></a>Tracing collector vs. countering collector</h3><p>There are two primary types of garbage collectors, although often a hybrid approach is found between these to suit particular needs. The first type, the one which might be the most intuitive, is a reference counting collector. The second one, which is most similar to what we described above, is a tracing collector.</p>
<h4 id="Reference-Counting-Collector-1"><a href="#Reference-Counting-Collector-1" class="headerlink" title="Reference Counting Collector"></a>Reference Counting Collector</h4><p>When a new memory object is allocated by the GC, it is given an integer count field. Every time a pointer is made to that object, a reference, the count is increased. So long as the count is a positive non-zero integer, the object is actively being referenced and is still alive.<br>When a reference to the object is removed, the count is decremented. When the count reaches zero, the object is dead and can be immediately reclaimed.<br>There are a number of points to remember about Reference Counting collectors:</p>
<ol>
<li><strong>Circular references will never be reclaimed</strong>, even if the entire set of objects is dead.</li>
<li><strong>Reference counting is pervasive</strong>: The entire program must be made aware of the system, and every pointer reference or dereference must be accompanied by an appropriate increment or decrement. Failing to maintain the count, even once in a large program, will create memory problems for your program.</li>
<li>Reference counting can be <strong>costly</strong>, because counts must be manipulated for every pointer operation, and the count must be tested against zero on ever decrement. These operations can, if used often enough, create a performance penalty for your program.</li>
</ol>
<p>These types of collectors are often called <strong>cooperative collectors</strong> because they require cooperation from the rest of the system to maintain the counts.</p>
<h4 id="Tracing-Collector-1"><a href="#Tracing-Collector-1" class="headerlink" title="Tracing Collector"></a>Tracing Collector</h4><p>Tracing collectors are entirely dissimilar from reference counting collectors, and have opposite strengths and weaknesses.<br>When the Tracing GC allocates a new memory chunk, the GC does not create a counter, but it does create a flag to determine when the item has been marked, and a pointer to the object that the GC keeps. The flags are not manipulated by the program itself, but are only manipulated by the GC when it performs a run.</p>
<p>During a GC run, the program execution typically halts. This can cause intermittent pauses in the program, pauses which can be quite long if there are many memory objects to trace.</p>
<p>The GC selects a set of root objects which are available to the current program scope and parent scopes. Starting from these objects, the GC identifies all pointers within the objects, called children. The object itself is marked as being alive, and then the collector moves to each child and marks it in the same way. The memory objects form a sort of tree structure, and the GC traverses this tree using recursive or stack-based methods.</p>
<p>At the end of the GC run, when there are no more children to be marked, all unmarked objects are considered unreachable and therefore dead. All dead objects are collected.</p>
<p>A few points to remember about Tracing GCs:</p>
<ol>
<li>Tracing GCs can be used <strong>to find cycles</strong>, memory objects whose pointers form circular structures. Reference Counting schemes cannot do this.</li>
<li>Tracing GCs <strong>cause pauses</strong> in the program, and these pauses can become unbearably long in some complex programs that use many small memory objects.</li>
<li><strong>Dead objects are not reclaimed immediately</strong>. Reclamation only occurs after a GC run. This causes a certain inefficiency in memory usage.</li>
<li>Tracing collectors do not require the program to account explicitly for memory counts or memory status updates. All memory tracking logic is stored inside the GC itself. This makes it easier to write extensions for these systems, and also makes it easier to install a Tracing GC in an existing system then to install a Reference Counting one.</li>
</ol>
<p>Tracing GCs are often called <strong>uncooperative</strong> collectors because they do not require cooperation from the rest of the system to function properly.<br>Hybrid Collectors</p>
<p>Sometimes, reference counting schemes will utilize Tracing systems to find cyclical garbage. Tracing systems may employ reference counts on very large objects to ensure they are reclaimed quickly. These are just two examples of hybridized garbage collectors that are more common then either of the two “pure” types described above.</p>
<p>In later chapters, we will discuss garbage collectors and their algorithms in more detail.</p>
<h1 id="to-be-callibrated"><a href="#to-be-callibrated" class="headerlink" title="to be callibrated"></a>to be callibrated</h1><p>G1 is a concurrent collector that operates on discrete regions within the heap. Each region (there are by default around 2,048 of them) can belong to either the old or new generation, and the generational regions need not be contiguous. The idea behind having regions in the old generation is that when the concurrent background threads look for unreferenced objects, some regions will contain more garbage than other regions. The actual collection of a region still requires that application threads be stopped, but G1 can focus on the regions that are mostly garbage and only spend a little bit of time emptying those regions. This approach—clearing out only the mostly garbage regions—is what gives G1 its name: Garbage First.<br>That doesn’t apply to the regions in the young generation: during a young GC, the entire young generation is either freed or promoted (to a survivor space or to the old generation). Still, the young generation is defined in terms of regions, in part because it makes resizing the generations much easier if the regions are predefined.<br>G1 has four main operations:<br>A young collection<br>A background, concurrent cycle<br>A mixed collection<br>If necessary, a full GC<br>We’ll look at each of those in turn, starting with the G1 young collection shown in Figure 6-6.</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><a href="http://www.ibm.com/developerworks/java/library/j-jtp10283/" target="_blank" rel="noopener">http://www.ibm.com/developerworks/java/library/j-jtp10283/</a></li>
<li><a href="https://blogs.oracle.com/jonthecollector/entry/our_collectors" target="_blank" rel="noopener">https://blogs.oracle.com/jonthecollector/entry/our_collectors</a></li>
<li><a href="https://en.wikipedia.org/wiki/Garbage_collection_%28computer_science%29#Tracing_garbage_collectors" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Garbage_collection_%28computer_science%29#Tracing_garbage_collectors</a></li>
<li><a href="http://users.cecs.anu.edu.au/~steveb/pubs/papers/urc-oopsla-2003.pdf" target="_blank" rel="noopener">http://users.cecs.anu.edu.au/~steveb/pubs/papers/urc-oopsla-2003.pdf</a></li>
<li><a href="https://www.dynatrace.com/resources/ebooks/javabook/" target="_blank" rel="noopener">https://www.dynatrace.com/resources/ebooks/javabook/</a></li>
<li><a href="https://en.wikipedia.org/wiki/Tracing_garbage_collection" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Tracing_garbage_collection</a></li>
<li><a href="https://en.wikibooks.org/wiki/Memory_Management/Garbage_Collection" target="_blank" rel="noopener">https://en.wikibooks.org/wiki/Memory_Management/Garbage_Collection</a></li>
<li><a href="http://flyingfrogblog.blogspot.com/2013/09/how-do-reference-counting-and-tracing.html" target="_blank" rel="noopener">http://flyingfrogblog.blogspot.com/2013/09/how-do-reference-counting-and-tracing.html</a></li>
<li><a href="https://www.dynatrace.com/resources/ebooks/javabook/how-garbage-collection-works/" target="_blank" rel="noopener">https://www.dynatrace.com/resources/ebooks/javabook/how-garbage-collection-works/</a></li>
<li><a href="http://stackoverflow.com/questions/1910194/how-does-java-garbage-collection-work-with-circular-references" target="_blank" rel="noopener">http://stackoverflow.com/questions/1910194/how-does-java-garbage-collection-work-with-circular-references</a></li>
<li><a href="http://www.java-books.us/j2ee_0003.php" target="_blank" rel="noopener">http://www.java-books.us/j2ee_0003.php</a></li>
<li><a href="http://www.ibm.com/developerworks/java/library/j-jtp10283/" target="_blank" rel="noopener">http://www.ibm.com/developerworks/java/library/j-jtp10283/</a></li>
<li><a href="https://blogs.oracle.com/jonthecollector/entry/our_collectors" target="_blank" rel="noopener">https://blogs.oracle.com/jonthecollector/entry/our_collectors</a></li>
<li><a href="https://en.wikipedia.org/wiki/Garbage_collection_%28computer_science%29#Tracing_garbage_collectors" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Garbage_collection_%28computer_science%29#Tracing_garbage_collectors</a></li>
<li><a href="http://users.cecs.anu.edu.au/~steveb/pubs/papers/urc-oopsla-2003.pdf" target="_blank" rel="noopener">http://users.cecs.anu.edu.au/~steveb/pubs/papers/urc-oopsla-2003.pdf</a></li>
<li><a href="https://www.dynatrace.com/resources/ebooks/javabook/" target="_blank" rel="noopener">https://www.dynatrace.com/resources/ebooks/javabook/</a></li>
<li><a href="https://en.wikipedia.org/wiki/Tracing_garbage_collection" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Tracing_garbage_collection</a></li>
<li><a href="https://en.wikibooks.org/wiki/Memory_Management/Garbage_Collection" target="_blank" rel="noopener">https://en.wikibooks.org/wiki/Memory_Management/Garbage_Collection</a></li>
<li><a href="http://flyingfrogblog.blogspot.com/2013/09/how-do-reference-counting-and-tracing.html" target="_blank" rel="noopener">http://flyingfrogblog.blogspot.com/2013/09/how-do-reference-counting-and-tracing.html</a></li>
<li><a href="https://www.dynatrace.com/resources/ebooks/javabook/how-garbage-collection-works/" target="_blank" rel="noopener">https://www.dynatrace.com/resources/ebooks/javabook/how-garbage-collection-works/</a></li>
<li><a href="http://stackoverflow.com/questions/1910194/how-does-java-garbage-collection-work-with-circular-references" target="_blank" rel="noopener">http://stackoverflow.com/questions/1910194/how-does-java-garbage-collection-work-with-circular-references</a></li>
<li><a href="http://www.java-books.us/j2ee_0003.php" target="_blank" rel="noopener">http://www.java-books.us/j2ee_0003.php</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.todzhang.com/2016-12-30-Java-GC/" data-id="cjxaajrpp002tbhq1tbuhlj80" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/GC/">GC</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/">java</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2016-12-30-HashCode-Contract/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Hash Code Misc
        
      </div>
    </a>
  
  
    <a href="/2017-01-02-Enum-Misc/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Java Enum Misc</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/AS400/">AS400</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/AWS/">AWS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Angular/">Angular</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Apache/">Apache</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Architect/">Architect</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/BA/">BA</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/BigData/">BigData</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CAS/">CAS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CI/">CI</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CTO/">CTO</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Camel/">Camel</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Cloud/">Cloud</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Coding/">Coding</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Collections/">Collections</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Concurrent/">Concurrent</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Cryptography/">Cryptography</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DB/">DB</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Data-Science/">Data Science</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DeepLearning/">DeepLearning</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Dev/">Dev</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DevOps/">DevOps</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Docker/">Docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Eclipse/">Eclipse</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Efficiency/">Efficiency</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Equity/">Equity</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/FX/">FX</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/FacialRecognition/">FacialRecognition</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Finance/">Finance</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Financial/">Financial</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/GC/">GC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git/">Git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/GitPages/">GitPages</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Global-Market/">Global Market</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTP/">HTTP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Haddop/">Haddop</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/IBM-Personal-Communications/">IBM Personal Communications</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/IO/">IO</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JIT/">JIT</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JVM/">JVM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScript/">JavaScript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Jboss/">Jboss</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JetBrains/">JetBrains</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MQ/">MQ</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MTF/">MTF</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Mac/">Mac</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MachineLearning/">MachineLearning</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Microservices/">Microservices</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Mifid/">Mifid</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Mint/">Mint</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MobileInternet/">MobileInternet</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MyBlog/">MyBlog</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/NavigableMap/">NavigableMap</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/NodeJs/">NodeJs</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/OpenShift/">OpenShift</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/OpenStack/">OpenStack</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Openshift/">Openshift</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Protocols/">Protocols</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python/">Python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Questions/">Questions</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/R/">R</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RESTul/">RESTul</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RMB/">RMB</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RxJS/">RxJS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SFTP/">SFTP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SOA/">SOA</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SQL/">SQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SSH/">SSH</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Sharding/">Sharding</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spark/">Spark</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Storm/">Storm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TCP/">TCP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/WAS/">WAS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/WebSphere/">WebSphere</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/XA/">XA</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/angular/">angular</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/anugar/">anugar</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/blockchain/">blockchain</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/class-loader/">class loader`</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cloud/">cloud</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/clud/">clud</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/compare/">compare</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/concurrent/">concurrent</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/data-strucutre/">data strucutre</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/database/">database</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/dead-lock/">dead lock</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/desgin/">desgin</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/development/">development</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/docker/">docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/efficiency/">efficiency</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/elasticsearch/">elasticsearch</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/enum/">enum</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ethereum/">ethereum</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/finance/">finance</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/fund/">fund</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hashcode/">hashcode</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/heavy-load/">heavy load</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/http/">http</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hyperledger/">hyperledger</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/iOS/">iOS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/intelliJ/">intelliJ</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/">java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/javascript/">javascript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/maven/">maven</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mobile-internet/">mobile internet</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ngrx/">ngrx</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/node/">node</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nodejs/">nodejs</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/principals/">principals</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/programming/">programming</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python/">python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/rfc/">rfc</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/rxjs/">rxjs</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/scraphy/">scraphy</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/security/">security</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/serialVersionUID/">serialVersionUID</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/shortcut/">shortcut</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/source-code/">source code</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spring/">spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/swift/">swift</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/tag/">tag</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/testing/">testing</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/typescript/">typescript</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/AS400/" style="font-size: 10px;">AS400</a> <a href="/tags/AWS/" style="font-size: 10px;">AWS</a> <a href="/tags/Angular/" style="font-size: 18px;">Angular</a> <a href="/tags/Apache/" style="font-size: 12px;">Apache</a> <a href="/tags/Architect/" style="font-size: 12px;">Architect</a> <a href="/tags/BA/" style="font-size: 10px;">BA</a> <a href="/tags/BigData/" style="font-size: 10px;">BigData</a> <a href="/tags/CAS/" style="font-size: 10px;">CAS</a> <a href="/tags/CI/" style="font-size: 10px;">CI</a> <a href="/tags/CTO/" style="font-size: 12px;">CTO</a> <a href="/tags/Camel/" style="font-size: 10px;">Camel</a> <a href="/tags/Cloud/" style="font-size: 10px;">Cloud</a> <a href="/tags/Coding/" style="font-size: 15px;">Coding</a> <a href="/tags/Collections/" style="font-size: 10px;">Collections</a> <a href="/tags/Concurrent/" style="font-size: 11px;">Concurrent</a> <a href="/tags/Cryptography/" style="font-size: 10px;">Cryptography</a> <a href="/tags/DB/" style="font-size: 11px;">DB</a> <a href="/tags/Data-Science/" style="font-size: 10px;">Data Science</a> <a href="/tags/DeepLearning/" style="font-size: 11px;">DeepLearning</a> <a href="/tags/Dev/" style="font-size: 10px;">Dev</a> <a href="/tags/DevOps/" style="font-size: 19px;">DevOps</a> <a href="/tags/Docker/" style="font-size: 10px;">Docker</a> <a href="/tags/Eclipse/" style="font-size: 10px;">Eclipse</a> <a href="/tags/Efficiency/" style="font-size: 10px;">Efficiency</a> <a href="/tags/Equity/" style="font-size: 10px;">Equity</a> <a href="/tags/FX/" style="font-size: 11px;">FX</a> <a href="/tags/FacialRecognition/" style="font-size: 11px;">FacialRecognition</a> <a href="/tags/Finance/" style="font-size: 10px;">Finance</a> <a href="/tags/Financial/" style="font-size: 10px;">Financial</a> <a href="/tags/GC/" style="font-size: 10px;">GC</a> <a href="/tags/Git/" style="font-size: 13px;">Git</a> <a href="/tags/GitPages/" style="font-size: 11px;">GitPages</a> <a href="/tags/Global-Market/" style="font-size: 10px;">Global Market</a> <a href="/tags/HTTP/" style="font-size: 10px;">HTTP</a> <a href="/tags/Haddop/" style="font-size: 10px;">Haddop</a> <a href="/tags/IBM-Personal-Communications/" style="font-size: 10px;">IBM Personal Communications</a> <a href="/tags/IO/" style="font-size: 10px;">IO</a> <a href="/tags/JIT/" style="font-size: 10px;">JIT</a> <a href="/tags/JVM/" style="font-size: 10px;">JVM</a> <a href="/tags/Java/" style="font-size: 18px;">Java</a> <a href="/tags/JavaScript/" style="font-size: 16px;">JavaScript</a> <a href="/tags/Jboss/" style="font-size: 10px;">Jboss</a> <a href="/tags/JetBrains/" style="font-size: 10px;">JetBrains</a> <a href="/tags/Linux/" style="font-size: 10px;">Linux</a> <a href="/tags/MQ/" style="font-size: 10px;">MQ</a> <a href="/tags/MTF/" style="font-size: 10px;">MTF</a> <a href="/tags/Mac/" style="font-size: 11px;">Mac</a> <a href="/tags/MachineLearning/" style="font-size: 10px;">MachineLearning</a> <a href="/tags/Microservices/" style="font-size: 10px;">Microservices</a> <a href="/tags/Mifid/" style="font-size: 10px;">Mifid</a> <a href="/tags/Mint/" style="font-size: 10px;">Mint</a> <a href="/tags/MobileInternet/" style="font-size: 15px;">MobileInternet</a> <a href="/tags/MyBlog/" style="font-size: 17px;">MyBlog</a> <a href="/tags/NavigableMap/" style="font-size: 10px;">NavigableMap</a> <a href="/tags/NodeJs/" style="font-size: 14px;">NodeJs</a> <a href="/tags/OpenShift/" style="font-size: 10px;">OpenShift</a> <a href="/tags/OpenStack/" style="font-size: 10px;">OpenStack</a> <a href="/tags/Openshift/" style="font-size: 10px;">Openshift</a> <a href="/tags/Protocols/" style="font-size: 10px;">Protocols</a> <a href="/tags/Python/" style="font-size: 11px;">Python</a> <a href="/tags/Questions/" style="font-size: 11px;">Questions</a> <a href="/tags/R/" style="font-size: 10px;">R</a> <a href="/tags/RESTul/" style="font-size: 10px;">RESTul</a> <a href="/tags/RMB/" style="font-size: 10px;">RMB</a> <a href="/tags/RxJS/" style="font-size: 10px;">RxJS</a> <a href="/tags/SFTP/" style="font-size: 10px;">SFTP</a> <a href="/tags/SOA/" style="font-size: 10px;">SOA</a> <a href="/tags/SQL/" style="font-size: 10px;">SQL</a> <a href="/tags/SSH/" style="font-size: 10px;">SSH</a> <a href="/tags/Sharding/" style="font-size: 10px;">Sharding</a> <a href="/tags/Spark/" style="font-size: 10px;">Spark</a> <a href="/tags/Storm/" style="font-size: 10px;">Storm</a> <a href="/tags/TCP/" style="font-size: 10px;">TCP</a> <a href="/tags/WAS/" style="font-size: 10px;">WAS</a> <a href="/tags/WebSphere/" style="font-size: 10px;">WebSphere</a> <a href="/tags/XA/" style="font-size: 10px;">XA</a> <a href="/tags/angular/" style="font-size: 12px;">angular</a> <a href="/tags/anugar/" style="font-size: 10px;">anugar</a> <a href="/tags/blockchain/" style="font-size: 12px;">blockchain</a> <a href="/tags/class-loader/" style="font-size: 10px;">class loader`</a> <a href="/tags/cloud/" style="font-size: 12px;">cloud</a> <a href="/tags/clud/" style="font-size: 10px;">clud</a> <a href="/tags/compare/" style="font-size: 10px;">compare</a> <a href="/tags/concurrent/" style="font-size: 10px;">concurrent</a> <a href="/tags/data-strucutre/" style="font-size: 10px;">data strucutre</a> <a href="/tags/database/" style="font-size: 10px;">database</a> <a href="/tags/dead-lock/" style="font-size: 10px;">dead lock</a> <a href="/tags/desgin/" style="font-size: 10px;">desgin</a> <a href="/tags/development/" style="font-size: 10px;">development</a> <a href="/tags/docker/" style="font-size: 10px;">docker</a> <a href="/tags/efficiency/" style="font-size: 10px;">efficiency</a> <a href="/tags/elasticsearch/" style="font-size: 11px;">elasticsearch</a> <a href="/tags/enum/" style="font-size: 10px;">enum</a> <a href="/tags/ethereum/" style="font-size: 10px;">ethereum</a> <a href="/tags/finance/" style="font-size: 10px;">finance</a> <a href="/tags/fund/" style="font-size: 10px;">fund</a> <a href="/tags/hashcode/" style="font-size: 10px;">hashcode</a> <a href="/tags/heavy-load/" style="font-size: 10px;">heavy load</a> <a href="/tags/http/" style="font-size: 10px;">http</a> <a href="/tags/hyperledger/" style="font-size: 11px;">hyperledger</a> <a href="/tags/iOS/" style="font-size: 10px;">iOS</a> <a href="/tags/intelliJ/" style="font-size: 10px;">intelliJ</a> <a href="/tags/java/" style="font-size: 20px;">java</a> <a href="/tags/javascript/" style="font-size: 14px;">javascript</a> <a href="/tags/maven/" style="font-size: 10px;">maven</a> <a href="/tags/mobile-internet/" style="font-size: 10px;">mobile internet</a> <a href="/tags/ngrx/" style="font-size: 10px;">ngrx</a> <a href="/tags/node/" style="font-size: 10px;">node</a> <a href="/tags/nodejs/" style="font-size: 11px;">nodejs</a> <a href="/tags/principals/" style="font-size: 10px;">principals</a> <a href="/tags/programming/" style="font-size: 10px;">programming</a> <a href="/tags/python/" style="font-size: 10px;">python</a> <a href="/tags/rfc/" style="font-size: 10px;">rfc</a> <a href="/tags/rxjs/" style="font-size: 10px;">rxjs</a> <a href="/tags/scraphy/" style="font-size: 10px;">scraphy</a> <a href="/tags/security/" style="font-size: 10px;">security</a> <a href="/tags/serialVersionUID/" style="font-size: 10px;">serialVersionUID</a> <a href="/tags/shortcut/" style="font-size: 11px;">shortcut</a> <a href="/tags/source-code/" style="font-size: 10px;">source code</a> <a href="/tags/spring/" style="font-size: 10px;">spring</a> <a href="/tags/swift/" style="font-size: 10px;">swift</a> <a href="/tags/tag/" style="font-size: 10px;">tag</a> <a href="/tags/testing/" style="font-size: 10px;">testing</a> <a href="/tags/typescript/" style="font-size: 10px;">typescript</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">June 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">May 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">June 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">April 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2007/04/">April 2007</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018-06-12-KDB/">KDB</a>
          </li>
        
          <li>
            <a href="/2019-02-26-TLS-SSL-HTTPS/">SSL certificates</a>
          </li>
        
          <li>
            <a href="/2016-09-01-Mac-Tips/">Mac tips</a>
          </li>
        
          <li>
            <a href="/2018-11-01-seconds/">Seconds</a>
          </li>
        
          <li>
            <a href="/2016-02-25-Java-Class-Loader/">Java Class Loader</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 Todd Zhang<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>